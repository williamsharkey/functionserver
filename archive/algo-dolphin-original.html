<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<link rel="icon" type="image/png" href="/algo-favicon.png">
<title>ALGO OS - Laserbarf Clubhouse</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  background: #008080;
  min-height: 100vh;
  font-family: 'MS Sans Serif', 'Segoe UI', Tahoma, sans-serif;
  overflow: hidden;
  user-select: none;
  font-size: 11px;
}

#desktop {
  position: absolute;
  top: 0; left: 0; right: 0; bottom: 28px;
  background: #008080;
  background-size: cover;
  background-position: center;
  background-repeat: no-repeat;
  overflow: hidden;
}
#desktop.bg-tile { background-size: auto; background-repeat: repeat; }
#desktop.bg-stretch { background-size: 100% 100%; }
#desktop.bg-center { background-size: auto; background-repeat: no-repeat; background-position: center; }

.desktop-icon {
  position: absolute;
  width: 70px;
  text-align: center;
  cursor: pointer;
  padding: 4px;
}
.desktop-icon:hover { background: rgba(0,0,128,0.3); }
.desktop-icon.selected { background: #000080; }
.desktop-icon .icon-img {
  font-size: 32px;
  margin-bottom: 2px;
}
.desktop-icon .icon-thumbnail {
  width: 32px;
  height: 32px;
  overflow: hidden;
  display: flex;
  align-items: center;
  justify-content: center;
}
.desktop-icon .icon-thumbnail img {
  max-width: 32px;
  max-height: 32px;
  object-fit: contain;
  border: 1px solid #808080;
}
.desktop-icon span {
  display: block;
  font-size: 11px;
  color: white;
  text-shadow: 1px 1px #000;
  word-wrap: break-word;
}

.window {
  position: absolute;
  background: #c0c0c0;
  border: 2px outset #dfdfdf;
  box-shadow: 1px 1px 0 #000;
  display: flex;
  flex-direction: column;
}
.window.minimized { display: none; }
.window-titlebar {
  background: linear-gradient(90deg, #000080, #1084d0);
  color: white;
  padding: 2px 4px;
  display: flex;
  align-items: center;
  cursor: move;
  font-weight: bold;
  font-size: 11px;
}
.window.inactive .window-titlebar { background: linear-gradient(90deg, #808080, #a0a0a0); }
.window-titlebar .title { flex: 1; display: flex; align-items: center; gap: 4px; }
.window-btn {
  width: 16px; height: 14px;
  background: #c0c0c0;
  border: 2px outset #fff;
  font-size: 9px; font-weight: bold;
  display: flex; align-items: center; justify-content: center;
  cursor: pointer;
  margin-left: 2px;
}
.window-btn:active { border-style: inset; }

/* Windows 95 style buttons */
.win95-btn {
  padding: 4px 8px;
  background: #c0c0c0;
  border: 2px outset #fff;
  font-size: 11px;
  cursor: pointer;
}
.win95-btn:hover { background: #d0d0d0; }
.win95-btn:active { border-style: inset; }
.win95-btn.active { background: #a0a0a0; border-style: inset; }
.win95-select {
  padding: 2px 4px;
  border: 2px inset #808080;
  background: white;
  font-size: 11px;
}

/* Drop zone styling */
.algo-drop-hover { outline: 2px dashed #000080 !important; background: rgba(0,0,128,0.1) !important; }

.window-content {
  flex: 1;
  overflow: auto;
  background: white;
  border: 2px inset #808080;
  margin: 2px;
}
.window-resize {
  position: absolute;
  right: 0;
  bottom: 0;
  width: 16px;
  height: 16px;
  cursor: nwse-resize;
  background: linear-gradient(135deg, transparent 50%, #808080 50%, #808080 60%, transparent 60%, transparent 70%, #808080 70%, #808080 80%, transparent 80%);
}
.window-menubar {
  background: #c0c0c0;
  padding: 1px 2px;
  display: flex;
  gap: 2px;
  position: relative;
}
.window-menubar .menu-item {
  padding: 2px 8px;
  cursor: pointer;
  position: relative;
}
.window-menubar .menu-item:hover { background: #000080; color: white; }

/* Dropdown menu - fixed positioning */
.dropdown-menu {
  position: absolute;
  top: 100%;
  left: 0;
  background: #c0c0c0;
  border: 2px outset #fff;
  display: none;
  z-index: 1000;
  min-width: 140px;
}
.dropdown-menu.visible { display: block; }
.dropdown-item { padding: 4px 20px 4px 8px; cursor: pointer; white-space: nowrap; }
.dropdown-item:hover { background: #000080; color: white; }

/* CHM Help Viewer */
.chm-viewer { display: flex; height: 100%; }
.chm-sidebar {
  width: 180px;
  background: #f0f0f0;
  border-right: 1px solid #808080;
  overflow-y: auto;
  font-size: 11px;
}
.chm-tree-item {
  padding: 2px 4px 2px 20px;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 4px;
}
.chm-tree-item:hover { background: #cce8ff; }
.chm-tree-item.active { background: #000080; color: white; }
.chm-content {
  flex: 1;
  padding: 10px;
  overflow-y: auto;
  font-size: 12px;
  line-height: 1.5;
}
.chm-content h1 { color: #000080; font-size: 18px; margin-bottom: 10px; }
.chm-content h2 { color: #000080; font-size: 14px; margin: 15px 0 8px; }
.chm-content a { color: #0000ff; }
.chm-content code { background: #f0f0f0; padding: 1px 4px; font-family: monospace; }

/* IDE */
.ide-container { display: flex; flex-direction: column; height: 100%; }
.ide-main { display: flex; flex: 1; min-height: 0; }
.ide-editor {
  flex: 1;
  display: flex;
  flex-direction: column;
  border-right: 2px solid #808080;
  min-width: 250px;
}
.ide-editor textarea {
  flex: 1;
  border: none;
  resize: none;
  font-family: 'Consolas', 'Courier New', monospace;
  font-size: 12px;
  padding: 8px;
  background: #1e1e1e;
  color: #d4d4d4;
  line-height: 1.4;
}
.ide-preview {
  flex: 1;
  display: flex;
  flex-direction: column;
  min-width: 200px;
  background: #f0f0f0;
}
.ide-preview-header {
  background: #c0c0c0;
  padding: 2px 8px;
  font-weight: bold;
  border-bottom: 1px solid #808080;
  display: flex;
  justify-content: space-between;
  align-items: center;
}
.ide-preview-content {
  flex: 1;
  overflow: auto;
  background: #fff;
  position: relative;
}
.ide-console {
  height: 100px;
  border-top: 2px solid #808080;
  display: flex;
  flex-direction: column;
  background: #1e1e1e;
}
.ide-console.collapsed { height: 22px; }
.ide-console-header {
  background: #2d2d2d;
  padding: 2px 8px;
  font-weight: bold;
  color: #d4d4d4;
  font-size: 10px;
  cursor: pointer;
  display: flex;
  justify-content: space-between;
}
.ide-console-content {
  flex: 1;
  padding: 4px 8px;
  font-family: 'Consolas', monospace;
  font-size: 11px;
  overflow-y: auto;
  color: #d4d4d4;
}
.ide-console-content .error { color: #f44; }
.ide-console-content .warn { color: #fa0; }
.ide-console-content .info { color: #4af; }
.ide-output { flex: 1; display: flex; flex-direction: column; }
.ide-output-header {
  background: #c0c0c0;
  padding: 2px 8px;
  font-weight: bold;
  border-bottom: 1px solid #808080;
}
.ide-output-content {
  flex: 1;
  padding: 8px;
  font-family: 'Courier New', monospace;
  font-size: 11px;
  overflow-y: auto;
  background: #fff;
}
.ide-toolbar {
  background: #c0c0c0;
  padding: 2px 4px;
  display: flex;
  gap: 4px;
  border-bottom: 1px solid #808080;
  align-items: center;
}
.ide-toolbar select {
  padding: 2px;
  font-size: 11px;
}

/* Browser */
.browser-toolbar {
  background: #c0c0c0;
  padding: 4px;
  display: flex;
  gap: 4px;
  align-items: center;
  border-bottom: 1px solid #808080;
}
.browser-url {
  flex: 1;
  padding: 2px 4px;
  border: 2px inset #808080;
  font-size: 11px;
}
.browser-frame { flex: 1; border: none; background: white; }

/* Folder */
.folder-content {
  padding: 10px;
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
}
.folder-item {
  width: 70px;
  text-align: center;
  cursor: pointer;
  padding: 4px;
}
.folder-item:hover { background: #cce8ff; }
.folder-item .icon-img { font-size: 32px; }
.folder-item span { font-size: 11px; display: block; }

/* Wizard */
.wizard-container { padding: 15px; display: flex; flex-direction: column; height: 100%; }
.wizard-header { display: flex; align-items: center; gap: 10px; margin-bottom: 15px; }
.wizard-header .icon { font-size: 48px; }
.wizard-header h2 { color: #000080; }
.wizard-form { flex: 1; display: flex; flex-direction: column; gap: 10px; }
.wizard-form label { font-weight: bold; }
.wizard-form input, .wizard-form textarea {
  padding: 4px;
  border: 2px inset #808080;
  font-family: inherit;
}
.wizard-form textarea { flex: 1; min-height: 100px; resize: none; }
.wizard-buttons { display: flex; gap: 8px; justify-content: flex-end; margin-top: 10px; }
.wizard-buttons button { padding: 4px 16px; }
.wizard-status { margin-top: 10px; padding: 8px; background: #f0f0f0; border: 1px solid #808080; }

/* Chat */
.chat-container { display: flex; flex-direction: column; height: 100%; }
.chat-messages {
  flex: 1;
  overflow-y: auto;
  padding: 8px;
  background: #fff;
  border-bottom: 1px solid #808080;
}
.chat-msg { margin-bottom: 8px; }
.chat-msg .name { font-weight: bold; color: #000080; }
.chat-msg .time { color: #888; font-size: 10px; }
.chat-input-area { display: flex; gap: 4px; padding: 4px; background: #c0c0c0; }
.chat-input-area input { flex: 1; padding: 4px; border: 2px inset #808080; }

/* Users list */
.users-list { padding: 8px; background: #f0f0f0; border-left: 1px solid #808080; width: 120px; }
.users-list h4 { margin-bottom: 8px; color: #000080; }
.user-item { padding: 2px 4px; display: flex; align-items: center; gap: 4px; }
.user-dot { width: 8px; height: 8px; border-radius: 50%; background: #0f0; }

/* Sticky Notes */
.sticky-note {
  position: absolute;
  width: 200px;
  min-height: 150px;
  background: #ffff88;
  box-shadow: 2px 2px 8px rgba(0,0,0,0.3);
  display: flex;
  flex-direction: column;
  font-family: 'Comic Sans MS', 'Segoe Print', cursive, sans-serif;
  z-index: 50;
}
.sticky-note.pink { background: #ffb8d0; }
.sticky-note.blue { background: #b8d4ff; }
.sticky-note.green { background: #b8ffb8; }
.sticky-note-header {
  background: rgba(0,0,0,0.1);
  padding: 4px 6px;
  font-size: 10px;
  display: flex;
  align-items: center;
  cursor: move;
}
.sticky-note-header .close-btn {
  margin-left: auto;
  cursor: pointer;
  font-weight: bold;
  padding: 0 4px;
}
.sticky-note-header .close-btn:hover { color: red; }
.sticky-note-content {
  flex: 1;
  padding: 8px;
}
.sticky-note-content textarea {
  width: 100%;
  height: 100%;
  min-height: 100px;
  border: none;
  background: transparent;
  font-family: inherit;
  font-size: 12px;
  resize: none;
  outline: none;
}
.sticky-note-colors {
  display: flex;
  gap: 4px;
  padding: 4px;
  border-top: 1px dashed rgba(0,0,0,0.2);
}
.sticky-note-colors span {
  width: 16px;
  height: 16px;
  border-radius: 50%;
  cursor: pointer;
  border: 1px solid rgba(0,0,0,0.3);
}
.sticky-note-colors .c-yellow { background: #ffff88; }
.sticky-note-colors .c-pink { background: #ffb8d0; }
.sticky-note-colors .c-blue { background: #b8d4ff; }
.sticky-note-colors .c-green { background: #b8ffb8; }


/* Context menu "Open With" submenu */
.ctx-submenu {
  position: absolute;
  left: 100%;
  top: 0;
  background: #c0c0c0;
  border: 2px outset #fff;
  display: none;
  min-width: 100px;
  max-height: calc(100vh - 50px);
  overflow-y: auto;
}
.ctx-item.has-submenu { position: relative; }
.ctx-item.has-submenu::after { content: '‚ñ∂'; float: right; margin-left: 8px; font-size: 8px; }
.ctx-item.has-submenu:hover > .ctx-submenu { display: block; }

/* ALGO Dolphin Mascot */
#algo-dolphin {
  position: absolute;
  font-size: 32px;
  z-index: 100;
  pointer-events: none;
  filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
}
#algo-dolphin.swimming {
  animation: dolphin-bob-right 2s ease-in-out infinite;
}
#algo-dolphin.swimming[data-facing="left"] {
  animation: dolphin-bob-left 2s ease-in-out infinite;
}
@keyframes dolphin-bob-right {
  0%, 100% { transform: scaleX(1) translateY(0) rotate(0deg); }
  25% { transform: scaleX(1) translateY(-8px) rotate(-5deg); }
  50% { transform: scaleX(1) translateY(0) rotate(0deg); }
  75% { transform: scaleX(1) translateY(-4px) rotate(5deg); }
}
@keyframes dolphin-bob-left {
  0%, 100% { transform: scaleX(-1) translateY(0) rotate(0deg); }
  25% { transform: scaleX(-1) translateY(-8px) rotate(5deg); }
  50% { transform: scaleX(-1) translateY(0) rotate(0deg); }
  75% { transform: scaleX(-1) translateY(-4px) rotate(-5deg); }
}

/* Taskbar */
#taskbar {
  position: absolute;
  bottom: 0; left: 0; right: 0;
  height: 28px;
  background: #c0c0c0;
  border-top: 2px outset #fff;
  display: flex;
  align-items: center;
  padding: 2px;
  z-index: 9000;
}
#start-btn {
  background: #c0c0c0;
  border: 2px outset #fff;
  padding: 2px 6px;
  font-weight: bold;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 4px;
  font-size: 11px;
}
#start-btn:active, #start-btn.active { border-style: inset; }
#taskbar-windows {
  flex: 1;
  display: flex;
  gap: 2px;
  margin-left: 4px;
  overflow: hidden;
}
.taskbar-item {
  background: #c0c0c0;
  border: 2px outset #fff;
  padding: 2px 8px;
  font-size: 11px;
  cursor: pointer;
  max-width: 140px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
.taskbar-item.active { border-style: inset; background: #a0a0a0; }
.taskbar-right {
  display: flex;
  align-items: center;
  gap: 4px;
}

#clock {
  background: #c0c0c0;
  border: 2px inset #808080;
  padding: 2px 8px;
  font-size: 11px;
}

/* Start Menu */
#start-menu {
  position: absolute;
  bottom: 28px;
  left: 0;
  background: #c0c0c0;
  border: 2px outset #fff;
  display: none;
  z-index: 9999;
  min-width: 200px;
  overflow: visible;
}
#start-menu.visible { display: block; }
.start-sidebar {
  position: absolute;
  left: 0; top: 0; bottom: 0;
  width: 22px;
  background: linear-gradient(#000080, #1084d0);
  writing-mode: vertical-rl;
  color: white;
  font-weight: bold;
  font-size: 16px;
  display: flex;
  align-items: center;
  justify-content: flex-end;
  padding-bottom: 8px;
}
.start-items { margin-left: 22px; padding: 2px 0; }
.start-item {
  padding: 4px 20px 4px 8px;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 6px;
  position: relative;
}
.start-item:hover { background: #000080; color: white; }
.start-separator { border-top: 1px solid #808080; border-bottom: 1px solid white; margin: 2px 4px; }
.start-submenu {
  position: absolute;
  left: 100%;
  bottom: 0;
  background: #c0c0c0;
  border: 2px outset #fff;
  display: none;
  min-width: 140px;
  max-height: calc(100vh - 50px);
  overflow-y: auto;
}
.start-item:hover > .start-submenu { display: block; }
.start-item.has-sub::after { content: '‚ñ∂'; position: absolute; right: 6px; font-size: 8px; }

/* Context Menu */
#context-menu {
  position: absolute;
  background: #c0c0c0;
  border: 2px outset #fff;
  display: none;
  z-index: 10000;
  min-width: 120px;
}
#context-menu.visible { display: block; }
.ctx-item { padding: 4px 20px 4px 8px; cursor: pointer; }
.ctx-item:hover { background: #000080; color: white; }
.ctx-sep { border-top: 1px solid #808080; border-bottom: 1px solid white; margin: 2px 4px; }

/* Notepad */
.notepad-container { display: flex; flex-direction: column; height: 100%; }
.notepad-textarea {
  flex: 1;
  border: none;
  resize: none;
  font-family: 'Courier New', monospace;
  font-size: 12px;
  padding: 4px;
}

/* ALGO sprite */
#algo-sprite { position: absolute; cursor: pointer; z-index: 100; }
#speech-bubble {
  position: absolute;
  background: white;
  border: 2px solid #000;
  border-radius: 10px;
  padding: 8px;
  max-width: 200px;
  font-size: 11px;
  display: none;
  z-index: 101;
}

/* Mobile styles */
@media (max-width: 768px) {
  body { font-size: 14px; }
  .desktop-icon {
    width: 90px;
    padding: 8px;
  }
  .desktop-icon .icon-img {
    font-size: 48px;
  }
  .desktop-icon .icon-thumbnail {
    width: 48px;
    height: 48px;
  }
  .desktop-icon .icon-thumbnail img {
    max-width: 48px;
    max-height: 48px;
  }
  .desktop-icon span {
    font-size: 13px;
  }
  #taskbar {
    height: 40px;
  }
  #start-btn {
    font-size: 14px;
    padding: 4px 12px;
  }
  .taskbar-item {
    font-size: 12px;
    padding: 4px 10px;
    max-width: 120px;
  }
  #clock {
    font-size: 13px;
    padding: 4px 10px;
  }
  .window-titlebar {
    padding: 4px 6px;
    font-size: 13px;
  }
  .window-btn {
    width: 20px;
    height: 20px;
    font-size: 14px;
  }
  #start-menu {
    width: 220px;
    font-size: 13px;
    bottom: 40px; /* Match mobile taskbar height */
  }
  .start-item {
    padding: 8px 12px;
  }
  .ctx-item {
    padding: 8px 16px;
    font-size: 13px;
  }
  .sticky-note {
    min-width: 140px;
    min-height: 120px;
    font-size: 13px;
  }
}
</style>
</head>
<body>

<div id="desktop"></div>
<div id="algo-dolphin" class="swimming">üê¨</div>

<div id="taskbar">
  <div id="start-btn" onclick="toggleStartMenu()">
    <span style="font-size:14px;">üê¨</span> Start
  </div>
  <div id="taskbar-windows"></div>
  <div class="taskbar-right">
    <div id="clock"></div>
  </div>
</div>

<div id="start-menu">
  <div class="start-sidebar">ALGO98</div>
  <div class="start-items">
    <div class="start-item has-sub">
      <span>üìÅ</span> Programs
      <div class="start-submenu" id="programs-menu">
        <div class="start-item" onclick="openNotepad()"><span>üìù</span> Notepad</div>
        <div class="start-item" onclick="openJSIDE()"><span>üìú</span> JavaScript.IDE</div>
        <div class="start-item" onclick="openBrowser()"><span>üåê</span> Web Browser</div>
        <div class="start-separator"></div>
        <div class="start-item" onclick="openClaudeWizard()"><span>ü§ñ</span> Claude Wizard</div>
        <div class="start-item" onclick="openGeminiWizard()"><span>üíé</span> Gemini Wizard</div>
        <div class="start-item" onclick="openGPTWizard()"><span>üß†</span> GPT Wizard</div>
        <div class="start-separator"></div>
        <div class="start-item" onclick="openChat()"><span>üí¨</span> ALGO Chat</div>
        <div class="start-item" onclick="openWebcam()"><span>üìπ</span> ALGO Webcam</div>
        <div class="start-separator"></div>
        <div class="start-item" onclick="openMidiEditor()"><span>üéπ</span> MIDI Editor</div>
        <div class="start-item" onclick="openShadeStation()"><span>üé®</span> Shade Station</div>
        <div class="start-item" onclick="openBoxEditor()"><span>üì¶</span> Box Editor</div>
        <div class="start-item" onclick="openAlgoDist()"><span>üöÄ</span> ALGO DIST</div>
        <div class="start-item" onclick="openProgramManager()"><span>üìÇ</span> Program Manager</div>
        <div class="start-separator"></div>
        <div id="installed-programs-menu"></div>
      </div>
    </div>
    <div class="start-item" onclick="openDocumentation()"><span style="color:#8B0000;">üìï</span> Documentation</div>
    <div class="start-item" onclick="openHelp()"><span style="color:#8B0000;">üìô</span> ALGO OS Help</div>
    <div class="start-separator"></div>
    <div class="start-item" onclick="openNotepad()"><span>üìù</span> New Post</div>
    <div class="start-item" onclick="createStickyNote()"><span>üìå</span> New Sticky Note</div>
    <div class="start-separator"></div>
    <div class="start-item" onclick="showAbout()"><span>üê¨</span> About ALGO</div>
    <div class="start-item" onclick="openSettings()"><span>‚öôÔ∏è</span> Settings</div>
  </div>
</div>

<div id="context-menu"></div>

<div id="algo-sprite" style="left:100px;top:350px;" onclick="algoSpeak()">
  <svg width="48" height="48" viewBox="0 0 48 48">
    <ellipse cx="24" cy="24" rx="18" ry="12" fill="#1E90FF"/>
    <ellipse cx="32" cy="22" rx="4" ry="3" fill="white"/>
    <circle cx="33" cy="22" r="1.5" fill="black"/>
    <path d="M6 24 Q2 20 6 16" stroke="#1E90FF" stroke-width="3" fill="none"/>
    <path d="M42 24 L52 20" stroke="#1E90FF" stroke-width="4" fill="none"/>
    <ellipse cx="24" cy="28" rx="6" ry="2" fill="#B0E0E6"/>
  </svg>
</div>
<div id="speech-bubble"></div>

<script>
// ==================== STATE ====================
let windows = [];
let winId = 0;
let activeWin = null;
let savedFiles = [];
let globalFiles = []; // Files from /api/algo-desktop (read-only, shown for all users)
let installedPrograms = [];
let roomFolders = [];
let windowStates = {};
let apiKeys = {};
let dragWin = null;
let dragOffset = {x:0,y:0};
let resizeWin = null;
let resizeStart = {x:0,y:0,w:0,h:0};
let contextTarget = null;

// P2P Chat State
let chatPeerId = 'p' + Math.random().toString(36).substr(2, 9);
let chatPeers = {}; // peerId -> { pc, dataChannel, connected, name }
let chatRoom = 'algo-chat';
let chatName = localStorage.getItem('algo-chat-name') || 'anon';
let chatPollInterval = null;
let chatWinId = null;

// Sticky Notes State
let stickyNotes = [];
let stickyNoteId = 0;
let dragStickyNote = null;

// Icon Drag State
let dragIcon = null;
let iconDragOffset = {x:0, y:0};
let iconPositions = {}; // iconId -> {x, y}

// File Type Handlers (moved to top for early registration)
const FILE_TYPE_HANDLERS = {}; // extension -> [{ name, icon, handler, appId }]
let defaultFileHandlers = {}; // extension -> appId (which handler is default)

function registerFileHandler(extension, name, icon, handler, appId) {
  if (!FILE_TYPE_HANDLERS[extension]) FILE_TYPE_HANDLERS[extension] = [];
  const id = appId || name.toLowerCase().replace(/\s+/g, '-');
  FILE_TYPE_HANDLERS[extension].push({ name, icon, handler, appId: id });
  // Set as default if first handler for this extension
  if (!defaultFileHandlers[extension]) {
    defaultFileHandlers[extension] = id;
  }
}

function setDefaultHandler(extension, appId) {
  defaultFileHandlers[extension] = appId;
  saveState();
}

function getDefaultHandler(extension) {
  if (!FILE_TYPE_HANDLERS[extension]) return null;
  const defaultId = defaultFileHandlers[extension];
  return FILE_TYPE_HANDLERS[extension].find(h => h.appId === defaultId) || FILE_TYPE_HANDLERS[extension][0];
}

// Extract app metadata from JS code content
function extractAppMetadata(code) {
  const nameMatch = code.match(/ALGO\.app\.name\s*=\s*['"]([^'"]+)['"]/);
  const iconMatch = code.match(/ALGO\.app\.icon\s*=\s*['"]([^'"]+)['"]/);
  return {
    name: nameMatch ? nameMatch[1] : null,
    icon: iconMatch ? iconMatch[1] : null
  };
}
let stickyDragOffset = {x:0, y:0};

const HELP_CONTENT = {
  'welcome': {
    title: 'Welcome to ALGO OS',
    content: `<h1>Welcome to ALGO OS</h1>
<p>ALGO OS is your retro computing experience on Laserbarf!</p>
<h2>Getting Started</h2>
<ul>
<li><b>Double-click</b> icons to open programs</li>
<li><b>Right-click</b> for context menus</li>
<li>Use the <b>Start Menu</b> to access programs</li>
</ul>
<h2>AI Wizards</h2>
<p>Use Claude, Gemini, or GPT wizards to create new artifacts!</p>
<h2>Secret Key</h2>
<p>You're in the trusted zone with key <code>dolphin42</code></p>`
  },
  'wizards': {
    title: 'AI Wizards',
    content: `<h1>AI App Wizards</h1>
<p>Create new artifacts using AI!</p>
<h2>Setup</h2>
<ol>
<li>Open a wizard from Start ‚Üí Programs</li>
<li>Enter your API key (saved locally)</li>
<li>Describe what you want to create</li>
<li>Click Generate!</li>
</ol>
<p>Generated apps appear on your desktop.</p>`
  },
  'chat': {
    title: 'ALGO Chat',
    content: `<h1>ALGO Chat</h1>
<p>Chat with other ALGO OS users in real-time!</p>
<h2>Features</h2>
<ul>
<li>See who's online</li>
<li>Send messages</li>
<li>Messages persist in #algo-world</li>
</ul>`
  },
  'shadestation': {
    title: 'Shade Station',
    content: `<h1>Shade Station</h1>
<p>A real-time WebGL shader editor for creating visual effects.</p>
<h2>Features</h2>
<ul>
<li>Live preview as you type</li>
<li>Built-in presets (Rainbow, Plasma, Circles, Mouse)</li>
<li>Uniforms: u_time, u_resolution, u_mouse</li>
<li>Save shaders to desktop as .shader files</li>
<li>Speed control and pause</li>
</ul>
<h2>Shader Uniforms</h2>
<ul>
<li><code>u_time</code> - elapsed time in seconds</li>
<li><code>u_resolution</code> - canvas width/height</li>
<li><code>u_mouse</code> - mouse position</li>
</ul>
<h2>File Format</h2>
<p>Shade Station uses .shader files containing GLSL fragment shader code. Double-click any .shader file to open it.</p>`
  }
};

const DOC_URLS = {
  'top-secret': '/top-secret',
  'artifact-guide': '/artifact-guide',
  'secret-ai': '/secret-ai'
};

// ==================== INIT ====================
async function fetchGlobalDesktopItems() {
  try {
    const resp = await fetch('/api/algo-desktop');
    if (resp.ok) {
      const data = await resp.json();
      globalFiles = data.files || [];
      console.log('Loaded', globalFiles.length, 'global desktop items');
    }
  } catch (e) {
    console.log('Could not fetch global desktop items:', e.message);
  }
}

async function init() {
  loadState();
  await fetchGlobalDesktopItems(); // Fetch global items before creating icons
  createDesktopIcons();
  await algoAutoLoadApps(); // Load external .app.js files and distribution apps
  loadStickyNotes();
  registerNotepadFileType();
  registerShaderFileType();
  registerBoxFileType();
  registerMarkdownFileType();
  loadDesktopBackground();
  updateClock();
  setInterval(updateClock, 1000);

  document.addEventListener('click', globalClick);
  document.addEventListener('contextmenu', showContextMenu);
  document.addEventListener('mousedown', startDrag);
  document.addEventListener('mousemove', onDrag);
  document.addEventListener('mouseup', endDrag);
  document.addEventListener('paste', handleDesktopPaste);

  // ==================== IFRAME API BRIDGE ====================
  // Allow external artifacts (iframes) to communicate with ALGO OS
  // Documentation: https://laserbarf.com/algo-api-docs
  window.addEventListener('message', function(event) {
    // Accept messages from any origin for now (artifacts can be anywhere)
    const msg = event.data;
    if (!msg || msg.type !== 'ALGO_API') return;

    console.log('ALGO API:', msg.method, msg.args);
    const source = event.source;
    const respond = (result) => {
      if (source) source.postMessage({ type: 'ALGO_RESPONSE', id: msg.id, result }, '*');
    };

    switch (msg.method) {
      // ===== DOLPHIN =====
      case 'dolphinSay':
        algoSpeak(msg.args.message, msg.args.duration || 5000);
        respond({ success: true });
        break;

      case 'dolphinAnimate':
        // Wiggle the dolphin
        const dolphin = document.getElementById('algo-assistant');
        if (dolphin) {
          dolphin.style.transition = 'transform 0.1s';
          let wiggles = msg.args.count || 3;
          let i = 0;
          const wiggle = () => {
            dolphin.style.transform = i % 2 ? 'scaleX(-1) rotate(10deg)' : 'scaleX(-1) rotate(-10deg)';
            i++;
            if (i < wiggles * 2) setTimeout(wiggle, 100);
            else dolphin.style.transform = 'scaleX(-1)';
          };
          wiggle();
        }
        respond({ success: true });
        break;

      // ===== FILES =====
      case 'saveFile':
        const existingIdx = savedFiles.findIndex(f => f.name === msg.args.name);
        if (existingIdx >= 0) {
          savedFiles[existingIdx] = { ...savedFiles[existingIdx], ...msg.args };
        } else {
          savedFiles.push({ name: msg.args.name, content: msg.args.content, type: msg.args.type || 'text', icon: msg.args.icon });
        }
        saveState(); createDesktopIcons();
        respond({ success: true });
        break;

      case 'readFile':
        const rfile = savedFiles.find(f => f.name === msg.args.name);
        respond({ success: !!rfile, file: rfile });
        break;

      case 'listFiles':
        respond({ success: true, files: savedFiles.map(f => ({ name: f.name, type: f.type, icon: f.icon })) });
        break;

      case 'deleteFile':
        const delIdx = savedFiles.findIndex(f => f.name === msg.args.name);
        if (delIdx >= 0) { savedFiles.splice(delIdx, 1); saveState(); createDesktopIcons(); respond({ success: true }); }
        else { respond({ success: false, error: 'File not found' }); }
        break;

      // ===== WINDOWS =====
      case 'createWindow':
        const newWinId = createWindow(msg.args);
        respond({ success: true, windowId: newWinId });
        break;

      case 'closeWindow':
        const closeWin = windows.find(w => w.id === msg.args.windowId);
        if (closeWin) { closeWindow(msg.args.windowId); respond({ success: true }); }
        else { respond({ success: false, error: 'Window not found' }); }
        break;

      case 'listWindows':
        respond({ success: true, windows: windows.map(w => ({ id: w.id, title: w.title, minimized: w.minimized })) });
        break;

      case 'focusWindow':
        const focusWin = windows.find(w => w.id === msg.args.windowId);
        if (focusWin) { focusWindow(msg.args.windowId); respond({ success: true }); }
        else { respond({ success: false, error: 'Window not found' }); }
        break;

      // ===== APPS =====
      case 'openNotepad':
        openNotepad(msg.args.content || '', msg.args.filename);
        respond({ success: true });
        break;

      case 'openBrowser':
        openBrowser(msg.args.url || 'https://laserbarf.com');
        respond({ success: true });
        break;

      case 'openChat':
        openChat();
        respond({ success: true });
        break;

      // ===== STICKY NOTES =====
      case 'createStickyNote':
        const noteId = Date.now();
        const newNote = {
          id: noteId,
          text: msg.args.text || '',
          color: msg.args.color || 'yellow',
          x: msg.args.x || 100 + Math.random() * 200,
          y: msg.args.y || 100 + Math.random() * 200
        };
        stickyNotes.push(newNote);
        renderStickyNote(newNote);
        saveStickyNotes();
        respond({ success: true, noteId });
        break;

      // ===== NOTIFICATIONS =====
      case 'notify':
        algoSpeak(msg.args.message);
        respond({ success: true });
        break;

      case 'alert':
        createWindow({
          title: msg.args.title || 'Alert',
          icon: msg.args.icon || '‚ö†Ô∏è',
          width: 300, height: 150,
          content: '<div style="padding:20px;text-align:center;">' +
            '<div style="font-size:32px;margin-bottom:10px;">' + (msg.args.icon || '‚ö†Ô∏è') + '</div>' +
            '<p>' + escapeHtml(msg.args.message || '') + '</p>' +
            '<button onclick="closeWindow(' + winId + ')" style="margin-top:10px;padding:4px 20px;">OK</button>' +
          '</div>'
        });
        respond({ success: true });
        break;

      // ===== DESKTOP =====
      case 'setWallpaper':
        desktopBackground = { type: msg.args.type || 'color', value: msg.args.value || '#008080' };
        localStorage.setItem('algo-wallpaper', JSON.stringify(desktopBackground));
        loadDesktopBackground();
        respond({ success: true });
        break;

      case 'getWallpaper':
        respond({ success: true, wallpaper: desktopBackground });
        break;

      // ===== PROGRAMS =====
      case 'installProgram':
        if (msg.args.name && msg.args.code) {
          const progId = 'artifact-' + Date.now();
          installedPrograms.push({
            id: progId,
            name: msg.args.name,
            icon: msg.args.icon || 'üéÆ',
            code: msg.args.code
          });
          saveState();
          updateProgramsMenu();
          respond({ success: true, programId: progId });
        } else {
          respond({ success: false, error: 'Name and code required' });
        }
        break;

      // ===== SOUND =====
      case 'playChime':
        if (window.playStartupChime) playStartupChime();
        respond({ success: true });
        break;

      // ===== SYSTEM INFO =====
      case 'getSystemInfo':
        respond({
          success: true,
          info: {
            version: 'ALGO OS 1.0',
            files: savedFiles.length,
            windows: windows.length,
            programs: installedPrograms.length
          }
        });
        break;

      // ===== FILE TYPE REGISTRATION =====
      case 'registerFileType':
        if (!window.iframeFileHandlers) window.iframeFileHandlers = {};
        window.iframeFileHandlers[msg.args.ext] = { name: msg.args.name, icon: msg.args.icon, source: source };
        respond({ success: true });
        break;

      default:
        respond({ success: false, error: 'Unknown method: ' + msg.method });
    }
  });

  // Touch support for mobile - dragging windows and long press context menu
  let longPressTimer = null;
  let longPressTarget = null;
  let touchDragging = false;

  document.addEventListener('touchstart', (e) => {
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

    const touch = e.touches[0];
    const titlebar = e.target.closest('.window-titlebar');

    // Check if touching a window titlebar for dragging
    if (titlebar && !e.target.classList.contains('window-btn')) {
      const id = parseInt(titlebar.dataset.winid);
      dragWin = windows.find(w => w.id === id);
      if (dragWin) {
        const el = document.getElementById('win-' + id);
        dragOffset.x = touch.clientX - el.offsetLeft;
        dragOffset.y = touch.clientY - el.offsetTop;
        touchDragging = true;
        focusWindow(id);
        e.preventDefault(); // Prevent scrolling when starting to drag
        return;
      }
    }

    // Check if touching a sticky note header for dragging
    const stickyHeader = e.target.closest('.sticky-header');
    if (stickyHeader) {
      const stickyEl = stickyHeader.closest('.sticky-note');
      if (stickyEl) {
        const id = parseInt(stickyEl.id.replace('sticky-', ''));
        dragStickyNote = stickyNotes.find(n => n.id === id);
        if (dragStickyNote) {
          stickyDragOffset.x = touch.clientX - stickyEl.offsetLeft;
          stickyDragOffset.y = touch.clientY - stickyEl.offsetTop;
          touchDragging = true;
          e.preventDefault();
          return;
        }
      }
    }

    // Check if touching a desktop icon - handle tap vs drag
    const icon = e.target.closest('.desktop-icon');
    if (icon) {
      // Store touch start position for drag detection
      icon._touchStart = { x: touch.clientX, y: touch.clientY, time: Date.now() };
      icon._touchMoved = false;
      iconDragOffset.x = touch.clientX - icon.offsetLeft;
      iconDragOffset.y = touch.clientY - icon.offsetTop;
      icon.classList.add('selected');
      document.querySelectorAll('.desktop-icon').forEach(i => {
        if (i !== icon) i.classList.remove('selected');
      });
      // Don't start drag immediately - wait for movement
      dragIcon = null;
      touchDragging = false;
      e.preventDefault();
      return;
    }

    // Long press for context menu (only if not dragging)
    longPressTarget = { x: touch.clientX, y: touch.clientY, target: e.target };
    longPressTimer = setTimeout(() => {
      if (longPressTarget && !touchDragging) {
        showContextMenu({ preventDefault: ()=>{}, clientX: longPressTarget.x, clientY: longPressTarget.y, target: longPressTarget.target });
        longPressTarget = null;
      }
    }, 600);
  }, { passive: false });

  document.addEventListener('touchmove', (e) => {
    clearTimeout(longPressTimer);
    longPressTarget = null;

    if (touchDragging && e.touches.length > 0) {
      const touch = e.touches[0];

      if (dragWin) {
        const el = document.getElementById('win-' + dragWin.id);
        dragWin.x = touch.clientX - dragOffset.x;
        dragWin.y = touch.clientY - dragOffset.y;
        el.style.left = dragWin.x + 'px';
        el.style.top = dragWin.y + 'px';
        e.preventDefault(); // Prevent scrolling while dragging
      }

      if (dragStickyNote) {
        const el = document.getElementById('sticky-' + dragStickyNote.id);
        dragStickyNote.x = touch.clientX - stickyDragOffset.x;
        dragStickyNote.y = touch.clientY - stickyDragOffset.y;
        el.style.left = dragStickyNote.x + 'px';
        el.style.top = dragStickyNote.y + 'px';
        e.preventDefault();
      }

      if (dragIcon) {
        let newX = touch.clientX - iconDragOffset.x;
        let newY = touch.clientY - iconDragOffset.y;
        // Keep icon on screen
        const desktop = document.getElementById('desktop');
        const maxX = desktop.clientWidth - dragIcon.offsetWidth;
        const maxY = desktop.clientHeight - dragIcon.offsetHeight - 40;
        newX = Math.max(0, Math.min(newX, maxX));
        newY = Math.max(0, Math.min(newY, maxY));
        dragIcon.style.left = newX + 'px';
        dragIcon.style.top = newY + 'px';
        e.preventDefault();
      }
    }

    // Check if a selected icon needs to start dragging (moved more than 10px)
    const selectedIcon = document.querySelector('.desktop-icon.selected');
    if (selectedIcon && selectedIcon._touchStart && !dragIcon && e.touches.length > 0) {
      const touch = e.touches[0];
      const dx = Math.abs(touch.clientX - selectedIcon._touchStart.x);
      const dy = Math.abs(touch.clientY - selectedIcon._touchStart.y);
      if (dx > 10 || dy > 10) {
        selectedIcon._touchMoved = true;
        dragIcon = selectedIcon;
        touchDragging = true;
        e.preventDefault();
      }
    }
  }, { passive: false });

  // Track last tap for double-tap detection
  let lastIconTap = { time: 0, icon: null };

  document.addEventListener('touchend', (e) => {
    clearTimeout(longPressTimer);
    longPressTarget = null;

    // Check for icon tap (not drag)
    const selectedIcon = document.querySelector('.desktop-icon.selected');
    if (selectedIcon && selectedIcon._touchStart && !selectedIcon._touchMoved && !touchDragging) {
      const now = Date.now();
      const tapDuration = now - selectedIcon._touchStart.time;

      // If quick tap (< 300ms) - treat as a tap
      if (tapDuration < 300) {
        // Check for double tap
        if (lastIconTap.icon === selectedIcon && (now - lastIconTap.time) < 400) {
          // Double tap - open the icon
          if (selectedIcon.ondblclick) selectedIcon.ondblclick();
          lastIconTap = { time: 0, icon: null };
        } else {
          // Single tap - remember for potential double tap
          lastIconTap = { time: now, icon: selectedIcon };
        }
      }
      selectedIcon._touchStart = null;
    }

    if (touchDragging) {
      if (dragWin) {
        const stateKey = dragWin.stateKey || dragWin.title;
        windowStates[stateKey] = { x: dragWin.x, y: dragWin.y, width: dragWin.width, height: dragWin.height };
        saveState();
      }
      if (dragStickyNote) {
        saveStickyNotes();
      }
      if (dragIcon) {
        const iconId = dragIcon.dataset.iconId;
        iconPositions[iconId] = {
          x: parseInt(dragIcon.style.left),
          y: parseInt(dragIcon.style.top)
        };
        localStorage.setItem('algo-icon-positions', JSON.stringify(iconPositions));
        dragIcon._touchStart = null;
        dragIcon._touchMoved = false;
      }
      dragWin = null;
      dragStickyNote = null;
      dragIcon = null;
      touchDragging = false;
    }
  });

  setTimeout(() => algoSpeak("Welcome to ALGO OS! Try the AI Wizards!"), 1500);
}

function handleDesktopPaste(e) {
  // Only handle paste if not in an input/textarea
  if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
  if (e.target.isContentEditable) return;

  const clipboardData = e.clipboardData || window.clipboardData;

  // Check for images first
  const items = clipboardData.items;
  if (items) {
    for (let i = 0; i < items.length; i++) {
      if (items[i].type.indexOf('image') !== -1) {
        e.preventDefault();
        const blob = items[i].getAsFile();
        const reader = new FileReader();
        reader.onload = function(event) {
          const dataUrl = event.target.result;
          const filename = generatePasteFilename('img', '.png');
          savedFiles.push({ name: filename, content: dataUrl, type: 'image' });
          saveState();
          createDesktopIcons();
          algoSpeak('Pasted ' + filename);
        };
        reader.readAsDataURL(blob);
        return;
      }
    }
  }

  // Check for text
  const text = clipboardData.getData('text').trim();
  if (!text) return;

  // Check if it's a laserbarf URL or artifact name - create shortcut
  let artifactName = null;
  if (text.match(/^https?:\/\/(www\.)?laserbarf\.com\/([a-z0-9-]+)/i)) {
    artifactName = text.match(/laserbarf\.com\/([a-z0-9-]+)/i)[1];
  } else if (text.match(/^\/([a-z0-9-]+)/i)) {
    artifactName = text.match(/^\/([a-z0-9-]+)/i)[1];
  }

  if (artifactName) {
    e.preventDefault();
    createDesktopShortcut(artifactName);
    algoSpeak('Added shortcut: ' + artifactName);
    return;
  }

  // Otherwise create a text file
  e.preventDefault();
  const filename = generatePasteFilename('note', '.txt');
  savedFiles.push({ name: filename, content: text, type: 'text' });
  saveState();
  createDesktopIcons();
  algoSpeak('Pasted ' + filename);
}

function generatePasteFilename(prefix, ext) {
  const syllables = ['mo','ha','lo','ki','ra','zu','na','te','fi','bo','se','lu','pa','ri','do','ve'];
  let name = prefix + '-' + syllables[Math.floor(Math.random()*syllables.length)] +
             syllables[Math.floor(Math.random()*syllables.length)] + ext;
  let counter = 1;
  while (savedFiles.some(f => f.name === name)) {
    name = prefix + '-' + syllables[Math.floor(Math.random()*syllables.length)] +
           syllables[Math.floor(Math.random()*syllables.length)] + '(' + counter + ')' + ext;
    counter++;
  }
  return name;
}

// Auto-layout grid system for desktop icons
const ICON_GRID = { startX: 180, startY: 20, cellW: 80, cellH: 80, cols: 10 };

function getOccupiedPositions() {
  // Get all icon positions (saved + defaults)
  const occupied = new Set();
  document.querySelectorAll('.desktop-icon').forEach(el => {
    const x = parseInt(el.style.left) || 0;
    const y = parseInt(el.style.top) || 0;
    // Round to grid cell
    const col = Math.round((x - ICON_GRID.startX) / ICON_GRID.cellW);
    const row = Math.round((y - ICON_GRID.startY) / ICON_GRID.cellH);
    if (col >= 0 && row >= 0) occupied.add(`${col},${row}`);
  });
  // Also include iconPositions
  Object.values(iconPositions).forEach(pos => {
    const col = Math.round((pos.x - ICON_GRID.startX) / ICON_GRID.cellW);
    const row = Math.round((pos.y - ICON_GRID.startY) / ICON_GRID.cellH);
    if (col >= 0 && row >= 0) occupied.add(`${col},${row}`);
  });
  return occupied;
}

function getNextIconPosition(existingCount) {
  // First, use the simple grid based on count
  const col = existingCount % ICON_GRID.cols;
  const row = Math.floor(existingCount / ICON_GRID.cols);
  return {
    x: ICON_GRID.startX + col * ICON_GRID.cellW,
    y: ICON_GRID.startY + row * ICON_GRID.cellH
  };
}

function createDesktopIcons() {
  const desktop = document.getElementById('desktop');
  desktop.innerHTML = '';

  const defaultIcons = [
    { id: 'docs', name: 'Documentation', icon: 'üìï', x: 20, y: 20, action: 'openDocumentation' },
    { id: 'notepad', name: 'Notepad', icon: 'üìù', x: 20, y: 100, action: 'openNotepad' },
    { id: 'jsIDE', name: 'JavaScript.IDE', icon: 'üìú', x: 20, y: 180, action: 'openJSIDE' },
    { id: 'browser', name: 'Web Browser', icon: 'üåê', x: 20, y: 260, action: 'openBrowser' },
    { id: 'claude', name: 'Claude Wizard', icon: 'ü§ñ', x: 20, y: 340, action: 'openClaudeWizard' },
    { id: 'gemini', name: 'Gemini Wizard', icon: 'üíé', x: 20, y: 420, action: 'openGeminiWizard' },
    { id: 'gpt', name: 'GPT Wizard', icon: 'üß†', x: 100, y: 20, action: 'openGPTWizard' },
    { id: 'chat', name: 'ALGO Chat', icon: 'üí¨', x: 100, y: 100, action: 'openChat' },
    { id: 'webcam', name: 'ALGO Webcam', icon: 'üìπ', x: 100, y: 180, action: 'openWebcam' },
  ];

  defaultIcons.forEach(ic => createDesktopIcon(ic));

  // Track position for auto-layout (starting after Video Player at row 0)
  let autoIdx = 1; // Video is at position 0 in the auto-layout grid

  // Global files first (from /api/algo-desktop) - read-only
  globalFiles.forEach((f) => {
    // Skip if user has a file with same name (user version takes precedence)
    if (savedFiles.some(sf => sf.name === f.name)) return;

    let icon = f.icon || 'üìÑ';
    if (!f.icon) {
      if (f.name.endsWith('.md')) icon = 'üìÑ';
      else if (f.name.endsWith('.js')) {
        // .js source files always use script icon - app icon is for compiled programs
        icon = 'üìú';
      }
      else if (f.name.endsWith('.layout')) icon = 'üìê';
      else if (f.name.endsWith('.ui')) icon = 'üéõÔ∏è';
      else if (f.type === 'image') icon = 'üñºÔ∏è';
    }

    const pos = getNextIconPosition(autoIdx++);
    createDesktopIcon({
      id: 'global-' + f.name.replace(/[^a-z0-9]/gi, '-'),
      name: f.name,
      icon: icon,
      imageData: f.type === 'image' ? f.content : null,
      x: pos.x,
      y: pos.y,
      action: f.type === 'image' ? 'viewImage' : 'openFile',
      data: { ...f, global: true }
    });
  });

  // Saved files - only show files NOT in a room folder on desktop
  const desktopFiles = savedFiles.filter(f => !f.room);
  desktopFiles.forEach((f) => {
    const fileIdx = savedFiles.indexOf(f);
    let icon = 'üìÑ';
    if (f.name.endsWith('.md')) icon = 'üìÑ';
    else if (f.name.endsWith('.js')) {
      // Compiled .js files use app icon, source files use script icon
      if (f.compiled && f.appIcon) {
        icon = f.appIcon;
      } else {
        icon = 'üìú';
      }
    }
    else if (f.name.endsWith('.layout')) icon = 'üìê';
    else if (f.name.endsWith('.ui')) icon = 'üéõÔ∏è';
    else if (f.type === 'image' || f.name.endsWith('.png') || f.name.endsWith('.jpg')) icon = 'üñºÔ∏è';

    const pos = getNextIconPosition(autoIdx++);
    createDesktopIcon({
      id: 'file-' + fileIdx,
      name: f.name,
      icon: icon,
      imageData: f.type === 'image' ? f.content : null,
      x: pos.x,
      y: pos.y,
      action: f.type === 'image' ? 'viewImage' : 'openFile',
      data: f
    });
  });

  // Installed programs
  installedPrograms.forEach((p) => {
    const pos = getNextIconPosition(autoIdx++);
    createDesktopIcon({
      id: 'prog-' + p.id,
      name: p.name,
      icon: p.icon || 'üéÆ',
      x: pos.x,
      y: pos.y,
      action: 'runProgram',
      data: p
    });
  });

  // Room folders
  roomFolders.forEach((r) => {
    const pos = getNextIconPosition(autoIdx++);
    createDesktopIcon({
      id: 'room-' + r.name,
      name: r.name,
      icon: 'üìÇ',
      x: pos.x,
      y: pos.y,
      action: 'openRoomFolder',
      data: r
    });
  });
}

function createDesktopIcon(ic) {
  const el = document.createElement('div');
  el.className = 'desktop-icon';
  el.id = 'icon-' + ic.id;
  // Use saved position if available, otherwise use default
  const savedPos = iconPositions[ic.id];
  el.style.left = (savedPos ? savedPos.x : ic.x) + 'px';
  el.style.top = (savedPos ? savedPos.y : ic.y) + 'px';
  // Show image thumbnail for image files
  if (ic.imageData) {
    el.innerHTML = '<div class="icon-img icon-thumbnail"><img src="' + ic.imageData + '" alt=""></div><span>' + ic.name + '</span>';
  } else {
    el.innerHTML = '<div class="icon-img">' + ic.icon + '</div><span>' + ic.name + '</span>';
  }
  el.ondblclick = () => {
    if (ic.action === 'openFile') openSavedFile(ic.data);
    else if (ic.action === 'viewImage') viewImage(ic.data);
    else if (ic.action === 'runProgram') runProgram(ic.data);
    else if (ic.action === 'openRoomFolder') openRoomFolder(ic.data);
    else if (window[ic.action]) window[ic.action]();
  };
  // Mousedown for dragging - only start drag on icon-img or icon area, not on double-click
  el.onmousedown = (e) => {
    // Select icon on click
    document.querySelectorAll('.desktop-icon').forEach(i => i.classList.remove('selected'));
    el.classList.add('selected');
  };
  el.dataset.iconId = ic.id;
  el.dataset.iconType = ic.action;
  el.dataset.defaultX = ic.x;
  el.dataset.defaultY = ic.y;
  if (ic.data) el.dataset.fileData = JSON.stringify(ic.data);
  document.getElementById('desktop').appendChild(el);
}

// ==================== WINDOWS ====================
function createWindow(opts) {
  const id = winId++;
  const stateKey = opts.stateKey || opts.title || 'Window';
  const saved = windowStates[stateKey] || {};
  const win = {
    id, title: opts.title || 'Window', icon: opts.icon || 'üìÑ',
    stateKey: stateKey,
    x: saved.x ?? opts.x ?? 150 + (id % 5) * 30,
    y: saved.y ?? opts.y ?? 80 + (id % 5) * 30,
    width: saved.width ?? opts.width ?? 500,
    height: saved.height ?? opts.height ?? 400,
    minWidth: opts.minWidth || 150,
    minHeight: opts.minHeight || 100,
    minimized: false, content: opts.content || '',
    menubar: opts.menubar || '', onClose: opts.onClose,
    onResize: opts.onResize || null,
    resizable: opts.resizable !== false
  };
  windows.push(win);
  renderWindow(win);
  focusWindow(id);
  updateTaskbar();
  return id;
}

function renderWindow(win) {
  const el = document.createElement('div');
  el.className = 'window';
  el.id = 'win-' + win.id;
  el.style.cssText = 'left:' + win.x + 'px;top:' + win.y + 'px;width:' + win.width + 'px;height:' + win.height + 'px;z-index:' + (100+win.id);
  el.innerHTML =
    '<div class="window-titlebar" data-winid="' + win.id + '">' +
      '<div class="title">' + win.icon + ' ' + win.title + '</div>' +
      '<div class="window-btn" onclick="minimizeWindow(' + win.id + ')">_</div>' +
      '<div class="window-btn" onclick="maximizeWindow(' + win.id + ')">‚ñ°</div>' +
      '<div class="window-btn" onclick="closeWindow(' + win.id + ')">√ó</div>' +
    '</div>' +
    win.menubar +
    '<div class="window-content">' + win.content + '</div>' +
    (win.resizable ? '<div class="window-resize" data-winid="' + win.id + '"></div>' : '');
  el.onmousedown = () => focusWindow(win.id);
  document.getElementById('desktop').appendChild(el);
}

function getWindowById(id) {
  return document.getElementById('win-' + id);
}

function focusWindow(id) {
  windows.forEach(w => {
    const el = document.getElementById('win-' + w.id);
    if (el) {
      el.classList.toggle('inactive', w.id !== id);
      el.style.zIndex = w.id === id ? 9000 : 100 + w.id;
    }
  });
  activeWin = id;
  updateTaskbar();
}

function minimizeWindow(id) {
  const el = document.getElementById('win-' + id);
  if (el) el.classList.add('minimized');
  const w = windows.find(x => x.id === id);
  if (w) w.minimized = true;
  updateTaskbar();
}

function restoreWindow(id) {
  const el = document.getElementById('win-' + id);
  if (el) el.classList.remove('minimized');
  const w = windows.find(x => x.id === id);
  if (w) w.minimized = false;
  focusWindow(id);
}

function maximizeWindow(id) {
  const el = document.getElementById('win-' + id);
  const w = windows.find(x => x.id === id);
  if (!el || !w) return;
  if (w.maximized) {
    el.style.cssText = 'left:' + w.restoreX + 'px;top:' + w.restoreY + 'px;width:' + w.restoreW + 'px;height:' + w.restoreH + 'px;z-index:9000';
    w.maximized = false;
  } else {
    w.restoreX = w.x; w.restoreY = w.y; w.restoreW = w.width; w.restoreH = w.height;
    el.style.cssText = 'left:0;top:0;width:100%;height:calc(100vh - 28px);z-index:9000';
    w.maximized = true;
  }
}

function closeWindow(id) {
  const idx = windows.findIndex(w => w.id === id);
  if (idx > -1) {
    if (windows[idx].onClose) windows[idx].onClose();
    windows.splice(idx, 1);
    const el = document.getElementById('win-' + id);
    if (el) el.remove();
    updateTaskbar();
  }
}

function updateTaskbar() {
  document.getElementById('taskbar-windows').innerHTML = windows.map(w =>
    '<div class="taskbar-item' + (w.id===activeWin?' active':'') + '" onclick="' + (w.minimized?'restoreWindow':'focusWindow') + '(' + w.id + ')">' + w.icon + ' ' + w.title + '</div>'
  ).join('');
}

// ==================== NOTEPAD ====================
function openNotepad(content, filename, room, existingFile) {
  content = content || '';
  filename = filename || '';
  room = room || null;
  existingFile = existingFile || null;
  const id = winId;
  const roomLabel = room ? ' [#' + room + ']' : '';
  const isNew = !filename;
  createWindow({
    title: (filename || 'Untitled') + roomLabel + ' - Notepad',
    stateKey: 'Notepad',
    icon: 'üìù',
    width: 500, height: 400,
    menubar: '<div class="window-menubar">' +
      '<div class="menu-item" onclick="toggleMenu(\'notepad-menu-' + id + '\')">' +
        'File' +
        '<div class="dropdown-menu" id="notepad-menu-' + id + '">' +
          '<div class="dropdown-item" onclick="notepadNew(' + id + ')">New</div>' +
          '<div class="dropdown-item" onclick="notepadSaveAs(' + id + ')">Save As... (Ctrl+S)</div>' +
          '<div class="dropdown-item" onclick="notepadPost(' + id + ')">Post to Laserbarf</div>' +
        '</div>' +
      '</div>' +
    '</div>',
    content: '<div class="notepad-container">' +
      '<textarea class="notepad-textarea" id="notepad-text-' + id + '" data-filename="' + filename + '" data-room="' + (room||'') + '" data-saved="' + (isNew ? 'false' : 'true') + '" data-original="' + escapeHtml(content) + '">' + escapeHtml(content) + '</textarea>' +
    '</div>'
  });

  // Set up change tracking and Ctrl+S
  setTimeout(() => {
    const textarea = document.getElementById('notepad-text-' + id);
    if (textarea) {
      if (existingFile) textarea._editingFile = existingFile;
      textarea.addEventListener('input', () => notepadMarkUnsaved(id));
      textarea.addEventListener('keydown', (e) => {
        if ((e.ctrlKey || e.metaKey) && e.key === 's') {
          e.preventDefault();
          notepadSaveAs(id);
        }
      });
    }
  }, 50);
}

function notepadMarkUnsaved(id) {
  const textarea = document.getElementById('notepad-text-' + id);
  if (!textarea) return;
  const titleEl = document.querySelector('#win-' + id + ' .title');
  if (titleEl && !titleEl.textContent.startsWith('üìù *')) {
    titleEl.textContent = titleEl.textContent.replace('üìù ', 'üìù *');
  }
}

function toggleMenu(menuId) {
  event.stopPropagation();
  const menu = document.getElementById(menuId);
  document.querySelectorAll('.dropdown-menu').forEach(m => {
    if (m.id !== menuId) m.classList.remove('visible');
  });
  if (menu) menu.classList.toggle('visible');
}

function notepadNew(id) {
  document.getElementById('notepad-text-' + id).value = '';
  document.querySelector('#win-' + id + ' .title').innerHTML = 'üìù Untitled - Notepad';
  hideMenus();
}

function notepadSaveAs(id) {
  const textarea = document.getElementById('notepad-text-' + id);
  const text = textarea.value.trim();
  if (!text) { alert('Nothing to save!'); return; }

  const room = textarea.dataset.room || null;
  const existingFilename = textarea.dataset.filename || '';
  const firstWord = text.split(/\s+/)[0].replace(/[^a-zA-Z0-9]/g, '').substring(0, 20) || 'untitled';
  const suggestedName = existingFilename || (firstWord + '.txt');

  hideMenus();

  // Show Save As dialog
  const filename = prompt('Save as:', suggestedName);
  if (!filename) return;

  // Ensure .txt extension
  let finalName = filename.trim();
  if (!finalName.endsWith('.txt')) finalName += '.txt';

  // Check for collision
  let counter = 1;
  let uniqueName = finalName;
  const baseName = finalName.replace(/\.txt$/, '');
  while (savedFiles.some(f => f.name === uniqueName && f.room === room && f !== textarea._editingFile)) {
    counter++;
    uniqueName = baseName + '(' + counter + ').txt';
  }

  // If editing existing file, update it; otherwise add new
  if (textarea._editingFile) {
    textarea._editingFile.name = uniqueName;
    textarea._editingFile.content = text;
  } else {
    savedFiles.push({ name: uniqueName, content: text, room: room });
  }

  saveState();
  createDesktopIcons();
  if (room) refreshRoomFolder(room);

  textarea.dataset.filename = uniqueName;
  textarea.dataset.saved = 'true';
  textarea._editingFile = savedFiles.find(f => f.name === uniqueName && f.room === room);
  const roomLabel = room ? ' [#' + room + ']' : '';
  document.querySelector('#win-' + id + ' .title').innerHTML = 'üìù ' + uniqueName + roomLabel + ' - Notepad';

  algoSpeak('Saved ' + uniqueName + '!');
}

function notepadPost(id) {
  const textarea = document.getElementById('notepad-text-' + id);
  const text = textarea.value.trim();
  if (!text) { alert('Nothing to post!'); return; }

  const room = textarea.dataset.room || 'algo-world';
  postToLaserbarf(text, room);
  hideMenus();
  algoSpeak('Posted to #' + room + '!');
}

function openSavedFile(file) {
  const ext = file.name.split('.').pop().toLowerCase();

  // Check registered file type handlers first - use default handler
  if (FILE_TYPE_HANDLERS[ext] && FILE_TYPE_HANDLERS[ext].length > 0) {
    const handler = getDefaultHandler(ext);
    if (handler) {
      handler.handler(file.content, file.name, file);
      return;
    }
  }

  // Check iframe-registered handlers (from external artifacts)
  if (window.iframeFileHandlers && window.iframeFileHandlers[ext]) {
    const handler = window.iframeFileHandlers[ext];
    if (handler.source) {
      handler.source.postMessage({ type: 'ALGO_FILE_OPEN', filename: file.name, content: file.content }, '*');
    }
    return;
  }

  // Built-in default handlers
  if (file.name.endsWith('.js')) {
    openJSIDE(file.content, file.name);
  } else if (file.type === 'image') {
    viewImage(file);
  } else {
    openNotepad(file.content, file.name, file.room, file);
  }
}

// Open file with a specific handler
function openFileWith(file, handlerIndex) {
  const ext = file.name.split('.').pop().toLowerCase();
  const handlers = FILE_TYPE_HANDLERS[ext];
  if (handlers && handlers[handlerIndex]) {
    handlers[handlerIndex].handler(file.content, file.name, file);
  }
}

function viewImage(file) {
  createWindow({
    title: file.name,
    stateKey: 'Image:' + file.name,
    icon: 'üñºÔ∏è',
    width: 500, height: 400,
    content: '<div style="width:100%;height:100%;display:flex;align-items:center;justify-content:center;background:#222;overflow:auto;">' +
      '<img src="' + file.content + '" style="max-width:100%;max-height:100%;object-fit:contain;">' +
    '</div>'
  });
}

// ==================== ROOM FOLDERS ====================
function openRoomFolder(room) {
  const id = winId;
  createWindow({
    title: room.name,
    stateKey: 'Room:' + room.name,
    icon: 'üìÇ',
    width: 400, height: 300,
    content: '<div class="folder-content" id="folder-content-' + room.name + '">' + generateFolderContent(room.name) + '</div>'
  });
}

function generateFolderContent(roomName) {
  const roomFiles = savedFiles.filter(f => f.room === roomName);
  return (roomFiles.length === 0 ? '<div style="color:#666;padding:10px;">Empty folder</div>' : '') +
    roomFiles.map((f, i) =>
      '<div class="folder-item" ondblclick="openSavedFile(savedFiles[' + savedFiles.indexOf(f) + '])">' +
        '<div class="icon-img">' + (f.name.endsWith('.js') ? 'üìú' : 'üìÑ') + '</div>' +
        '<span>' + f.name + '</span>' +
      '</div>'
    ).join('') +
    '<div class="folder-item" ondblclick="openNotepadInRoom(\'' + roomName + '\')" style="opacity:0.6;">' +
      '<div class="icon-img">üìù</div>' +
      '<span>New File...</span>' +
    '</div>';
}

function refreshRoomFolder(roomName) {
  const container = document.getElementById('folder-content-' + roomName);
  if (container) {
    container.innerHTML = generateFolderContent(roomName);
  }
}

function openNotepadInRoom(roomName) {
  openNotepad('', '', roomName);
}

function createRoomFolder() {
  const name = prompt('Enter room name:');
  if (!name) return;
  const cleanName = name.replace(/[^a-zA-Z0-9-]/g, '').toLowerCase();
  if (!cleanName || roomFolders.some(r => r.name === cleanName)) return;
  roomFolders.push({ name: cleanName });
  saveState();
  createDesktopIcons();
  hideContextMenu();
}

// ==================== JAVASCRIPT IDE ====================
// ALGO API library for IDE scripts
const ALGO_API_CODE = `
// ALGO OS App API
window.ALGO = {
  // App metadata
  app: { name: 'My App', icon: 'üì±', version: '1.0' },

  // File type handlers
  handlers: {},

  // Register as handler for file extension
  registerFileType: function(ext, handler) {
    this.handlers[ext] = handler;
    if (window.registerFileHandler) {
      window.registerFileHandler(ext, this.app.name, this.app.icon, handler);
    }
  },

  // Create a window with UI
  createWindow: function(options) {
    const opts = Object.assign({ title: this.app.name, icon: this.app.icon, width: 400, height: 300 }, options);
    if (window.createWindow) {
      return window.createWindow(opts);
    }
    return null;
  },

  // Create UI elements
  ui: {
    button: function(label, onclick) {
      return '<button onclick="(' + onclick.toString() + ')()" style="padding:4px 12px;margin:2px;">' + label + '</button>';
    },
    input: function(id, placeholder) {
      return '<input id="' + id + '" placeholder="' + (placeholder||'') + '" style="padding:4px;margin:2px;width:200px;">';
    },
    label: function(text) {
      return '<label style="display:block;margin:4px;">' + text + '</label>';
    },
    select: function(id, options) {
      return '<select id="' + id + '" style="padding:4px;margin:2px;">' +
        options.map(o => '<option value="' + o.value + '">' + o.label + '</option>').join('') + '</select>';
    },
    panel: function(content) {
      return '<div style="padding:10px;background:#f0f0f0;border:1px solid #ccc;margin:4px;">' + content + '</div>';
    }
  },

  // Save file to desktop
  saveFile: function(name, content, type) {
    if (window.savedFiles) {
      window.savedFiles.push({ name: name, content: content, type: type || 'text' });
      if (window.saveState) window.saveState();
      if (window.createDesktopIcons) window.createDesktopIcons();
      return true;
    }
    return false;
  },

  // Show notification
  notify: function(message) {
    if (window.algoSpeak) window.algoSpeak(message);
    else alert(message);
  },

  // Get element value
  getValue: function(id) {
    const el = document.getElementById(id);
    return el ? el.value : null;
  },

  // Set element content
  setContent: function(id, html) {
    const el = document.getElementById(id);
    if (el) el.innerHTML = html;
  },

  // === LAYOUT SYSTEM ===
  // Monospace character unit size (approximately 8x16 pixels)
  CHAR_WIDTH: 8,
  CHAR_HEIGHT: 16,

  // Load files from API by folder prefix and type
  loadFiles: async function(folder, type) {
    try {
      const url = 'https://laserbarf.com/api/algo-files?folder=' + encodeURIComponent(folder) + '&type=' + encodeURIComponent(type);
      const resp = await fetch(url);
      const data = await resp.json();
      return data.files || [];
    } catch (e) {
      console.error('ALGO.loadFiles error:', e);
      return [];
    }
  },

  // Get file contents by names
  getFileContents: async function(names) {
    try {
      const resp = await fetch('https://laserbarf.com/api/algo-files', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ names: names })
      });
      const data = await resp.json();
      return data.files || {};
    } catch (e) {
      console.error('ALGO.getFileContents error:', e);
      return {};
    }
  },

  // Parse layout file (JSON format)
  parseLayout: function(content) {
    try {
      return JSON.parse(content);
    } catch (e) {
      console.error('Invalid layout JSON:', e);
      return null;
    }
  },

  // Parse UI component file (JSON format)
  parseUI: function(content) {
    try {
      return JSON.parse(content);
    } catch (e) {
      console.error('Invalid UI JSON:', e);
      return null;
    }
  },

  // === ANCHOR CONSTRAINT SYSTEM ===
  // Parse anchor string like "toolbar.bottom + 2" or "window.left - 4"
  parseAnchor: function(anchorStr) {
    if (!anchorStr || typeof anchorStr !== 'string') return null;
    const match = anchorStr.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\\.(left|right|top|bottom)\\s*([+-]\\s*\\d+)?$/);
    if (!match) return null;
    return {
      to: match[1],
      edge: match[2],
      offset: match[3] ? parseInt(match[3].replace(/\\s/g, '')) : 0
    };
  },

  // Build dependency graph from components
  buildDependencyGraph: function(components) {
    const graph = {};
    const ids = new Set(components.map(c => c.id).filter(Boolean));
    ids.add('window');

    components.forEach(comp => {
      const id = comp.id;
      if (!id) return;
      graph[id] = new Set();

      if (comp.anchor) {
        ['top', 'bottom', 'left', 'right'].forEach(edge => {
          const anchor = this.parseAnchor(comp.anchor[edge]);
          if (anchor && anchor.to !== 'window' && ids.has(anchor.to)) {
            graph[id].add(anchor.to);
          }
        });
      }
    });
    return graph;
  },

  // Topological sort for dependency resolution
  topoSort: function(components) {
    const graph = this.buildDependencyGraph(components);
    const visited = new Set();
    const result = [];
    const visiting = new Set();

    const visit = (id) => {
      if (visited.has(id)) return true;
      if (visiting.has(id)) return false; // Cycle detected
      visiting.add(id);
      const deps = graph[id] || new Set();
      for (const dep of deps) {
        if (!visit(dep)) return false;
      }
      visiting.delete(id);
      visited.add(id);
      result.push(id);
      return true;
    };

    components.forEach(c => { if (c.id) visit(c.id); });
    return result;
  },

  // Solve anchor constraints and return resolved positions
  solveAnchors: function(layout, containerWidth, containerHeight) {
    const cw = this.CHAR_WIDTH;
    const ch = this.CHAR_HEIGHT;
    const components = layout.components || [];

    // Window bounds (in pixels)
    const bounds = {
      window: { left: 0, top: 0, right: containerWidth, bottom: containerHeight }
    };

    // Get sorted order
    const sortedIds = this.topoSort(components);
    const compMap = {};
    components.forEach(c => { if (c.id) compMap[c.id] = c; });

    // Resolve each component in dependency order
    const resolved = {};
    sortedIds.forEach(id => {
      const comp = compMap[id];
      if (!comp) return;

      let x, y, w, h;
      const defaultW = (comp.w || 10) * cw;
      const defaultH = (comp.h || 2) * ch;

      if (comp.anchor) {
        // Resolve horizontal (left/right)
        const leftAnchor = this.parseAnchor(comp.anchor.left);
        const rightAnchor = this.parseAnchor(comp.anchor.right);

        if (leftAnchor && rightAnchor) {
          // Both anchored - calculate x and width
          const leftRef = bounds[leftAnchor.to];
          const rightRef = bounds[rightAnchor.to];
          if (leftRef && rightRef) {
            x = leftRef[leftAnchor.edge] + leftAnchor.offset * cw;
            const rightEdge = rightRef[rightAnchor.edge] + rightAnchor.offset * cw;
            w = rightEdge - x;
          }
        } else if (leftAnchor) {
          const leftRef = bounds[leftAnchor.to];
          if (leftRef) {
            x = leftRef[leftAnchor.edge] + leftAnchor.offset * cw;
          }
          w = defaultW;
        } else if (rightAnchor) {
          const rightRef = bounds[rightAnchor.to];
          if (rightRef) {
            x = rightRef[rightAnchor.edge] + rightAnchor.offset * cw - defaultW;
          }
          w = defaultW;
        } else {
          x = (comp.x || 0) * cw;
          w = defaultW;
        }

        // Resolve vertical (top/bottom)
        const topAnchor = this.parseAnchor(comp.anchor.top);
        const bottomAnchor = this.parseAnchor(comp.anchor.bottom);

        if (topAnchor && bottomAnchor) {
          // Both anchored - calculate y and height
          const topRef = bounds[topAnchor.to];
          const bottomRef = bounds[bottomAnchor.to];
          if (topRef && bottomRef) {
            y = topRef[topAnchor.edge] + topAnchor.offset * ch;
            const bottomEdge = bottomRef[bottomAnchor.edge] + bottomAnchor.offset * ch;
            h = bottomEdge - y;
          }
        } else if (topAnchor) {
          const topRef = bounds[topAnchor.to];
          if (topRef) {
            y = topRef[topAnchor.edge] + topAnchor.offset * ch;
          }
          h = defaultH;
        } else if (bottomAnchor) {
          const bottomRef = bounds[bottomAnchor.to];
          if (bottomRef) {
            y = bottomRef[bottomAnchor.edge] + bottomAnchor.offset * ch - defaultH;
          }
          h = defaultH;
        } else {
          y = (comp.y || 0) * ch;
          h = defaultH;
        }
      } else {
        // No anchors - use absolute position
        x = (comp.x || 0) * cw;
        y = (comp.y || 0) * ch;
        w = defaultW;
        h = defaultH;
      }

      // Ensure valid dimensions
      x = x || 0;
      y = y || 0;
      w = Math.max(w || defaultW, cw);
      h = Math.max(h || defaultH, ch);

      resolved[id] = { x, y, w, h };

      // Add to bounds for other components to reference
      bounds[id] = {
        left: x,
        top: y,
        right: x + w,
        bottom: y + h
      };
    });

    return resolved;
  },

  // Render a layout to HTML with anchor support
  renderLayout: function(layout, uiComponents, values, containerWidth, containerHeight) {
    values = values || {};
    const cw = this.CHAR_WIDTH;
    const ch = this.CHAR_HEIGHT;
    const width = containerWidth || (layout.size?.default?.[0] || 40) * cw;
    const height = containerHeight || (layout.size?.default?.[1] || 20) * ch;

    // Solve anchor constraints
    const resolved = this.solveAnchors(layout, width, height);

    let html = '<div class="algo-layout" data-layout-width="' + width + '" data-layout-height="' + height + '" style="position:relative;width:' + width + 'px;height:' + height + 'px;background:#f8f8f8;border:1px solid #ccc;font-family:monospace;">';

    if (layout.components) {
      layout.components.forEach(function(comp, idx) {
        const compId = comp.id || ('comp-' + idx);
        const pos = resolved[compId] || {
          x: (comp.x || 0) * cw,
          y: (comp.y || 0) * ch,
          w: (comp.w || 10) * cw,
          h: (comp.h || 2) * ch
        };

        const ui = uiComponents[comp.ui];
        const props = Object.assign({}, ui?.props || {}, comp.props || {});

        if (values[compId] !== undefined) {
          props.value = values[compId];
        }

        html += '<div class="algo-component" data-id="' + compId + '" style="position:absolute;left:' + pos.x + 'px;top:' + pos.y + 'px;width:' + pos.w + 'px;height:' + pos.h + 'px;overflow:hidden;">';
        if (ui) {
          html += ALGO.renderComponent(ui, props, compId, pos.w, pos.h);
        } else if (comp.ui) {
          html += '<div style="background:#fcc;padding:4px;font-size:10px;">Missing: ' + comp.ui + '</div>';
        } else {
          // No UI - might be a spacer/anchor point
          html += '<div style="background:rgba(0,100,200,0.1);width:100%;height:100%;"></div>';
        }
        html += '</div>';
      });
    }

    html += '</div>';
    return html;
  },

  // Render a single UI component
  renderComponent: function(ui, props, id, width, height) {
    // Substitute props into HTML template
    let html = ui.html || '<div>Component</div>';

    // Replace {{prop}} placeholders
    Object.keys(props).forEach(function(key) {
      const val = typeof props[key] === 'object' ? props[key].default : props[key];
      html = html.replace(new RegExp('\\\\{\\\\{' + key + '\\\\}\\\\}', 'g'), val);
    });

    // Add component ID
    html = html.replace(/id="/g, 'id="' + id + '-');
    html = '<div class="ui-' + (ui.name || 'component').toLowerCase().replace(/\\s+/g, '-') + '" data-component-id="' + id + '">' + html + '</div>';

    // Add component CSS (scoped)
    if (ui.css) {
      html = '<style>' + ui.css.replace(/\\.([a-z])/gi, '.' + id + '-$1') + '</style>' + html;
    }

    return html;
  },

  // Re-render a layout with new dimensions (for resize handling)
  relayoutWindow: function(layoutId, newWidth, newHeight) {
    const data = window._algoLayouts?.[layoutId];
    if (!data) return;

    const container = document.getElementById(layoutId);
    if (!container) return;

    container.innerHTML = this.renderLayout(data.layout, data.uiComponents, data.values, newWidth, newHeight);
  },

  // Create a layout window with automatic resize handling
  createLayoutWindow: async function(layoutName, folder) {
    folder = folder || this.app.folder || '';
    const files = await this.loadFiles(folder, 'layout');
    const layoutFile = files.find(f => f.name.endsWith(layoutName) || f.name === layoutName);

    if (!layoutFile) {
      this.notify('Layout not found: ' + layoutName);
      return null;
    }

    // Load layout and UI files
    const contents = await this.getFileContents([layoutFile.name]);
    const layout = this.parseLayout(contents[layoutFile.name]?.content);

    if (!layout) {
      this.notify('Invalid layout file');
      return null;
    }

    // Load UI components referenced in layout
    const uiNames = (layout.components || []).map(c => folder + '/' + c.ui).filter(Boolean);
    const uiContents = await this.getFileContents(uiNames);
    const uiComponents = {};
    Object.keys(uiContents).forEach(function(name) {
      const ui = ALGO.parseUI(uiContents[name]?.content);
      if (ui) {
        const shortName = name.split('/').pop();
        uiComponents[shortName] = ui;
      }
    });

    // Calculate window size from layout
    const cw = this.CHAR_WIDTH;
    const ch = this.CHAR_HEIGHT;
    const width = (layout.size?.default?.[0] || 40) * cw + 8;
    const height = (layout.size?.default?.[1] || 20) * ch + 30;
    const minW = (layout.size?.min?.[0] || 20) * cw + 8;
    const minH = (layout.size?.min?.[1] || 10) * ch + 30;

    // Store for resize handling
    window._algoLayouts = window._algoLayouts || {};
    const layoutId = 'layout-' + Date.now();
    window._algoLayouts[layoutId] = { layout, uiComponents, values: {} };

    // Create window with resize callback
    const win = this.createWindow({
      title: layout.name || this.app.name,
      width: width,
      height: height,
      minWidth: minW,
      minHeight: minH,
      resizable: true,
      content: '<div id="' + layoutId + '" style="width:100%;height:100%;">' + this.renderLayout(layout, uiComponents) + '</div>',
      onResize: function(newW, newH) {
        // Account for window chrome (borders, titlebar)
        const contentW = newW - 8;
        const contentH = newH - 30;
        ALGO.relayoutWindow(layoutId, contentW, contentH);
      }
    });

    // Store window reference
    if (win) {
      window._algoLayouts[layoutId].windowId = win;
    }

    return win;
  },

  // Get component value from a layout
  getComponentValue: function(layoutId, componentId) {
    const data = window._algoLayouts?.[layoutId];
    return data?.values?.[componentId];
  },

  // Set component value in a layout
  setComponentValue: function(layoutId, componentId, value) {
    const data = window._algoLayouts?.[layoutId];
    if (data) {
      data.values[componentId] = value;
    }
  },

  // === REALTIME CHANNEL SYSTEM ===
  // Allows JAVASCRIPT.IDE apps to communicate directly with each other
  // Channels are typed (e.g., 'midi', 'audio', 'data') for discovery

  _channels: {},

  // Register a named channel that can receive messages
  // type: channel type for discovery (e.g., 'midi', 'audio', 'sync')
  // callback: function(message, senderInfo) called when message received
  // Returns channel ID for management
  registerChannel: function(name, type, callback, metadata) {
    const channelId = 'ch-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
    window._algoChannels = window._algoChannels || {};
    window._algoChannels[channelId] = {
      id: channelId,
      name: name,
      type: type,
      callback: callback,
      metadata: metadata || {},
      appName: this.app.name,
      appIcon: this.app.icon,
      created: Date.now()
    };
    this._channels[name] = channelId;
    console.log('ALGO Channel registered:', name, '(' + type + ')');
    return channelId;
  },

  // Unregister a channel
  unregisterChannel: function(nameOrId) {
    window._algoChannels = window._algoChannels || {};
    // Try by name first
    if (this._channels[nameOrId]) {
      const id = this._channels[nameOrId];
      delete window._algoChannels[id];
      delete this._channels[nameOrId];
      return true;
    }
    // Try by ID
    if (window._algoChannels[nameOrId]) {
      delete window._algoChannels[nameOrId];
      return true;
    }
    return false;
  },

  // List available channels, optionally filtered by type
  listChannels: function(type) {
    window._algoChannels = window._algoChannels || {};
    const channels = Object.values(window._algoChannels);
    if (type) {
      return channels.filter(ch => ch.type === type);
    }
    return channels;
  },

  // Send a message to a channel by name or ID
  // Returns true if delivered, false if channel not found
  sendToChannel: function(nameOrId, message) {
    window._algoChannels = window._algoChannels || {};
    let channel = window._algoChannels[nameOrId];
    // Try by name if not found by ID
    if (!channel) {
      channel = Object.values(window._algoChannels).find(ch => ch.name === nameOrId);
    }
    if (channel && channel.callback) {
      try {
        channel.callback(message, { sender: this.app.name, senderIcon: this.app.icon, timestamp: Date.now() });
        return true;
      } catch (e) {
        console.error('Channel delivery error:', e);
        return false;
      }
    }
    return false;
  },

  // Broadcast a message to all channels of a specific type
  broadcast: function(type, message) {
    const channels = this.listChannels(type);
    let delivered = 0;
    channels.forEach(ch => {
      if (this.sendToChannel(ch.id, message)) delivered++;
    });
    return delivered;
  },

  // Subscribe to all messages of a type (creates a listener channel)
  subscribe: function(type, callback) {
    return this.registerChannel(this.app.name + '-sub-' + type, type + '-subscriber', callback, { subscriber: true });
  },

  // === CONTEXT MENU SYSTEM ===
  // Show a context menu at the specified position
  showContextMenu: function(x, y, items, onSelect) {
    // Remove any existing context menu
    this.hideContextMenu();

    const menu = document.createElement('div');
    menu.id = 'algo-context-menu';
    menu.style.cssText = 'position:fixed;left:' + x + 'px;top:' + y + 'px;background:#c0c0c0;border:2px outset #fff;box-shadow:2px 2px 4px rgba(0,0,0,0.3);z-index:100000;min-width:120px;font-size:11px;';

    items.forEach((item, idx) => {
      if (item === '-' || item.separator) {
        const sep = document.createElement('div');
        sep.style.cssText = 'height:1px;background:#808080;margin:2px 4px;';
        menu.appendChild(sep);
      } else {
        const menuItem = document.createElement('div');
        menuItem.style.cssText = 'padding:4px 20px 4px 8px;cursor:pointer;white-space:nowrap;' + (item.disabled ? 'color:#808080;' : '');
        menuItem.textContent = (item.icon ? item.icon + ' ' : '') + (item.label || item);
        if (!item.disabled) {
          menuItem.onmouseenter = () => menuItem.style.background = '#000080', menuItem.style.color = '#fff';
          menuItem.onmouseleave = () => menuItem.style.background = '', menuItem.style.color = '';
          menuItem.onclick = (e) => {
            e.stopPropagation();
            this.hideContextMenu();
            if (onSelect) onSelect(item.action || item.label || item, item);
          };
        }
        menu.appendChild(menuItem);
      }
    });

    document.body.appendChild(menu);

    // Adjust position if off-screen
    const rect = menu.getBoundingClientRect();
    if (rect.right > window.innerWidth) menu.style.left = (window.innerWidth - rect.width - 5) + 'px';
    if (rect.bottom > window.innerHeight) menu.style.top = (window.innerHeight - rect.height - 5) + 'px';

    // Close on click outside
    setTimeout(() => {
      document.addEventListener('click', this._contextMenuClose = () => this.hideContextMenu(), { once: true });
    }, 10);

    return menu;
  },

  hideContextMenu: function() {
    const existing = document.getElementById('algo-context-menu');
    if (existing) existing.remove();
    if (this._contextMenuClose) {
      document.removeEventListener('click', this._contextMenuClose);
      this._contextMenuClose = null;
    }
  },

  // === DRAG & DROP FILE SUPPORT ===
  // Make an element a drop zone for files
  makeDropZone: function(element, options) {
    const opts = Object.assign({ accept: '*', onDrop: null, onHover: null }, options);

    element.addEventListener('dragover', (e) => {
      e.preventDefault();
      e.stopPropagation();
      element.classList.add('algo-drop-hover');
      if (opts.onHover) opts.onHover(true);
    });

    element.addEventListener('dragleave', (e) => {
      e.preventDefault();
      element.classList.remove('algo-drop-hover');
      if (opts.onHover) opts.onHover(false);
    });

    element.addEventListener('drop', (e) => {
      e.preventDefault();
      e.stopPropagation();
      element.classList.remove('algo-drop-hover');

      const files = [];

      // Handle files from system
      if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
        Array.from(e.dataTransfer.files).forEach(file => {
          const reader = new FileReader();
          reader.onload = () => {
            files.push({ name: file.name, content: reader.result, type: file.type, size: file.size });
            if (files.length === e.dataTransfer.files.length && opts.onDrop) {
              opts.onDrop(files);
            }
          };
          if (file.type.startsWith('text/') || file.name.match(/\\.(txt|md|js|json|mid|dw)$/i)) {
            reader.readAsText(file);
          } else {
            reader.readAsDataURL(file);
          }
        });
      }

      // Handle ALGO file data (internal drag)
      const algoFile = e.dataTransfer.getData('application/x-algo-file');
      if (algoFile) {
        try {
          const fileData = JSON.parse(algoFile);
          if (opts.onDrop) opts.onDrop([fileData]);
        } catch (err) {}
      }
    });

    return element;
  },

  // === USER PRESENCE SYSTEM ===
  _presence: {},

  // Set current user's presence
  setPresence: function(status, data) {
    window._algoPresence = window._algoPresence || {};
    const userId = this.app.name + '-' + (data?.userId || 'user');
    window._algoPresence[userId] = {
      id: userId,
      name: data?.name || 'Anonymous',
      app: this.app.name,
      icon: this.app.icon,
      status: status, // online, away, busy, offline
      data: data || {},
      lastSeen: Date.now()
    };
    return userId;
  },

  // Get all present users, optionally filtered by app
  getPresence: function(appFilter) {
    window._algoPresence = window._algoPresence || {};
    const users = Object.values(window._algoPresence);
    if (appFilter) {
      return users.filter(u => u.app === appFilter);
    }
    return users;
  },

  // Remove user presence
  clearPresence: function(userId) {
    window._algoPresence = window._algoPresence || {};
    delete window._algoPresence[userId];
  },

  // === SHARED STATE ===
  // Simple key-value store for sharing state between apps
  setShared: function(key, value) {
    window._algoShared = window._algoShared || {};
    window._algoShared[key] = value;
  },

  getShared: function(key) {
    window._algoShared = window._algoShared || {};
    return window._algoShared[key];
  }
};
`;

const IDE_EXAMPLES = {
  'hello': {
    name: 'Hello World',
    code: `// Hello World App
ALGO.app.name = 'Hello App';
ALGO.app.icon = 'üëã';

// Create a simple window
ALGO.createWindow({
  title: 'Hello World',
  width: 300,
  height: 150,
  content: ALGO.ui.panel(
    '<h2>Hello, ALGO OS!</h2>' +
    '<p>Welcome to JavaScript.IDE</p>' +
    ALGO.ui.button('Say Hi', function() {
      ALGO.notify('Hello from my app!');
    })
  )
});

console.log('Hello World app created!');`
  },
  'counter': {
    name: 'Counter App',
    code: `// Counter App
ALGO.app.name = 'Counter';
ALGO.app.icon = 'üî¢';

window.counterVal = 0;

window.counterUpdate = function() {
  ALGO.setContent('counter-display', '<h1 style="text-align:center;font-size:48px;">' + window.counterVal + '</h1>');
};

ALGO.createWindow({
  title: 'Counter',
  width: 250,
  height: 200,
  content: '<div style="padding:20px;text-align:center;">' +
    '<div id="counter-display"><h1 style="font-size:48px;">0</h1></div>' +
    '<div>' +
      '<button onclick="window.counterVal--;window.counterUpdate();" style="padding:10px 20px;font-size:20px;">-</button>' +
      ' ' +
      '<button onclick="window.counterVal++;window.counterUpdate();" style="padding:10px 20px;font-size:20px;">+</button>' +
    '</div>' +
  '</div>'
});

console.log('Counter app ready!');`
  },
  'notepad': {
    name: 'Mini Notepad',
    code: `// Mini Notepad
ALGO.app.name = 'Mini Notepad';
ALGO.app.icon = 'üìù';

window.saveNote = function() {
  const text = ALGO.getValue('notepad-text');
  if (text) {
    ALGO.saveFile('note-' + Date.now() + '.txt', text, 'text');
    ALGO.notify('Note saved!');
  }
};

window.clearNote = function() {
  document.getElementById('notepad-text').value = '';
};

ALGO.createWindow({
  title: 'Mini Notepad',
  width: 400,
  height: 300,
  content: '<div style="display:flex;flex-direction:column;height:100%;">' +
    '<div style="padding:4px;background:#c0c0c0;">' +
      '<button onclick="window.saveNote()">Save</button>' +
      '<button onclick="window.clearNote()">Clear</button>' +
    '</div>' +
    '<textarea id="notepad-text" style="flex:1;padding:8px;border:none;resize:none;font-family:monospace;"></textarea>' +
  '</div>'
});

console.log('Mini Notepad ready!');`
  },
  'calculator': {
    name: 'Calculator',
    code: `// Simple Calculator
ALGO.app.name = 'Calculator';
ALGO.app.icon = 'üßÆ';

window.calcDisplay = '0';
window.calcLastOp = null;
window.calcLastNum = 0;

window.updateCalc = function() {
  document.getElementById('calc-display').value = window.calcDisplay;
};

window.calcDigit = function(d) {
  if (window.calcDisplay === '0') window.calcDisplay = d;
  else window.calcDisplay += d;
  window.updateCalc();
};

window.calcOp = function(op) {
  window.calcLastNum = parseFloat(window.calcDisplay);
  window.calcLastOp = op;
  window.calcDisplay = '0';
};

window.calcEquals = function() {
  const curr = parseFloat(window.calcDisplay);
  if (window.calcLastOp === '+') window.calcDisplay = String(window.calcLastNum + curr);
  else if (window.calcLastOp === '-') window.calcDisplay = String(window.calcLastNum - curr);
  else if (window.calcLastOp === '*') window.calcDisplay = String(window.calcLastNum * curr);
  else if (window.calcLastOp === '/') window.calcDisplay = String(window.calcLastNum / curr);
  window.calcLastOp = null;
  window.updateCalc();
};

window.calcClear = function() {
  window.calcDisplay = '0';
  window.calcLastOp = null;
  window.calcLastNum = 0;
  window.updateCalc();
};

const btnStyle = 'width:40px;height:35px;margin:2px;font-size:16px;';
ALGO.createWindow({
  title: 'Calculator',
  width: 220,
  height: 280,
  content: '<div style="padding:10px;">' +
    '<input id="calc-display" value="0" readonly style="width:100%;padding:8px;font-size:18px;text-align:right;margin-bottom:8px;">' +
    '<div>' +
      '<button onclick="window.calcDigit(\\'7\\')" style="' + btnStyle + '">7</button>' +
      '<button onclick="window.calcDigit(\\'8\\')" style="' + btnStyle + '">8</button>' +
      '<button onclick="window.calcDigit(\\'9\\')" style="' + btnStyle + '">9</button>' +
      '<button onclick="window.calcOp(\\'/\\')" style="' + btnStyle + '">/</button>' +
    '</div><div>' +
      '<button onclick="window.calcDigit(\\'4\\')" style="' + btnStyle + '">4</button>' +
      '<button onclick="window.calcDigit(\\'5\\')" style="' + btnStyle + '">5</button>' +
      '<button onclick="window.calcDigit(\\'6\\')" style="' + btnStyle + '">6</button>' +
      '<button onclick="window.calcOp(\\'*\\')" style="' + btnStyle + '">*</button>' +
    '</div><div>' +
      '<button onclick="window.calcDigit(\\'1\\')" style="' + btnStyle + '">1</button>' +
      '<button onclick="window.calcDigit(\\'2\\')" style="' + btnStyle + '">2</button>' +
      '<button onclick="window.calcDigit(\\'3\\')" style="' + btnStyle + '">3</button>' +
      '<button onclick="window.calcOp(\\'-\\')" style="' + btnStyle + '">-</button>' +
    '</div><div>' +
      '<button onclick="window.calcClear()" style="' + btnStyle + '">C</button>' +
      '<button onclick="window.calcDigit(\\'0\\')" style="' + btnStyle + '">0</button>' +
      '<button onclick="window.calcEquals()" style="' + btnStyle + '">=</button>' +
      '<button onclick="window.calcOp(\\'+\\')" style="' + btnStyle + '">+</button>' +
    '</div>' +
  '</div>'
});

console.log('Calculator ready!');`
  },
  'filehandler': {
    name: 'File Handler Demo',
    code: `// File Handler Demo - registers for .demo files
ALGO.app.name = 'Demo Viewer';
ALGO.app.icon = 'üìã';

// Register to handle .demo files
ALGO.registerFileType('demo', function(content, filename) {
  ALGO.createWindow({
    title: 'Viewing: ' + filename,
    width: 400,
    height: 300,
    content: '<div style="padding:15px;">' +
      '<h3>Demo File Contents:</h3>' +
      '<pre style="background:#f0f0f0;padding:10px;overflow:auto;">' + content + '</pre>' +
    '</div>'
  });
});

// Create a sample .demo file
ALGO.saveFile('sample.demo', 'This is a demo file!\\nIt was created by JavaScript.IDE.\\nDouble-click to open with Demo Viewer.', 'text');

ALGO.notify('Demo Viewer registered for .demo files!');
console.log('File handler registered. Created sample.demo on desktop.');`
  },
  'notepad2': {
    name: 'Notepad 2',
    code: `// Notepad 2 - Alternative Text Editor
ALGO.app.name = 'Notepad 2';
ALGO.app.icon = 'üìì';

// Track current file
window.np2File = null;
window.np2Modified = false;

// Register as handler for .txt files
ALGO.registerFileType('txt', function(content, filename, file) {
  window.np2File = file;
  window.np2Modified = false;
  const textarea = document.getElementById('np2-text');
  if (textarea) {
    textarea.value = content;
    document.getElementById('np2-title').textContent = filename;
  } else {
    openNp2Window(content, filename);
  }
});

function openNp2Window(content, filename) {
  ALGO.createWindow({
    title: (filename || 'Untitled') + ' - Notepad 2',
    width: 500,
    height: 400,
    content: '<div style="display:flex;flex-direction:column;height:100%;">' +
      '<div style="padding:4px;background:linear-gradient(#e8e8e8,#d0d0d0);border-bottom:1px solid #999;">' +
        '<span id="np2-title" style="font-weight:bold;">' + (filename || 'Untitled') + '</span>' +
        '<button onclick="np2New()" style="margin-left:10px;">New</button>' +
        '<button onclick="np2Save()">Save</button>' +
        '<button onclick="np2WordCount()">Word Count</button>' +
      '</div>' +
      '<textarea id="np2-text" style="flex:1;border:none;resize:none;font-family:Consolas,monospace;font-size:13px;padding:8px;line-height:1.5;" oninput="window.np2Modified=true">' +
        (content || '') +
      '</textarea>' +
      '<div id="np2-status" style="padding:4px 8px;background:#e8e8e8;border-top:1px solid #999;font-size:11px;color:#666;">Ready</div>' +
    '</div>'
  });
}

window.np2New = function() {
  window.np2File = null;
  window.np2Modified = false;
  document.getElementById('np2-text').value = '';
  document.getElementById('np2-title').textContent = 'Untitled';
  document.getElementById('np2-status').textContent = 'New file';
};

window.np2Save = function() {
  const text = document.getElementById('np2-text').value;
  const title = document.getElementById('np2-title').textContent;
  const filename = title === 'Untitled' ? 'note-' + Date.now() + '.txt' : title;
  ALGO.saveFile(filename, text, 'text');
  window.np2Modified = false;
  document.getElementById('np2-title').textContent = filename;
  document.getElementById('np2-status').textContent = 'Saved: ' + filename;
  ALGO.notify('Saved ' + filename);
};

window.np2WordCount = function() {
  const text = document.getElementById('np2-text').value;
  const words = text.trim() ? text.trim().split(/\\\\s+/).length : 0;
  const chars = text.length;
  const lines = text.split('\\\\n').length;
  document.getElementById('np2-status').textContent = words + ' words, ' + chars + ' characters, ' + lines + ' lines';
};

// Open initial window
openNp2Window('', '');
ALGO.notify('Notepad 2 ready! Registered for .txt files.');
console.log('Notepad 2 - a simple alternative text editor');`
  },
  'designer': {
    name: 'Layout Designer',
    code: `// Layout Designer - Create .layout files
ALGO.app.name = 'Designer';
ALGO.app.icon = 'üìê';

// Current layout data
window.designerLayout = {
  name: 'My Layout',
  size: { default: [40, 20], min: [20, 10], max: [80, 40] },
  grid: { cols: 40, rows: 20, gap: 1 },
  components: []
};
window.designerFile = null;
window.selectedComponent = null;

// Character units
const CW = 8, CH = 16;

function designerRender() {
  const layout = window.designerLayout;
  const w = layout.size.default[0] * CW;
  const h = layout.size.default[1] * CH;

  let html = '<div id="designer-canvas" style="position:relative;width:' + w + 'px;height:' + h + 'px;background:#fff;border:1px solid #000;background-image:linear-gradient(#eee 1px,transparent 1px),linear-gradient(90deg,#eee 1px,transparent 1px);background-size:' + CW + 'px ' + CH + 'px;" onclick="designerDeselect(event)">';

  layout.components.forEach((c, i) => {
    const sel = i === window.selectedComponent ? 'outline:2px solid #00f;' : '';
    const hasAnchor = c.anchor && Object.keys(c.anchor).length > 0;
    const anchorStyle = hasAnchor ? 'background:linear-gradient(135deg,#e0ffe0 25%,#e0e0ff 25%,#e0e0ff 50%,#e0ffe0 50%,#e0ffe0 75%,#e0e0ff 75%);background-size:8px 8px;' : 'background:#e0e0ff;';
    const label = c.ui || (c.id ? '(' + c.id + ')' : 'spacer');
    html += '<div class="designer-comp" data-idx="' + i + '" onclick="designerSelect(event,' + i + ')" style="position:absolute;left:' + ((c.x||0) * CW) + 'px;top:' + ((c.y||0) * CH) + 'px;width:' + ((c.w||10) * CW) + 'px;height:' + ((c.h||2) * CH) + 'px;' + anchorStyle + 'border:1px solid #888;cursor:move;font-size:10px;overflow:hidden;display:flex;align-items:center;justify-content:center;' + sel + '">' +
      '<span style="background:rgba(255,255,255,0.7);padding:1px 3px;">' + label + (hasAnchor ? ' ‚öì' : '') + '</span></div>';
  });

  html += '</div>';
  document.getElementById('designer-preview').innerHTML = html;
}

window.designerSelect = function(e, idx) {
  e.stopPropagation();
  window.selectedComponent = idx;
  designerRender();
  designerShowProps();
};

window.designerDeselect = function(e) {
  if (e.target.id === 'designer-canvas') {
    window.selectedComponent = null;
    designerRender();
    document.getElementById('designer-props').innerHTML = '<div style="color:#888;padding:8px;">Select a component</div>';
  }
};

function designerShowProps() {
  const idx = window.selectedComponent;
  if (idx === null) return;
  const c = window.designerLayout.components[idx];
  const anchor = c.anchor || {};
  const ids = window.designerLayout.components.map(x => x.id).filter(Boolean);
  const anchorOpts = '<option value="">--</option><option value="window">window</option>' +
    ids.filter(id => id !== c.id).map(id => '<option value="' + id + '">' + id + '</option>').join('');

  document.getElementById('designer-props').innerHTML =
    '<div style="padding:8px;font-size:11px;"><b>' + (c.ui || 'Spacer') + '</b><br>' +
    'ID: <input value="' + (c.id || '') + '" onchange="designerUpdateProp(\\'id\\',this.value)" style="width:90px;"><br>' +
    '<hr style="margin:4px 0;border:none;border-top:1px solid #ccc;">' +
    '<b>Position</b> (if no anchors):<br>' +
    'X: <input type="number" value="' + (c.x||0) + '" onchange="designerUpdateProp(\\'x\\',+this.value)" style="width:40px;"> ' +
    'Y: <input type="number" value="' + (c.y||0) + '" onchange="designerUpdateProp(\\'y\\',+this.value)" style="width:40px;"><br>' +
    'W: <input type="number" value="' + (c.w||10) + '" onchange="designerUpdateProp(\\'w\\',+this.value)" style="width:40px;"> ' +
    'H: <input type="number" value="' + (c.h||2) + '" onchange="designerUpdateProp(\\'h\\',+this.value)" style="width:40px;"><br>' +
    '<hr style="margin:4px 0;border:none;border-top:1px solid #ccc;">' +
    '<b>Anchors</b> (element.edge +/- offset):<br>' +
    '<div style="display:grid;grid-template-columns:40px 1fr;gap:2px;margin:4px 0;">' +
    '<span>Left:</span><input value="' + (anchor.left||'') + '" onchange="designerUpdateAnchor(\\'left\\',this.value)" style="width:100%;font-size:10px;" placeholder="window.left + 1">' +
    '<span>Right:</span><input value="' + (anchor.right||'') + '" onchange="designerUpdateAnchor(\\'right\\',this.value)" style="width:100%;font-size:10px;" placeholder="window.right - 1">' +
    '<span>Top:</span><input value="' + (anchor.top||'') + '" onchange="designerUpdateAnchor(\\'top\\',this.value)" style="width:100%;font-size:10px;" placeholder="window.top + 1">' +
    '<span>Btm:</span><input value="' + (anchor.bottom||'') + '" onchange="designerUpdateAnchor(\\'bottom\\',this.value)" style="width:100%;font-size:10px;" placeholder="window.bottom - 1">' +
    '</div>' +
    '<div style="font-size:9px;color:#666;margin:4px 0;">Format: element.edge +/- offset<br>Elements: window, or component ID</div>' +
    '<button onclick="designerDeleteComp()" style="margin-top:8px;color:red;">Delete</button></div>';
}

window.designerUpdateAnchor = function(edge, val) {
  if (window.selectedComponent !== null) {
    const c = window.designerLayout.components[window.selectedComponent];
    if (!c.anchor) c.anchor = {};
    if (val.trim()) {
      c.anchor[edge] = val.trim();
    } else {
      delete c.anchor[edge];
      if (Object.keys(c.anchor).length === 0) delete c.anchor;
    }
    designerRender();
  }
};

window.designerUpdateProp = function(prop, val) {
  if (window.selectedComponent !== null) {
    window.designerLayout.components[window.selectedComponent][prop] = val;
    designerRender();
  }
};

window.designerDeleteComp = function() {
  if (window.selectedComponent !== null) {
    window.designerLayout.components.splice(window.selectedComponent, 1);
    window.selectedComponent = null;
    designerRender();
    document.getElementById('designer-props').innerHTML = '<div style="color:#888;padding:8px;">Select a component</div>';
  }
};

window.designerAddComp = function() {
  const ui = prompt('UI component filename (e.g., slider.ui)\\nLeave blank for spacer/anchor point:');
  if (ui !== null) {
    const comp = {
      id: 'comp-' + Date.now(), x: 1, y: 1, w: 10, h: 2, props: {}
    };
    if (ui.trim()) comp.ui = ui.trim();
    window.designerLayout.components.push(comp);
    designerRender();
  }
};

window.designerSave = function() {
  const json = JSON.stringify(window.designerLayout, null, 2);
  const name = window.designerFile || (window.designerLayout.name.toLowerCase().replace(/\\s+/g, '-') + '.layout');
  ALGO.saveFile(name, json, 'text');
  window.designerFile = name;
  ALGO.notify('Saved ' + name);
};

window.designerUpdateSize = function() {
  const w = +document.getElementById('designer-w').value || 40;
  const h = +document.getElementById('designer-h').value || 20;
  window.designerLayout.size.default = [w, h];
  window.designerLayout.grid.cols = w;
  window.designerLayout.grid.rows = h;
  designerRender();
};

// Register as handler for .layout files
ALGO.registerFileType('layout', function(content, filename) {
  try {
    window.designerLayout = JSON.parse(content);
    window.designerFile = filename;
    document.getElementById('designer-w').value = window.designerLayout.size?.default?.[0] || 40;
    document.getElementById('designer-h').value = window.designerLayout.size?.default?.[1] || 20;
    designerRender();
    ALGO.notify('Loaded ' + filename);
  } catch (e) {
    ALGO.notify('Invalid layout file');
  }
});

ALGO.createWindow({
  title: 'Layout Designer',
  width: 600,
  height: 450,
  content: '<div style="display:flex;height:100%;">' +
    '<div style="flex:1;display:flex;flex-direction:column;">' +
      '<div style="padding:4px;background:#e0e0e0;border-bottom:1px solid #999;">' +
        '<button onclick="designerAddComp()">+ Add Component</button> ' +
        '<button onclick="designerSave()">Save</button> ' +
        'Size: <input id="designer-w" type="number" value="40" style="width:40px;" onchange="designerUpdateSize()">x' +
        '<input id="designer-h" type="number" value="20" style="width:40px;" onchange="designerUpdateSize()"> chars' +
      '</div>' +
      '<div id="designer-preview" style="flex:1;overflow:auto;padding:8px;background:#f0f0f0;"></div>' +
    '</div>' +
    '<div id="designer-props" style="width:180px;background:#e8e8e8;border-left:1px solid #999;overflow-y:auto;">' +
      '<div style="color:#888;padding:8px;">Select a component</div>' +
    '</div>' +
  '</div>'
});

designerRender();
console.log('Layout Designer - create and edit .layout files');`
  },
  'widget': {
    name: 'Widget Editor',
    code: `// Widget Editor - Create .ui component files
ALGO.app.name = 'Widget';
ALGO.app.icon = 'üéõÔ∏è';

// Current UI component
window.widgetData = {
  name: 'My Widget',
  icon: 'üî≤',
  size: { default: [10, 2], min: [5, 1], max: [20, 4] },
  props: {},
  html: '<div class="widget">Hello</div>',
  css: '.widget { padding: 4px; background: #e0e0e0; border: 1px solid #999; }',
  js: '// Widget initialization code'
};
window.widgetFile = null;

function widgetRender() {
  const ui = window.widgetData;
  const w = (ui.size?.default?.[0] || 10) * 8;
  const h = (ui.size?.default?.[1] || 2) * 16;

  let preview = '<style>' + (ui.css || '') + '</style>';
  preview += '<div style="width:' + w + 'px;height:' + h + 'px;overflow:hidden;border:1px solid #ccc;background:#fff;">';
  preview += ui.html || '';
  preview += '</div>';

  document.getElementById('widget-preview').innerHTML = preview;

  // Run JS in try-catch
  if (ui.js) {
    try {
      const fn = new Function(ui.js);
      fn();
    } catch (e) {
      console.error('Widget JS error:', e);
    }
  }
}

window.widgetSave = function() {
  const json = JSON.stringify(window.widgetData, null, 2);
  const name = window.widgetFile || (window.widgetData.name.toLowerCase().replace(/\\s+/g, '-') + '.ui');
  ALGO.saveFile(name, json, 'text');
  window.widgetFile = name;
  ALGO.notify('Saved ' + name);
};

window.widgetUpdateMeta = function() {
  window.widgetData.name = document.getElementById('widget-name').value;
  window.widgetData.icon = document.getElementById('widget-icon').value;
  const w = +document.getElementById('widget-w').value || 10;
  const h = +document.getElementById('widget-h').value || 2;
  window.widgetData.size.default = [w, h];
};

window.widgetUpdateCode = function() {
  window.widgetData.html = document.getElementById('widget-html').value;
  window.widgetData.css = document.getElementById('widget-css').value;
  window.widgetData.js = document.getElementById('widget-js').value;
  widgetRender();
};

// Register as handler for .ui files
ALGO.registerFileType('ui', function(content, filename) {
  try {
    window.widgetData = JSON.parse(content);
    window.widgetFile = filename;
    document.getElementById('widget-name').value = window.widgetData.name || '';
    document.getElementById('widget-icon').value = window.widgetData.icon || '';
    document.getElementById('widget-w').value = window.widgetData.size?.default?.[0] || 10;
    document.getElementById('widget-h').value = window.widgetData.size?.default?.[1] || 2;
    document.getElementById('widget-html').value = window.widgetData.html || '';
    document.getElementById('widget-css').value = window.widgetData.css || '';
    document.getElementById('widget-js').value = window.widgetData.js || '';
    widgetRender();
    ALGO.notify('Loaded ' + filename);
  } catch (e) {
    ALGO.notify('Invalid UI file');
  }
});

ALGO.createWindow({
  title: 'Widget Editor',
  width: 650,
  height: 500,
  content: '<div style="display:flex;flex-direction:column;height:100%;">' +
    '<div style="padding:4px;background:#e0e0e0;border-bottom:1px solid #999;">' +
      'Name: <input id="widget-name" value="My Widget" style="width:100px;" onchange="widgetUpdateMeta()"> ' +
      'Icon: <input id="widget-icon" value="üî≤" style="width:30px;" onchange="widgetUpdateMeta()"> ' +
      'Size: <input id="widget-w" type="number" value="10" style="width:40px;" onchange="widgetUpdateMeta()">x' +
      '<input id="widget-h" type="number" value="2" style="width:40px;" onchange="widgetUpdateMeta()"> ' +
      '<button onclick="widgetSave()">Save</button> ' +
      '<button onclick="widgetRender()">Refresh</button>' +
    '</div>' +
    '<div style="flex:1;display:flex;overflow:hidden;">' +
      '<div style="flex:1;display:flex;flex-direction:column;border-right:1px solid #999;">' +
        '<div style="padding:2px 4px;background:#d0d0d0;font-weight:bold;font-size:10px;">HTML</div>' +
        '<textarea id="widget-html" style="flex:1;border:none;resize:none;font-family:monospace;font-size:11px;padding:4px;" onchange="widgetUpdateCode()"><div class="widget">Hello</div></textarea>' +
        '<div style="padding:2px 4px;background:#d0d0d0;font-weight:bold;font-size:10px;">CSS</div>' +
        '<textarea id="widget-css" style="flex:1;border:none;resize:none;font-family:monospace;font-size:11px;padding:4px;" onchange="widgetUpdateCode()">.widget { padding: 4px; background: #e0e0e0; border: 1px solid #999; }</textarea>' +
        '<div style="padding:2px 4px;background:#d0d0d0;font-weight:bold;font-size:10px;">JavaScript</div>' +
        '<textarea id="widget-js" style="flex:1;border:none;resize:none;font-family:monospace;font-size:11px;padding:4px;" onchange="widgetUpdateCode()">// Widget initialization code</textarea>' +
      '</div>' +
      '<div style="width:200px;display:flex;flex-direction:column;">' +
        '<div style="padding:2px 4px;background:#d0d0d0;font-weight:bold;font-size:10px;">Preview</div>' +
        '<div id="widget-preview" style="flex:1;padding:8px;background:#f8f8f8;overflow:auto;"></div>' +
      '</div>' +
    '</div>' +
  '</div>'
});

widgetRender();
console.log('Widget Editor - create and edit .ui component files');`
  }
};

function openJSIDE(content, filename) {
  content = content || '';
  filename = filename || '';
  const id = winId;

  const defaultCode = `// ALGO OS App - JavaScript.IDE
// Use the ALGO API to create apps!

ALGO.app.name = 'My App';
ALGO.app.icon = 'üöÄ';

// Create a window
ALGO.createWindow({
  title: 'My First App',
  width: 300,
  height: 200,
  content: '<div style="padding:20px;text-align:center;">' +
    '<h2>Welcome!</h2>' +
    '<p>Edit this code to build your app.</p>' +
    '<button onclick="ALGO.notify(\\'Hello!\\')">Click Me</button>' +
  '</div>'
});

console.log('App started!');`;

  const exampleOptions = Object.entries(IDE_EXAMPLES).map(([k, v]) =>
    '<option value="' + k + '">' + v.name + '</option>'
  ).join('');

  createWindow({
    title: filename || 'Untitled - JavaScript.IDE',
    stateKey: 'JavaScript.IDE',
    icon: 'üìú',
    width: 850, height: 500,
    menubar: '<div class="window-menubar">' +
      '<div class="menu-item" onclick="toggleMenu(\'ide-menu-' + id + '\')">' +
        'File' +
        '<div class="dropdown-menu" id="ide-menu-' + id + '">' +
          '<div class="dropdown-item" onclick="ideNew(' + id + ')">New</div>' +
          '<div class="dropdown-item" onclick="ideSave(' + id + ')">Save to Desktop</div>' +
          '<div class="dropdown-item" onclick="ideCompile(' + id + ')">Compile App...</div>' +
          '<div class="dropdown-item" onclick="ideInstall(' + id + ')">Install as Program</div>' +
        '</div>' +
      '</div>' +
      '<div class="menu-item" onclick="toggleMenu(\'ide-help-' + id + '\')">' +
        'Help' +
        '<div class="dropdown-menu" id="ide-help-' + id + '">' +
          '<div class="dropdown-item" onclick="ideShowAPI(' + id + ')">API Reference</div>' +
        '</div>' +
      '</div>' +
    '</div>',
    content: '<div class="ide-container">' +
      '<div class="ide-main">' +
        '<div class="ide-editor">' +
          '<div class="ide-toolbar">' +
            '<button onclick="ideRun(' + id + ')">‚ñ∂ Run</button>' +
            '<button onclick="ideStop(' + id + ')">‚¨õ Stop</button>' +
            '<select onchange="ideLoadExample(' + id + ', this.value)">' +
              '<option value="">-- Examples --</option>' +
              exampleOptions +
            '</select>' +
          '</div>' +
          '<textarea id="ide-code-' + id + '" spellcheck="false">' + escapeHtml(content || defaultCode) + '</textarea>' +
        '</div>' +
        '<div class="ide-preview">' +
          '<div class="ide-preview-header">' +
            '<span>Preview</span>' +
            '<button onclick="ideRefresh(' + id + ')" style="padding:1px 6px;font-size:10px;">‚Üª Refresh</button>' +
          '</div>' +
          '<div class="ide-preview-content" id="ide-preview-' + id + '">' +
            '<div style="padding:20px;color:#888;text-align:center;">Click Run to see your app</div>' +
          '</div>' +
        '</div>' +
      '</div>' +
      '<div class="ide-console" id="ide-console-' + id + '">' +
        '<div class="ide-console-header" onclick="ideToggleConsole(' + id + ')">' +
          '<span>Console</span>' +
          '<span id="ide-console-toggle-' + id + '">‚ñº</span>' +
        '</div>' +
        '<div class="ide-console-content" id="ide-console-content-' + id + '"></div>' +
      '</div>' +
    '</div>'
  });
}

function ideRun(id) {
  const code = document.getElementById('ide-code-' + id).value;
  const consoleEl = document.getElementById('ide-console-content-' + id);
  consoleEl.innerHTML = '';

  // Custom console that logs to our console pane
  const ideConsole = {
    log: function() {
      const args = Array.prototype.slice.call(arguments);
      const text = args.map(a => typeof a === 'object' ? JSON.stringify(a, null, 2) : String(a)).join(' ');
      consoleEl.innerHTML += '<div>' + escapeHtml(text) + '</div>';
      consoleEl.scrollTop = consoleEl.scrollHeight;
    },
    error: function() {
      const args = Array.prototype.slice.call(arguments);
      const text = args.map(a => typeof a === 'object' ? JSON.stringify(a, null, 2) : String(a)).join(' ');
      consoleEl.innerHTML += '<div class="error">Error: ' + escapeHtml(text) + '</div>';
      consoleEl.scrollTop = consoleEl.scrollHeight;
    },
    warn: function() {
      const args = Array.prototype.slice.call(arguments);
      const text = args.map(a => typeof a === 'object' ? JSON.stringify(a, null, 2) : String(a)).join(' ');
      consoleEl.innerHTML += '<div class="warn">Warning: ' + escapeHtml(text) + '</div>';
      consoleEl.scrollTop = consoleEl.scrollHeight;
    },
    info: function() {
      const args = Array.prototype.slice.call(arguments);
      const text = args.map(a => typeof a === 'object' ? JSON.stringify(a, null, 2) : String(a)).join(' ');
      consoleEl.innerHTML += '<div class="info">' + escapeHtml(text) + '</div>';
      consoleEl.scrollTop = consoleEl.scrollHeight;
    }
  };

  try {
    // Combine ALGO API with user code
    const fullCode = ALGO_API_CODE + '\n' + code;
    // Store original console and replace with IDE console
    const origConsole = window.console;
    window.console = ideConsole;
    // Execute in global scope using indirect eval
    (0, eval)(fullCode);
    // Restore original console
    window.console = origConsole;
    ideConsole.info('‚úì App executed successfully');
  } catch (e) {
    ideConsole.error(e.message);
    if (e.stack) {
      const stackLines = e.stack.split('\n').slice(1, 3).join('\n');
      consoleEl.innerHTML += '<div class="error" style="font-size:10px;opacity:0.7;">' + escapeHtml(stackLines) + '</div>';
    }
  }
}

function ideStop(id) {
  const consoleEl = document.getElementById('ide-console-content-' + id);
  consoleEl.innerHTML += '<div class="warn">Execution stopped</div>';
}

function ideToggleConsole(id) {
  const consoleEl = document.getElementById('ide-console-' + id);
  const toggleEl = document.getElementById('ide-console-toggle-' + id);
  consoleEl.classList.toggle('collapsed');
  toggleEl.textContent = consoleEl.classList.contains('collapsed') ? '‚ñ≤' : '‚ñº';
}

function ideLoadExample(id, exampleKey) {
  if (!exampleKey || !IDE_EXAMPLES[exampleKey]) return;
  document.getElementById('ide-code-' + id).value = IDE_EXAMPLES[exampleKey].code;
  const consoleEl = document.getElementById('ide-console-content-' + id);
  consoleEl.innerHTML = '<div class="info">Loaded example: ' + IDE_EXAMPLES[exampleKey].name + '</div>';
}

function ideRefresh(id) {
  ideRun(id);
}

function ideShowAPI(id) {
  hideMenus();
  createWindow({
    title: 'ALGO API Reference',
    icon: 'üìñ',
    width: 450, height: 400,
    content: '<div style="padding:15px;overflow:auto;height:100%;font-size:11px;">' +
      '<h2>ALGO OS App API</h2>' +
      '<h3>App Metadata</h3>' +
      '<pre>ALGO.app.name = "My App";\nALGO.app.icon = "üì±";</pre>' +
      '<h3>Create Window</h3>' +
      '<pre>ALGO.createWindow({\n  title: "Window Title",\n  width: 400, height: 300,\n  content: "&lt;div&gt;HTML content&lt;/div&gt;"\n});</pre>' +
      '<h3>UI Helpers</h3>' +
      '<pre>ALGO.ui.button(label, onclick)\nALGO.ui.input(id, placeholder)\nALGO.ui.label(text)\nALGO.ui.select(id, [{value, label}])\nALGO.ui.panel(content)</pre>' +
      '<h3>File Operations</h3>' +
      '<pre>ALGO.saveFile(name, content, type)\nALGO.registerFileType(ext, handler)</pre>' +
      '<h3>Utilities</h3>' +
      '<pre>ALGO.notify(message)\nALGO.getValue(elementId)\nALGO.setContent(elementId, html)</pre>' +
    '</div>'
  });
}

function ideNew(id) {
  const defaultCode = `// ALGO OS App - JavaScript.IDE
ALGO.app.name = 'My App';
ALGO.app.icon = 'üöÄ';

ALGO.createWindow({
  title: 'My App',
  width: 300,
  height: 200,
  content: '<div style="padding:20px;text-align:center;">' +
    '<h2>Hello!</h2>' +
  '</div>'
});`;
  document.getElementById('ide-code-' + id).value = defaultCode;
  document.querySelector('#win-' + id + ' .title').innerHTML = 'üìú Untitled - JavaScript.IDE';
  document.getElementById('ide-console-content-' + id).innerHTML = '';
  hideMenus();
}

function ideSave(id) {
  const code = document.getElementById('ide-code-' + id).value.trim();
  if (!code) return;
  const m = code.match(/ALGO\.app\.name\s*=\s*['"]([^'"]+)['"]/);
  const appName = m ? m[1] : 'script';
  let filename = appName.replace(/\s+/g, '-').toLowerCase() + '.js';
  let counter = 1;
  while (savedFiles.some(f => f.name === filename)) {
    counter++;
    filename = appName.replace(/\s+/g, '-').toLowerCase() + '(' + counter + ').js';
  }
  savedFiles.push({ name: filename, content: code, room: null });
  saveState();
  createDesktopIcons();
  hideMenus();
  algoSpeak('Saved ' + filename + '!');
}

function ideInstall(id) {
  const code = document.getElementById('ide-code-' + id).value.trim();
  if (!code) return;

  // Extract app metadata
  const nameMatch = code.match(/ALGO\.app\.name\s*=\s*['"]([^'"]+)['"]/);
  const iconMatch = code.match(/ALGO\.app\.icon\s*=\s*['"]([^'"]+)['"]/);
  const appName = nameMatch ? nameMatch[1] : 'My App';
  const appIcon = iconMatch ? iconMatch[1] : 'üì±';

  // Install as program
  const progId = 'ide-' + Date.now();
  installedPrograms.push({
    id: progId,
    name: appName,
    icon: appIcon,
    code: code
  });
  updateProgramsMenu();
  saveState();
  createDesktopIcons();
  hideMenus();
  algoSpeak('Installed ' + appName + '!');
}

async function ideCompile(id) {
  const code = document.getElementById('ide-code-' + id).value.trim();
  if (!code) return;
  hideMenus();

  // Extract app metadata
  const nameMatch = code.match(/ALGO\.app\.name\s*=\s*['"]([^'"]+)['"]/);
  const iconMatch = code.match(/ALGO\.app\.icon\s*=\s*['"]([^'"]+)['"]/);
  const folderMatch = code.match(/ALGO\.app\.folder\s*=\s*['"]([^'"]+)['"]/);
  const appName = nameMatch ? nameMatch[1] : 'My App';
  const appIcon = iconMatch ? iconMatch[1] : 'üì±';
  const folder = folderMatch ? folderMatch[1] : '';

  // Find layout references in code
  const layoutRefs = code.match(/createLayoutWindow\s*\(\s*['"]([^'"]+)['"]/g) || [];
  const layoutNames = layoutRefs.map(r => r.match(/['"]([^'"]+)['"]/)[1]);

  // Check for direct .layout file references
  const layoutFileRefs = code.match(/['"][^'"]+\.layout['"]/g) || [];
  layoutFileRefs.forEach(r => {
    const name = r.replace(/['"]/g, '');
    if (!layoutNames.includes(name)) layoutNames.push(name);
  });

  if (layoutNames.length === 0 && folder) {
    // If folder specified, check for layouts in that folder
    algoSpeak('Scanning folder ' + folder + '...');
  }

  let bundledLayouts = {};
  let bundledUIs = {};

  if (layoutNames.length > 0 || folder) {
    algoSpeak('Bundling dependencies...');

    try {
      // Fetch layouts
      const layoutFiles = folder ?
        await fetch('https://laserbarf.com/api/algo-files?folder=' + encodeURIComponent(folder) + '&type=layout')
          .then(r => r.json()).then(d => d.files || []) :
        [];

      // Get layout contents from API or local files
      const layoutNamesToFetch = layoutNames.map(n => folder ? folder + '/' + n : n);
      layoutFiles.forEach(f => {
        if (!layoutNamesToFetch.includes(f.name)) layoutNamesToFetch.push(f.name);
      });

      if (layoutNamesToFetch.length > 0) {
        const layoutContents = await fetch('https://laserbarf.com/api/algo-files', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ names: layoutNamesToFetch })
        }).then(r => r.json()).then(d => d.files || {});

        // Parse layouts and collect UI references
        const uiNames = [];
        Object.entries(layoutContents).forEach(([name, data]) => {
          try {
            const layout = JSON.parse(data.content);
            bundledLayouts[name.split('/').pop()] = layout;
            (layout.components || []).forEach(c => {
              if (c.ui && !uiNames.includes(c.ui)) {
                uiNames.push(folder ? folder + '/' + c.ui : c.ui);
              }
            });
          } catch (e) {
            console.error('Failed to parse layout:', name, e);
          }
        });

        // Fetch UI files
        if (uiNames.length > 0) {
          const uiContents = await fetch('https://laserbarf.com/api/algo-files', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ names: uiNames })
          }).then(r => r.json()).then(d => d.files || {});

          Object.entries(uiContents).forEach(([name, data]) => {
            try {
              bundledUIs[name.split('/').pop()] = JSON.parse(data.content);
            } catch (e) {
              console.error('Failed to parse UI:', name, e);
            }
          });
        }
      }
    } catch (e) {
      console.error('Compile error:', e);
      algoSpeak('Error fetching dependencies: ' + e.message);
    }
  }

  // Generate bundled code
  let bundledCode = '// Compiled App: ' + appName + '\n';
  bundledCode += '// Generated by JAVASCRIPT.IDE on ' + new Date().toISOString() + '\n\n';

  // Embed layouts and UIs if any
  if (Object.keys(bundledLayouts).length > 0 || Object.keys(bundledUIs).length > 0) {
    bundledCode += '// === BUNDLED RESOURCES ===\n';
    bundledCode += 'window._bundledLayouts = ' + JSON.stringify(bundledLayouts, null, 2) + ';\n';
    bundledCode += 'window._bundledUIs = ' + JSON.stringify(bundledUIs, null, 2) + ';\n\n';
    bundledCode += '// Override ALGO layout functions to use bundled resources\n';
    bundledCode += 'const _origLoadFiles = ALGO.loadFiles;\n';
    bundledCode += 'ALGO.loadFiles = async function(folder, type) {\n';
    bundledCode += '  if (type === "layout" && window._bundledLayouts) {\n';
    bundledCode += '    return Object.keys(window._bundledLayouts).map(n => ({ name: n, type: "layout" }));\n';
    bundledCode += '  }\n';
    bundledCode += '  if (type === "ui" && window._bundledUIs) {\n';
    bundledCode += '    return Object.keys(window._bundledUIs).map(n => ({ name: n, type: "ui" }));\n';
    bundledCode += '  }\n';
    bundledCode += '  return _origLoadFiles.call(this, folder, type);\n';
    bundledCode += '};\n\n';
    bundledCode += 'const _origGetContents = ALGO.getFileContents;\n';
    bundledCode += 'ALGO.getFileContents = async function(names) {\n';
    bundledCode += '  const result = {};\n';
    bundledCode += '  names.forEach(n => {\n';
    bundledCode += '    const short = n.split("/").pop();\n';
    bundledCode += '    if (short.endsWith(".layout") && window._bundledLayouts[short]) {\n';
    bundledCode += '      result[n] = { content: JSON.stringify(window._bundledLayouts[short]), type: "layout" };\n';
    bundledCode += '    } else if (short.endsWith(".ui") && window._bundledUIs[short]) {\n';
    bundledCode += '      result[n] = { content: JSON.stringify(window._bundledUIs[short]), type: "ui" };\n';
    bundledCode += '    }\n';
    bundledCode += '  });\n';
    bundledCode += '  if (Object.keys(result).length < names.length) {\n';
    bundledCode += '    const remaining = await _origGetContents.call(this, names.filter(n => !result[n]));\n';
    bundledCode += '    Object.assign(result, remaining);\n';
    bundledCode += '  }\n';
    bundledCode += '  return result;\n';
    bundledCode += '};\n\n';
  }

  bundledCode += '// === APP CODE ===\n';
  bundledCode += code;

  // Prompt for filename
  const defaultFilename = appName.toLowerCase().replace(/\s+/g, '-') + '-compiled.js';
  const filename = prompt('Save compiled app as:', defaultFilename);
  if (!filename) return;

  // Save to desktop (compiled apps can use app icon since they're self-contained)
  savedFiles.push({
    name: filename,
    content: bundledCode,
    room: null,
    compiled: true,
    appIcon: appIcon
  });
  saveState();
  createDesktopIcons();

  const layoutCount = Object.keys(bundledLayouts).length;
  const uiCount = Object.keys(bundledUIs).length;
  let msg = 'Compiled ' + filename;
  if (layoutCount || uiCount) {
    msg += ' (bundled: ' + layoutCount + ' layouts, ' + uiCount + ' UIs)';
  }
  algoSpeak(msg);
}

// ==================== WEB BROWSER ====================
function openBrowser(url) {
  const id = winId;
  const startUrl = url || 'https://laserbarf.com';
  createWindow({
    title: 'Web Browser',
    stateKey: 'Web Browser',
    icon: 'üåê',
    width: 700, height: 500,
    content: '<div style="display:flex;flex-direction:column;height:100%;">' +
      '<div class="browser-toolbar">' +
        '<button onclick="browserBack(' + id + ')">‚Üê</button>' +
        '<button onclick="browserFwd(' + id + ')">‚Üí</button>' +
        '<input type="text" class="browser-url" id="browser-url-' + id + '" value="' + escapeHtml(startUrl) + '" onkeydown="if(event.key===\'Enter\')browserGo(' + id + ')">' +
        '<button onclick="browserGo(' + id + ')">Go</button>' +
      '</div>' +
      '<iframe class="browser-frame" id="browser-frame-' + id + '" src="' + startUrl + '"></iframe>' +
    '</div>'
  });
}

function browserGo(id) {
  let url = document.getElementById('browser-url-' + id).value;
  if (!url.startsWith('http')) url = 'https://' + url;
  document.getElementById('browser-frame-' + id).src = url;
}

function browserBack(id) {
  try { document.getElementById('browser-frame-' + id).contentWindow.history.back(); } catch(e) {}
}

function browserFwd(id) {
  try { document.getElementById('browser-frame-' + id).contentWindow.history.forward(); } catch(e) {}
}

// ==================== AI WIZARDS ====================
function openClaudeWizard() { openAIWizard('claude', 'ü§ñ', 'Claude Wizard', 'anthropic'); }
function openGeminiWizard() { openAIWizard('gemini', 'üíé', 'Gemini Wizard', 'google'); }
function openGPTWizard() { openAIWizard('gpt', 'üß†', 'GPT Wizard', 'openai'); }

function openAIWizard(provider, icon, title, providerKey) {
  const id = winId;
  const savedKey = apiKeys[provider] || '';
  createWindow({
    title: title,
    stateKey: title,
    icon: icon,
    width: 500, height: 450,
    content: '<div class="wizard-container">' +
      '<div class="wizard-header">' +
        '<div class="icon">' + icon + '</div>' +
        '<div><h2>' + title + '</h2><p>Create artifacts with AI</p></div>' +
      '</div>' +
      '<div class="wizard-form">' +
        '<label>API Key:</label>' +
        '<input type="password" id="wizard-key-' + id + '" value="' + savedKey + '" placeholder="Enter your ' + provider.toUpperCase() + ' API key">' +
        '<button onclick="saveApiKey(\'' + provider + '\',' + id + ')">Save Key</button>' +
        '<label style="margin-top:10px;">Describe your artifact:</label>' +
        '<textarea id="wizard-prompt-' + id + '" placeholder="e.g., A retro space invaders game with neon colors"></textarea>' +
        '<div class="wizard-buttons">' +
          '<button onclick="generateArtifact(\'' + providerKey + '\',' + id + ')">‚ú® Generate</button>' +
        '</div>' +
        '<div class="wizard-status" id="wizard-status-' + id + '">Ready to create!</div>' +
      '</div>' +
    '</div>'
  });
}

function saveApiKey(provider, id) {
  const key = document.getElementById('wizard-key-' + id).value.trim();
  if (key) {
    apiKeys[provider] = key;
    saveState();
    document.getElementById('wizard-status-' + id).textContent = 'API key saved!';
  }
}

function generateArtifact(provider, id) {
  const key = document.getElementById('wizard-key-' + id).value.trim();
  const prompt = document.getElementById('wizard-prompt-' + id).value.trim();
  const status = document.getElementById('wizard-status-' + id);

  if (!key) { status.textContent = 'Please enter an API key!'; return; }
  if (!prompt) { status.textContent = 'Please describe what to create!'; return; }

  status.textContent = 'Generating... please wait...';

  fetch('/api/ai-create', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ provider: provider, apiKey: key, prompt: prompt })
  })
  .then(r => r.json())
  .then(data => {
    if (data.error) {
      status.textContent = 'Error: ' + data.error;
      return;
    }
    if (data.html) {
      // Generate a name from prompt
      const words = prompt.split(/\s+/).slice(0, 2).join('-').toLowerCase().replace(/[^a-z0-9-]/g, '') || 'artifact';
      const name = words + '-' + Date.now().toString(36);

      // Post to algo-world with key
      const postContent = '#' + name + ':dolphin42\n' + data.html;

      fetch('/', {
        method: 'POST',
        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
        body: 'yo=489&text=' + encodeURIComponent(postContent) + '&save=POST'
      }).then(() => {
        // Add to installed programs
        installedPrograms.push({ id: name, name: name, url: '/' + name + ':dolphin42', icon: '‚ú®' });
        saveState();
        createDesktopIcons();
        updateProgramsMenu();
        status.textContent = 'Created! ' + name + ' is on your desktop.';
        algoSpeak('New app created: ' + name);
      });
    }
  })
  .catch(e => {
    status.textContent = 'Network error: ' + e.message;
  });
}

// ==================== P2P CHAT ====================
function openChat() {
  const id = winId;
  chatWinId = id;
  chatName = localStorage.getItem('algo-chat-name') || 'anon';
  createWindow({
    title: 'ALGO Chat (P2P)',
    stateKey: 'ALGO Chat',
    icon: 'üí¨',
    width: 500, height: 400,
    content: '<div class="chat-container">' +
      '<div style="padding:4px;background:#c0c0c0;border-bottom:1px solid #808080;display:flex;gap:4px;align-items:center;">' +
        '<label>Name:</label>' +
        '<input type="text" id="chat-name-' + id + '" value="' + escapeHtml(chatName) + '" style="width:80px;padding:2px;border:2px inset #808080;" onchange="updateChatName(' + id + ')">' +
        '<span style="margin-left:auto;font-size:10px;color:#666;" id="chat-status-' + id + '">Connecting...</span>' +
      '</div>' +
      '<div style="display:flex;flex:1;overflow:hidden;">' +
        '<div class="chat-messages" id="chat-messages-' + id + '"></div>' +
        '<div class="users-list" id="chat-users-' + id + '">' +
          '<h4>Online</h4>' +
          '<div id="online-users-' + id + '"></div>' +
        '</div>' +
      '</div>' +
      '<div class="chat-input-area">' +
        '<input type="text" id="chat-input-' + id + '" placeholder="Type a message..." onkeydown="if(event.key===\'Enter\')sendChatP2P(' + id + ')">' +
        '<button onclick="sendChatP2P(' + id + ')">Send</button>' +
      '</div>' +
    '</div>',
    onClose: () => { leaveChat(); }
  });

  joinChat();
}

function updateChatName(id) {
  chatName = document.getElementById('chat-name-' + id).value.trim() || 'anon';
  localStorage.setItem('algo-chat-name', chatName);
  // Broadcast name to all peers
  Object.values(chatPeers).forEach(peer => {
    if (peer.dataChannel && peer.dataChannel.readyState === 'open') {
      peer.dataChannel.send(JSON.stringify({ type: 'name', name: chatName }));
    }
  });
  updateChatUsers();
}

function joinChat() {
  fetch('/api/signal', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ action: 'join', room: chatRoom, peerId: chatPeerId })
  }).then(() => {
    if (chatWinId !== null) {
      const status = document.getElementById('chat-status-' + chatWinId);
      if (status) status.textContent = 'Connected';
    }
    chatPollInterval = setInterval(pollChatSignals, 1000);
    pollChatSignals();
  });
}

function leaveChat() {
  if (chatPollInterval) clearInterval(chatPollInterval);
  chatPollInterval = null;

  fetch('/api/signal', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ action: 'leave', room: chatRoom, peerId: chatPeerId })
  });

  Object.keys(chatPeers).forEach(pid => {
    if (chatPeers[pid].pc) chatPeers[pid].pc.close();
    if (chatPeers[pid].dataChannel) chatPeers[pid].dataChannel.close();
  });
  chatPeers = {};
  chatWinId = null;
}

async function pollChatSignals() {
  if (chatWinId === null) return;
  try {
    const res = await fetch('/api/signal?room=' + chatRoom + '&peerId=' + chatPeerId);
    const data = await res.json();

    // Connect to new peers
    data.peers.forEach(pid => {
      if (pid !== chatPeerId && !chatPeers[pid]) {
        initiateChatConnection(pid);
      }
    });

    // Handle signals
    data.signals.forEach(sig => {
      handleChatSignal(sig.from, sig.signal);
    });

    // Clean up disconnected peers
    Object.keys(chatPeers).forEach(pid => {
      if (!data.peers.includes(pid)) {
        removeChatPeer(pid);
      }
    });

    updateChatUsers();
  } catch (e) {}
}

function createChatPeerConnection(remotePeerId, isInitiator) {
  const pc = new RTCPeerConnection({
    iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
  });

  chatPeers[remotePeerId] = { pc, dataChannel: null, connected: false, name: remotePeerId.substr(0, 8), iceCandidateQueue: [] };

  if (isInitiator) {
    const dc = pc.createDataChannel('chat');
    setupChatDataChannel(dc, remotePeerId);
    chatPeers[remotePeerId].dataChannel = dc;
  } else {
    pc.ondatachannel = (e) => {
      setupChatDataChannel(e.channel, remotePeerId);
      chatPeers[remotePeerId].dataChannel = e.channel;
    };
  }

  pc.onicecandidate = (e) => {
    if (e.candidate) {
      sendChatSignal(remotePeerId, { type: 'ice', candidate: e.candidate });
    }
  };

  pc.onconnectionstatechange = () => {
    if (pc.connectionState === 'connected') {
      chatPeers[remotePeerId].connected = true;
      addChatMessage('', remotePeerId.substr(0, 8) + ' joined', true);
      updateChatUsers();
    } else if (pc.connectionState === 'disconnected' || pc.connectionState === 'failed') {
      removeChatPeer(remotePeerId);
    }
  };

  return pc;
}

function setupChatDataChannel(dc, peerId) {
  dc.onopen = () => {
    dc.send(JSON.stringify({ type: 'name', name: chatName }));
  };
  dc.onmessage = (e) => {
    try {
      const data = JSON.parse(e.data);
      if (data.type === 'chat') {
        addChatMessage(data.name || peerId.substr(0, 8), data.text);
      } else if (data.type === 'name') {
        chatPeers[peerId].name = data.name;
        updateChatUsers();
      }
    } catch (e) {}
  };
}

function removeChatPeer(peerId) {
  const peer = chatPeers[peerId];
  if (peer) {
    if (peer.pc) peer.pc.close();
    delete chatPeers[peerId];
    addChatMessage('', (peer.name || peerId.substr(0, 8)) + ' left', true);
    updateChatUsers();
  }
}

async function sendChatSignal(to, signal) {
  await fetch('/api/signal', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ action: 'signal', room: chatRoom, peerId: chatPeerId, to, signal })
  });
}

async function handleChatSignal(from, signal) {
  if (signal.type === 'offer') {
    // Handle glare (both peers sent offers) using polite peer pattern
    // The peer with the higher ID is "impolite" and ignores incoming offers if they already sent one
    const existingPeer = chatPeers[from];
    if (existingPeer && existingPeer.pc) {
      const isPolite = chatPeerId < from; // Lower ID is polite
      const isStable = existingPeer.pc.signalingState === 'stable';
      const hasLocalOffer = existingPeer.pc.signalingState === 'have-local-offer';

      if (hasLocalOffer && !isPolite) {
        // Impolite peer ignores incoming offer if we already sent one
        console.log('Ignoring offer due to glare (impolite peer)');
        return;
      }
      // Polite peer or stable state - close existing and accept new offer
      existingPeer.pc.close();
      delete chatPeers[from];
    }

    const pc = createChatPeerConnection(from, false);
    await pc.setRemoteDescription(new RTCSessionDescription(signal.sdp));
    await processIceCandidateQueue(from);
    const answer = await pc.createAnswer();
    await pc.setLocalDescription(answer);
    sendChatSignal(from, { type: 'answer', sdp: pc.localDescription });
  } else if (signal.type === 'answer') {
    const peer = chatPeers[from];
    if (peer && peer.pc && peer.pc.signalingState === 'have-local-offer') {
      await peer.pc.setRemoteDescription(new RTCSessionDescription(signal.sdp));
      await processIceCandidateQueue(from);
    }
  } else if (signal.type === 'ice') {
    const peer = chatPeers[from];
    if (peer && peer.pc) {
      if (peer.pc.remoteDescription) {
        try {
          await peer.pc.addIceCandidate(new RTCIceCandidate(signal.candidate));
        } catch (e) {
          // Ignore errors - may happen during renegotiation
        }
      } else {
        // Queue the candidate for later
        peer.iceCandidateQueue = peer.iceCandidateQueue || [];
        peer.iceCandidateQueue.push(signal.candidate);
      }
    }
  }
}

// Process queued ICE candidates after remote description is set
async function processIceCandidateQueue(peerId) {
  const peer = chatPeers[peerId];
  if (peer && peer.iceCandidateQueue && peer.pc && peer.pc.remoteDescription) {
    for (const candidate of peer.iceCandidateQueue) {
      try {
        await peer.pc.addIceCandidate(new RTCIceCandidate(candidate));
      } catch (e) {}
    }
    peer.iceCandidateQueue = [];
  }
}

async function initiateChatConnection(remotePeerId) {
  const pc = createChatPeerConnection(remotePeerId, true);
  const offer = await pc.createOffer();
  await pc.setLocalDescription(offer);
  sendChatSignal(remotePeerId, { type: 'offer', sdp: pc.localDescription });
}

function addChatMessage(name, text, isSystem = false) {
  // Auto-open chat when receiving a message (but not system messages like join/leave)
  if (chatWinId === null) {
    if (!isSystem) {
      openChat();
    } else {
      return;
    }
  }
  const container = document.getElementById('chat-messages-' + chatWinId);
  if (!container) return;

  const div = document.createElement('div');
  div.className = 'chat-msg';
  const time = new Date().toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' });
  if (isSystem) {
    div.innerHTML = '<span class="time">' + time + '</span> <span style="color:#888;">' + escapeHtml(text) + '</span>';
  } else {
    div.innerHTML = '<span class="name">' + escapeHtml(name) + '</span> <span class="time">' + time + '</span><div>' + escapeHtml(text) + '</div>';
  }
  container.appendChild(div);
  container.scrollTop = container.scrollHeight;
}

function updateChatUsers() {
  if (chatWinId === null) return;
  const usersEl = document.getElementById('online-users-' + chatWinId);
  if (!usersEl) return;

  const users = [chatName + ' (you)'];
  Object.values(chatPeers).forEach(peer => {
    if (peer.connected) users.push(peer.name);
  });

  usersEl.innerHTML = users.map(u =>
    '<div class="user-item"><div class="user-dot"></div> ' + escapeHtml(u) + '</div>'
  ).join('');
}

function sendChatP2P(id) {
  const input = document.getElementById('chat-input-' + id);
  const text = input.value.trim();
  if (!text) return;

  addChatMessage(chatName, text);

  Object.values(chatPeers).forEach(peer => {
    if (peer.dataChannel && peer.dataChannel.readyState === 'open') {
      peer.dataChannel.send(JSON.stringify({ type: 'chat', name: chatName, text }));
    }
  });

  input.value = '';
}

// ==================== WEBCAM ====================
function openWebcam() {
  createWindow({
    title: 'ALGO Webcam',
    stateKey: 'ALGO Webcam',
    icon: 'üìπ',
    width: 700, height: 500,
    content: '<iframe src="/algo-webcam:dolphin42" style="width:100%;height:100%;border:none;"></iframe>'
  });
}

// ==================== CHIME SYNTHESIZER ====================
let audioCtx = null;

function getAudioContext() {
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  if (audioCtx.state === 'suspended') audioCtx.resume();
  return audioCtx;
}

// Windows-style sound effects
function playChime(type) {
  const ctx = getAudioContext();
  const now = ctx.currentTime;

  const presets = {
    startup: [
      { freq: 523.25, start: 0, dur: 0.3, vol: 0.4 },      // C5
      { freq: 659.25, start: 0.15, dur: 0.3, vol: 0.4 },   // E5
      { freq: 783.99, start: 0.3, dur: 0.5, vol: 0.5 },    // G5
      { freq: 1046.50, start: 0.45, dur: 0.6, vol: 0.4 }   // C6
    ],
    error: [
      { freq: 440, start: 0, dur: 0.15, vol: 0.5 },
      { freq: 349.23, start: 0.12, dur: 0.2, vol: 0.5 }
    ],
    notify: [
      { freq: 880, start: 0, dur: 0.1, vol: 0.3 },
      { freq: 1108.73, start: 0.08, dur: 0.15, vol: 0.3 }
    ],
    warning: [
      { freq: 440, start: 0, dur: 0.2, vol: 0.4 },
      { freq: 440, start: 0.25, dur: 0.2, vol: 0.4 }
    ],
    success: [
      { freq: 523.25, start: 0, dur: 0.15, vol: 0.4 },
      { freq: 659.25, start: 0.1, dur: 0.15, vol: 0.4 },
      { freq: 783.99, start: 0.2, dur: 0.25, vol: 0.5 }
    ],
    click: [
      { freq: 1000, start: 0, dur: 0.03, vol: 0.2, wave: 'square' }
    ],
    shutdown: [
      { freq: 783.99, start: 0, dur: 0.25, vol: 0.4 },
      { freq: 659.25, start: 0.2, dur: 0.25, vol: 0.4 },
      { freq: 523.25, start: 0.4, dur: 0.4, vol: 0.4 },
      { freq: 392.00, start: 0.6, dur: 0.5, vol: 0.3 }
    ],
    maximize: [
      { freq: 600, start: 0, dur: 0.08, vol: 0.2 },
      { freq: 800, start: 0.06, dur: 0.1, vol: 0.25 }
    ],
    minimize: [
      { freq: 800, start: 0, dur: 0.08, vol: 0.2 },
      { freq: 600, start: 0.06, dur: 0.1, vol: 0.2 }
    ]
  };

  const notes = presets[type] || presets.notify;

  notes.forEach(note => {
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();

    osc.type = note.wave || 'sine';
    osc.frequency.setValueAtTime(note.freq, now + note.start);

    gain.gain.setValueAtTime(0, now + note.start);
    gain.gain.linearRampToValueAtTime(note.vol, now + note.start + 0.01);
    gain.gain.exponentialRampToValueAtTime(0.01, now + note.start + note.dur);

    osc.connect(gain);
    gain.connect(ctx.destination);

    osc.start(now + note.start);
    osc.stop(now + note.start + note.dur + 0.1);
  });
}

// ==================== EXTERNAL APP LOADER ====================
// Apps can be loaded from separate .js artifact files
// They self-register with the OS via window.algoRegisterApp()

window.algoApps = window.algoApps || {};

window.algoRegisterApp = function(appDef) {
  if (!appDef.id || !appDef.name || !appDef.open) {
    console.error('App registration requires id, name, and open function');
    return false;
  }

  window.algoApps[appDef.id] = appDef;

  // Add CSS if provided
  if (appDef.css) {
    const style = document.createElement('style');
    style.id = 'app-style-' + appDef.id;
    style.textContent = appDef.css;
    document.head.appendChild(style);
  }

  // Add to start menu if requested
  if (appDef.startMenu !== false) {
    const startItems = document.querySelector('.start-items');
    if (startItems) {
      // Find insertion point (before separator or at end)
      const sep = startItems.querySelector('.start-separator:last-of-type');
      const item = document.createElement('div');
      item.className = 'start-item';
      item.onclick = () => { hideStartMenu(); appDef.open(); };
      item.innerHTML = `<span>${appDef.icon || 'üì¶'}</span> ${appDef.name}`;
      if (sep) {
        sep.parentNode.insertBefore(item, sep);
      } else {
        startItems.appendChild(item);
      }
    }
  }

  // Call onInit if provided (for apps that need initialization)
  if (typeof appDef.onInit === 'function') {
    try {
      appDef.onInit();
    } catch (e) {
      console.error('Error in app onInit:', appDef.name, e);
    }
  }

  console.log('ALGO: Registered app:', appDef.name);
  return true;
};

// Load an app from a saved .js file
window.algoLoadApp = function(fileName) {
  const file = savedFiles.find(f => f.name === fileName);
  if (!file) {
    algoSpeak('App file not found: ' + fileName);
    return false;
  }

  try {
    // Execute the app code
    const script = document.createElement('script');
    script.textContent = file.content;
    document.head.appendChild(script);
    return true;
  } catch (e) {
    algoSpeak('Error loading app: ' + e.message);
    return false;
  }
};

// Distribution apps - these get auto-installed if not present
const ALGO_DISTRIBUTION_APPS = [
  { name: 'angelwave-vox.app.js', url: '/raw/1768947353000' },
  { name: 'windchime-dad.app.js', url: '/raw/1768947616000' },
  { name: 'deepwave-gold.app.js', url: '/raw/1768947971000' },
  { name: 'voyeur-js.app.js', url: '/raw/1768948321000' },
  { name: 'photobooth.app.js', url: '/raw/1768949272000' },
  { name: 'ticket-manager.app.js', url: '/raw/1768950502000' },
  { name: 'todo-manager.app.js', url: '/raw/1768951728000' },
  { name: 'calendar.app.js', url: '/raw/1768952664000' },
  { name: 'music-player.app.js', url: '/raw/1768953096000' },
  { name: 'video-player.app.js', url: '/raw/1768953343000' },
  { name: 'shade-station.app.js', url: '/raw/1768953500000' },
  { name: 'box-editor.app.js', url: '/raw/1768953600000' }
];

// Auto-load apps from saved files on startup
async function algoAutoLoadApps() {
  // First, check for and install distribution apps
  for (const distApp of ALGO_DISTRIBUTION_APPS) {
    if (!savedFiles.find(f => f.name === distApp.name)) {
      try {
        const resp = await fetch(distApp.url);
        if (resp.ok) {
          const content = await resp.text();
          savedFiles.push({ name: distApp.name, content, type: 'application/javascript', created: Date.now() });
          console.log('ALGO: Installed distribution app:', distApp.name);
        }
      } catch (e) {
        console.error('Failed to fetch distribution app:', distApp.name, e);
      }
    }
  }

  // Now load all .app.js files
  const appFiles = savedFiles.filter(f => f.name.endsWith('.app.js'));
  appFiles.forEach(f => {
    try {
      const script = document.createElement('script');
      script.textContent = f.content;
      document.head.appendChild(script);
    } catch (e) {
      console.error('Failed to load app:', f.name, e);
    }
  });

  // Update desktop icons to show new apps
  if (appFiles.length > 0) createDesktopIcons();
}

// ==================== STICKY NOTES ====================
function createStickyNote(x, y, text, color) {
  hideStartMenu();
  const id = stickyNoteId++;
  const note = {
    id: id,
    x: x || 200 + (id % 5) * 30,
    y: y || 100 + (id % 5) * 30,
    text: text || '',
    color: color || 'yellow'
  };
  stickyNotes.push(note);
  renderStickyNote(note);
  saveStickyNotes();
}

function renderStickyNote(note) {
  const el = document.createElement('div');
  el.className = 'sticky-note' + (note.color !== 'yellow' ? ' ' + note.color : '');
  el.id = 'sticky-' + note.id;
  el.style.left = note.x + 'px';
  el.style.top = note.y + 'px';
  el.innerHTML =
    '<div class="sticky-note-header" data-stickyid="' + note.id + '">' +
      '<span>üìå Note</span>' +
      '<span class="close-btn" onclick="deleteStickyNote(' + note.id + ')">√ó</span>' +
    '</div>' +
    '<div class="sticky-note-content">' +
      '<textarea id="sticky-text-' + note.id + '" placeholder="Type your note...">' + escapeHtml(note.text) + '</textarea>' +
    '</div>' +
    '<div class="sticky-note-colors">' +
      '<span class="c-yellow" onclick="setStickyColor(' + note.id + ',\'yellow\')"></span>' +
      '<span class="c-pink" onclick="setStickyColor(' + note.id + ',\'pink\')"></span>' +
      '<span class="c-blue" onclick="setStickyColor(' + note.id + ',\'blue\')"></span>' +
      '<span class="c-green" onclick="setStickyColor(' + note.id + ',\'green\')"></span>' +
    '</div>';

  // Save text on change
  el.querySelector('textarea').addEventListener('input', function() {
    const n = stickyNotes.find(s => s.id === note.id);
    if (n) { n.text = this.value; saveStickyNotes(); }
  });

  // Drag handling
  el.querySelector('.sticky-note-header').addEventListener('mousedown', function(e) {
    if (e.target.classList.contains('close-btn')) return;
    dragStickyNote = note;
    stickyDragOffset.x = e.clientX - el.offsetLeft;
    stickyDragOffset.y = e.clientY - el.offsetTop;
    e.preventDefault();
  });

  document.getElementById('desktop').appendChild(el);
}

function setStickyColor(id, color) {
  const note = stickyNotes.find(s => s.id === id);
  if (!note) return;
  note.color = color;
  const el = document.getElementById('sticky-' + id);
  if (el) {
    el.className = 'sticky-note' + (color !== 'yellow' ? ' ' + color : '');
  }
  saveStickyNotes();
}

function deleteStickyNote(id) {
  stickyNotes = stickyNotes.filter(s => s.id !== id);
  const el = document.getElementById('sticky-' + id);
  if (el) el.remove();
  saveStickyNotes();
}

function saveStickyNotes() {
  localStorage.setItem('algo-sticky-notes', JSON.stringify(stickyNotes));
}

function loadStickyNotes() {
  try {
    const saved = JSON.parse(localStorage.getItem('algo-sticky-notes') || '[]');
    saved.forEach(note => {
      note.id = stickyNoteId++;
      stickyNotes.push(note);
      renderStickyNote(note);
    });
  } catch(e) {}
}

// ==================== DOCUMENTATION ====================
function openDocumentation() {
  hideStartMenu();
  createWindow({
    title: 'Documentation',
    stateKey: 'Documentation',
    icon: 'üìï',
    width: 400, height: 350,
    content: '<div class="folder-content">' +
      '<div class="folder-item" ondblclick="openDocViewer(\'top-secret\')">' +
        '<div class="icon-img" style="color:#8B0000;">üìï</div>' +
        '<span>Top Secret</span>' +
      '</div>' +
      '<div class="folder-item" ondblclick="openDocViewer(\'artifact-guide\')">' +
        '<div class="icon-img" style="color:#8B0000;">üìï</div>' +
        '<span>Artifact Guide</span>' +
      '</div>' +
      '<div class="folder-item" ondblclick="openDocViewer(\'secret-ai\')">' +
        '<div class="icon-img" style="color:#8B0000;">üìï</div>' +
        '<span>AI/LLM Guide</span>' +
      '</div>' +
    '</div>'
  });
}

function openDocViewer(docId) {
  const url = DOC_URLS[docId] || '/';
  createWindow({
    title: docId + ' - Documentation',
    stateKey: 'Doc:' + docId,
    icon: 'üìï',
    width: 600, height: 450,
    content: '<iframe src="' + url + '" style="width:100%;height:100%;border:none;"></iframe>'
  });
}

function openHelp() {
  hideStartMenu();
  createWindow({
    title: 'ALGO OS Help',
    stateKey: 'ALGO OS Help',
    icon: 'üìô',
    width: 600, height: 450,
    content: '<div class="chm-viewer">' +
      '<div class="chm-sidebar">' +
        Object.entries(HELP_CONTENT).map(function(e) {
          return '<div class="chm-tree-item" onclick="showHelpTopic(\'' + e[0] + '\',this)"><span class="book-icon">üìñ</span> ' + e[1].title + '</div>';
        }).join('') +
      '</div>' +
      '<div class="chm-content" id="help-content">' + HELP_CONTENT.welcome.content + '</div>' +
    '</div>'
  });
}

function showHelpTopic(key, el) {
  document.querySelectorAll('.chm-tree-item').forEach(e => e.classList.remove('active'));
  if (el) el.classList.add('active');
  const helpContent = document.getElementById('help-content');
  if (helpContent && HELP_CONTENT[key]) {
    helpContent.innerHTML = HELP_CONTENT[key].content;
  }
}

// ==================== PROGRAMS ====================
function runProgram(prog) {
  // Handle IDE-installed apps with code
  if (prog.code) {
    try {
      const fullCode = ALGO_API_CODE + '\n' + prog.code;
      // Execute in global scope using indirect eval
      (0, eval)(fullCode);
    } catch (e) {
      algoSpeak('Error running ' + prog.name + ': ' + e.message);
    }
    return;
  }

  // Handle URL-based apps (artifacts)
  createWindow({
    title: prog.name,
    stateKey: 'App:' + prog.id,
    icon: prog.icon || 'üéÆ',
    width: 600, height: 500,
    content: '<iframe src="' + prog.url + '" style="width:100%;height:100%;border:none;"></iframe>'
  });
}

function updateProgramsMenu() {
  const el = document.getElementById('installed-programs-menu');
  if (el) {
    el.innerHTML = installedPrograms.map(p =>
      '<div class="start-item" onclick="runProgram(installedPrograms.find(x=>x.id===\'' + p.id + '\'));hideStartMenu()"><span>' + (p.icon||'üéÆ') + '</span> ' + p.name + '</div>'
    ).join('');
  }
}

function createDesktopShortcut(artifactName) {
  // Check if shortcut already exists
  if (installedPrograms.some(p => p.id === artifactName)) {
    return;
  }

  // Add to installed programs
  installedPrograms.push({
    id: artifactName,
    name: artifactName,
    url: '/' + artifactName,
    icon: 'üîó'
  });

  saveState();
  createDesktopIcons();
  updateProgramsMenu();
}

// ==================== CONTEXT MENU ====================
function showContextMenu(e) {
  e.preventDefault();
  const menu = document.getElementById('context-menu');
  const icon = e.target.closest('.desktop-icon');
  contextTarget = { icon: icon };

  let html = '';
  if (icon) {
    const type = icon.dataset.iconType;
    const iconId = icon.dataset.iconId || icon.id;
    html = '<div class="ctx-item" onclick="ctxOpen()">Open</div>';

    // Find file info for "Open With" menu
    let fileInfo = null;
    if (iconId && iconId.startsWith('file-')) {
      const idx = parseInt(iconId.replace('file-',''));
      fileInfo = savedFiles[idx];
    } else if (iconId && (iconId.startsWith('shader-') || iconId.startsWith('box-'))) {
      fileInfo = desktopIcons.find(i => i.id === iconId);
    }

    if (fileInfo && fileInfo.name) {
      const handlers = getFileHandlers(fileInfo.name, fileInfo.content);
      if (handlers.length > 0) {
        const ext = fileInfo.name.split('.').pop().toLowerCase();
        const defaultId = defaultFileHandlers[ext];
        html += '<div class="ctx-item has-submenu">Open With<div class="ctx-submenu">';
        handlers.forEach((h, idx) => {
          const isDefault = h.appId === defaultId;
          const checkmark = isDefault ? '‚úì ' : '&nbsp;&nbsp;&nbsp;';
          html += '<div class="ctx-item" onclick="ctxOpenWith(' + idx + ')">' + checkmark + h.icon + ' ' + h.name + '</div>';
        });
        if (handlers.length > 1) {
          html += '<div class="ctx-sep"></div>';
          handlers.forEach((h, idx) => {
            html += '<div class="ctx-item" onclick="ctxSetDefaultHandler(' + idx + ')">Set ' + h.name + ' as Default</div>';
          });
        }
        html += '</div></div>';
        contextTarget.handlers = handlers;
        contextTarget.fileInfo = fileInfo;
      }

      // Add "Set as Background" for images
      if (fileInfo.type === 'image') {
        const imageFiles = savedFiles.filter(f => f.type === 'image');
        const imgIdx = imageFiles.indexOf(fileInfo);
        if (imgIdx >= 0) {
          html += '<div class="ctx-item" onclick="setImageAsBackground(' + imgIdx + ')">Set as Background</div>';
        }
      }
    }

    if (type === 'openFile' || type === 'runProgram' || type === 'openRoomFolder') {
      html += '<div class="ctx-sep"></div><div class="ctx-item" onclick="ctxDelete()">Delete</div>';
    }
    // Add "Reset Position" option if icon has been moved
    if (iconPositions[iconId]) {
      html += '<div class="ctx-sep"></div><div class="ctx-item" onclick="ctxResetIconPosition()">Reset Position</div>';
    }
  } else {
    html = '<div class="ctx-item" id="ctx-paste-item" onclick="ctxPaste()">Paste</div>' +
           '<div class="ctx-sep"></div>' +
           '<div class="ctx-item" onclick="openNotepad()">New Text File</div>' +
           '<div class="ctx-item" onclick="openJSIDE()">New JavaScript</div>' +
           '<div class="ctx-item" onclick="createRoomFolder()">New Room Folder</div>' +
           '<div class="ctx-item" onclick="createStickyNote(' + e.clientX + ',' + e.clientY + ')">New Sticky Note</div>' +
           '<div class="ctx-sep"></div>' +
           '<div class="ctx-item" onclick="location.reload()">Refresh</div>';
    // Try to read clipboard and show preview
    setTimeout(updatePastePreview, 0);
  }

  menu.innerHTML = html;
  menu.style.left = e.clientX + 'px';
  menu.style.top = e.clientY + 'px';
  menu.classList.add('visible');

  // Adjust position if menu extends beyond viewport
  const rect = menu.getBoundingClientRect();
  const viewWidth = window.innerWidth;
  const viewHeight = window.innerHeight;

  if (rect.right > viewWidth) {
    menu.style.left = Math.max(0, viewWidth - rect.width) + 'px';
  }
  if (rect.bottom > viewHeight) {
    menu.style.top = Math.max(0, viewHeight - rect.height) + 'px';
  }
}

function ctxOpen() {
  if (contextTarget.icon && contextTarget.icon.ondblclick) contextTarget.icon.ondblclick();
  hideContextMenu();
}

function ctxOpenWith(idx) {
  if (contextTarget.handlers && contextTarget.handlers[idx] && contextTarget.fileInfo) {
    const handler = contextTarget.handlers[idx];
    const file = contextTarget.fileInfo;
    handler.handler(file.content, file.name, file);
  }
  hideContextMenu();
}

function ctxSetDefaultHandler(idx) {
  if (contextTarget.handlers && contextTarget.handlers[idx] && contextTarget.fileInfo) {
    const handler = contextTarget.handlers[idx];
    const ext = contextTarget.fileInfo.name.split('.').pop().toLowerCase();
    setDefaultHandler(ext, handler.appId);
    algoSpeak(handler.name + ' is now default for .' + ext + ' files');
  }
  hideContextMenu();
}

function ctxDelete() {
  const icon = contextTarget.icon;
  if (!icon) return;
  const id = icon.dataset.iconId;
  if (id.startsWith('file-')) {
    const idx = parseInt(id.replace('file-',''));
    savedFiles.splice(idx, 1);
  } else if (id.startsWith('prog-')) {
    const pid = id.replace('prog-','');
    installedPrograms = installedPrograms.filter(p => p.id !== pid);
    updateProgramsMenu();
  } else if (id.startsWith('room-')) {
    const roomName = id.replace('room-','');
    roomFolders = roomFolders.filter(r => r.name !== roomName);
    savedFiles = savedFiles.filter(f => f.room !== roomName);
  }
  saveState();
  createDesktopIcons();
  hideContextMenu();
}

function ctxResetIconPosition() {
  const icon = contextTarget.icon;
  if (!icon) return;
  const iconId = icon.dataset.iconId;
  if (iconPositions[iconId]) {
    delete iconPositions[iconId];
    localStorage.setItem('algo-icon-positions', JSON.stringify(iconPositions));
    // Reset to default position
    const defaultX = icon.dataset.defaultX || '20';
    const defaultY = icon.dataset.defaultY || '20';
    icon.style.left = defaultX + 'px';
    icon.style.top = defaultY + 'px';
  }
  hideContextMenu();
}

async function updatePastePreview() {
  const pasteItem = document.getElementById('ctx-paste-item');
  if (!pasteItem) return;

  try {
    // Try to read clipboard (requires permission)
    const clipboardItems = await navigator.clipboard.read();
    for (const item of clipboardItems) {
      // Check for images first
      if (item.types.includes('image/png') || item.types.includes('image/jpeg')) {
        const filename = generatePasteFilename('img', '.png');
        pasteItem.textContent = 'Paste ' + filename;
        pasteItem.dataset.clipboardType = 'image';
        return;
      }
      // Check for text
      if (item.types.includes('text/plain')) {
        const blob = await item.getType('text/plain');
        const text = await blob.text();
        if (text.length > 0) {
          // Check if it's a URL/artifact link
          if (text.match(/laserbarf\.com\/([a-z0-9-]+)/i)) {
            const name = text.match(/laserbarf\.com\/([a-z0-9-]+)/i)[1];
            pasteItem.textContent = 'Paste shortcut: ' + name;
          } else {
            const preview = text.substring(0, 20) + (text.length > 20 ? '...' : '');
            const filename = generatePasteFilename('note', '.txt');
            pasteItem.textContent = 'Paste "' + preview + '"';
          }
          pasteItem.dataset.clipboardType = 'text';
          return;
        }
      }
    }
  } catch (e) {
    // Clipboard API not available or permission denied - keep default "Paste"
  }
}

function ctxPaste() {
  hideContextMenu();
  // Open a paste dialog - clipboard API is too restricted in browsers
  openPasteDialog();
}

function openPasteDialog() {
  createWindow({
    title: 'Paste',
    stateKey: 'Paste Dialog',
    icon: 'üìã',
    width: 400, height: 300,
    content: '<div style="padding:15px;height:100%;display:flex;flex-direction:column;">' +
      '<p style="margin-bottom:10px;">Paste your content below (Ctrl+V), then click Save:</p>' +
      '<div id="paste-drop-zone" style="flex:1;border:2px dashed #999;margin-bottom:10px;display:flex;align-items:center;justify-content:center;background:#fff;position:relative;min-height:120px;">' +
        '<textarea id="paste-textarea" style="position:absolute;top:0;left:0;width:100%;height:100%;border:none;resize:none;padding:8px;font-family:monospace;font-size:12px;" placeholder="Click here and press Ctrl+V to paste text or images..."></textarea>' +
        '<img id="paste-preview" style="max-width:100%;max-height:100%;display:none;position:absolute;">' +
      '</div>' +
      '<div style="display:flex;gap:8px;justify-content:flex-end;">' +
        '<button onclick="closePasteDialog()">Cancel</button>' +
        '<button onclick="savePastedContent()">Save to Desktop</button>' +
      '</div>' +
    '</div>'
  });

  // Set up paste handler for the textarea
  setTimeout(() => {
    const textarea = document.getElementById('paste-textarea');
    const preview = document.getElementById('paste-preview');
    if (textarea) {
      textarea.focus();
      textarea.addEventListener('paste', function(e) {
        const items = (e.clipboardData || window.clipboardData).items;
        for (let i = 0; i < items.length; i++) {
          if (items[i].type.indexOf('image') !== -1) {
            e.preventDefault();
            const blob = items[i].getAsFile();
            const reader = new FileReader();
            reader.onload = function(event) {
              textarea.style.display = 'none';
              preview.src = event.target.result;
              preview.style.display = 'block';
              preview.dataset.imageData = event.target.result;
            };
            reader.readAsDataURL(blob);
            return;
          }
        }
      });
    }
  }, 100);
}

function savePastedContent() {
  const textarea = document.getElementById('paste-textarea');
  const preview = document.getElementById('paste-preview');

  if (preview && preview.dataset.imageData) {
    // Save image
    const filename = generatePasteFilename('img', '.png');
    savedFiles.push({ name: filename, content: preview.dataset.imageData, type: 'image' });
    saveState();
    createDesktopIcons();
    algoSpeak('Saved ' + filename);
    closePasteDialog();
  } else if (textarea && textarea.value.trim()) {
    // Save text
    const text = textarea.value.trim();
    if (text.match(/laserbarf\.com\/([a-z0-9-]+)/i)) {
      const artifactName = text.match(/laserbarf\.com\/([a-z0-9-]+)/i)[1];
      createDesktopShortcut(artifactName);
      algoSpeak('Added shortcut: ' + artifactName);
    } else {
      const filename = generatePasteFilename('note', '.txt');
      savedFiles.push({ name: filename, content: text, type: 'text' });
      saveState();
      createDesktopIcons();
      algoSpeak('Saved ' + filename);
    }
    closePasteDialog();
  } else {
    algoSpeak('Nothing to save');
  }
}

function closePasteDialog() {
  const win = windows.find(w => w.title === 'Paste');
  if (win) closeWindow(win.id);
}

// ==================== DRAG ====================
function startDrag(e) {
  // Check for window resize handle
  const resizeHandle = e.target.closest('.window-resize');
  if (resizeHandle) {
    const id = parseInt(resizeHandle.dataset.winid);
    resizeWin = windows.find(w => w.id === id);
    if (resizeWin) {
      const el = document.getElementById('win-' + id);
      resizeStart.x = e.clientX;
      resizeStart.y = e.clientY;
      resizeStart.w = el.offsetWidth;
      resizeStart.h = el.offsetHeight;
    }
    return;
  }

  const titlebar = e.target.closest('.window-titlebar');
  if (titlebar && !e.target.classList.contains('window-btn')) {
    const id = parseInt(titlebar.dataset.winid);
    dragWin = windows.find(w => w.id === id);
    if (dragWin) {
      const el = document.getElementById('win-' + id);
      dragOffset.x = e.clientX - el.offsetLeft;
      dragOffset.y = e.clientY - el.offsetTop;
    }
    return;
  }
  // Desktop icon dragging
  const icon = e.target.closest('.desktop-icon');
  if (icon && !dragWin) {
    dragIcon = icon;
    iconDragOffset.x = e.clientX - icon.offsetLeft;
    iconDragOffset.y = e.clientY - icon.offsetTop;
    icon.classList.add('selected');
    document.querySelectorAll('.desktop-icon').forEach(i => {
      if (i !== icon) i.classList.remove('selected');
    });
  }
}

function onDrag(e) {
  if (resizeWin) {
    const el = document.getElementById('win-' + resizeWin.id);
    const dx = e.clientX - resizeStart.x;
    const dy = e.clientY - resizeStart.y;
    const newW = Math.max(resizeWin.minWidth || 150, resizeStart.w + dx);
    const newH = Math.max(resizeWin.minHeight || 100, resizeStart.h + dy);
    resizeWin.width = newW;
    resizeWin.height = newH;
    el.style.width = newW + 'px';
    el.style.height = newH + 'px';
  }
  if (dragWin) {
    const el = document.getElementById('win-' + dragWin.id);
    dragWin.x = e.clientX - dragOffset.x;
    dragWin.y = e.clientY - dragOffset.y;
    el.style.left = dragWin.x + 'px';
    el.style.top = dragWin.y + 'px';
  }
  if (dragStickyNote) {
    const el = document.getElementById('sticky-' + dragStickyNote.id);
    dragStickyNote.x = e.clientX - stickyDragOffset.x;
    dragStickyNote.y = e.clientY - stickyDragOffset.y;
    el.style.left = dragStickyNote.x + 'px';
    el.style.top = dragStickyNote.y + 'px';
  }
  if (dragIcon) {
    let newX = e.clientX - iconDragOffset.x;
    let newY = e.clientY - iconDragOffset.y;
    // Keep icon on screen
    const desktop = document.getElementById('desktop');
    const maxX = desktop.clientWidth - dragIcon.offsetWidth;
    const maxY = desktop.clientHeight - dragIcon.offsetHeight - 40; // Account for taskbar
    newX = Math.max(0, Math.min(newX, maxX));
    newY = Math.max(0, Math.min(newY, maxY));
    dragIcon.style.left = newX + 'px';
    dragIcon.style.top = newY + 'px';
  }
}

function endDrag() {
  if (resizeWin) {
    // Call onResize callback if defined
    if (resizeWin.onResize) {
      resizeWin.onResize(resizeWin.width, resizeWin.height);
    }
    // Save state
    const stateKey = resizeWin.stateKey || resizeWin.title;
    windowStates[stateKey] = { x: resizeWin.x, y: resizeWin.y, width: resizeWin.width, height: resizeWin.height };
    saveState();
  }
  if (dragWin) {
    const stateKey = dragWin.stateKey || dragWin.title;
    windowStates[stateKey] = { x: dragWin.x, y: dragWin.y, width: dragWin.width, height: dragWin.height };
    saveState();
  }
  if (dragStickyNote) {
    saveStickyNotes();
  }
  if (dragIcon) {
    const iconId = dragIcon.dataset.iconId;
    iconPositions[iconId] = {
      x: parseInt(dragIcon.style.left),
      y: parseInt(dragIcon.style.top)
    };
    localStorage.setItem('algo-icon-positions', JSON.stringify(iconPositions));
  }
  resizeWin = null;
  dragWin = null;
  dragStickyNote = null;
  dragIcon = null;
}

// ==================== MIDI EDITOR ====================
function openMidiEditor() {
  hideStartMenu();
  createWindow({
    title: 'MIDI Editor',
    stateKey: 'MIDI Editor',
    icon: 'üéπ',
    width: 800, height: 500,
    content: '<iframe src="/midi-editor" style="width:100%;height:100%;border:none;"></iframe>'
  });
}

// ==================== ALGO DIST ====================
function openAlgoDist() {
  hideStartMenu();
  createWindow({
    title: 'ALGO DIST',
    stateKey: 'ALGO DIST',
    icon: 'üì¶',
    width: 500, height: 500,
    content: '<div id="algo-dist-content">Loading...</div>'
  });
  setTimeout(initAlgoDist, 100);
}

function initAlgoDist() {
  var container = document.getElementById('algo-dist-content');
  if (!container) return;
  var ADMIN_KEY = 'dolphin42-admin';
  var currentItems = [];
  var availableArtifacts = [];

  container.innerHTML = '<style>' +
    '.dist-container { font-family: system-ui; padding: 10px; background: #f0f0f0; min-height: 380px; }' +
    '.dist-header { background: #000080; color: white; padding: 8px 12px; margin: -10px -10px 10px -10px; font-weight: bold; }' +
    '.dist-tabs { display: flex; gap: 2px; margin-bottom: 10px; }' +
    '.dist-tab { padding: 6px 12px; background: #c0c0c0; border: 2px outset #fff; cursor: pointer; }' +
    '.dist-tab.active { background: #fff; border-style: inset; }' +
    '.dist-panel { display: none; }' +
    '.dist-panel.active { display: block; }' +
    '.dist-list { background: white; border: 1px solid #808080; max-height: 180px; overflow-y: auto; }' +
    '.dist-item { padding: 6px 10px; border-bottom: 1px solid #e0e0e0; display: flex; justify-content: space-between; align-items: center; }' +
    '.dist-item:hover { background: #e8e8ff; }' +
    '.dist-item-name { font-weight: bold; }' +
    '.dist-item-type { color: #666; font-size: 11px; margin-left: 8px; }' +
    '.dist-btn { padding: 4px 12px; background: #c0c0c0; border: 2px outset #fff; cursor: pointer; font-size: 12px; }' +
    '.dist-btn:active { border-style: inset; }' +
    '.dist-btn.danger { background: #ffcccc; }' +
    '.dist-form { background: white; border: 1px solid #808080; padding: 10px; margin-top: 10px; }' +
    '.dist-form label { display: block; margin: 8px 0 4px; font-weight: bold; font-size: 12px; }' +
    '.dist-form input, .dist-form select, .dist-form textarea { width: 100%; padding: 4px; border: 1px solid #808080; box-sizing: border-box; }' +
    '.dist-form textarea { height: 80px; font-family: monospace; font-size: 11px; }' +
    '.dist-status { padding: 8px; margin-top: 10px; border: 1px solid; font-size: 12px; }' +
    '.dist-status.success { background: #d4ffd4; border-color: #0a0; }' +
    '.dist-status.error { background: #ffd4d4; border-color: #a00; }' +
    '.artifact-list { max-height: 120px; overflow-y: auto; background: white; border: 1px solid #808080; }' +
    '.artifact-item { padding: 4px 8px; cursor: pointer; font-size: 11px; }' +
    '.artifact-item:hover { background: #e8e8ff; }' +
    '</style>' +
    '<div class="dist-container">' +
      '<div class="dist-header">üì¶ ALGO DIST - Distribution Manager</div>' +
      '<div class="dist-tabs">' +
        '<div class="dist-tab active" id="dist-tab-current">Current Items</div>' +
        '<div class="dist-tab" id="dist-tab-add-doc">Add Document</div>' +
        '<div class="dist-tab" id="dist-tab-add-artifact">Add Artifact</div>' +
      '</div>' +
      '<div id="dist-panel-current" class="dist-panel active">' +
        '<p style="font-size:12px;color:#666;">Items on every ALGO OS desktop:</p>' +
        '<div id="dist-current-list" class="dist-list"><div style="padding:20px;color:#888;text-align:center;">Loading...</div></div>' +
      '</div>' +
      '<div id="dist-panel-add-doc" class="dist-panel">' +
        '<div class="dist-form">' +
          '<label>Document Name:</label>' +
          '<input type="text" id="dist-doc-name" placeholder="example.md">' +
          '<label>Icon:</label>' +
          '<input type="text" id="dist-doc-icon" value="üìÑ" style="width:50px;">' +
          '<label>Content:</label>' +
          '<textarea id="dist-doc-content" placeholder="# Document"></textarea>' +
          '<button class="dist-btn" id="dist-add-doc-btn" style="margin-top:10px;">Add Document</button>' +
        '</div>' +
      '</div>' +
      '<div id="dist-panel-add-artifact" class="dist-panel">' +
        '<div class="dist-form">' +
          '<label>Artifact Tag:</label>' +
          '<input type="text" id="dist-artifact-tag" placeholder="my-artifact">' +
          '<label>Recent artifacts:</label>' +
          '<div id="dist-artifact-list" class="artifact-list"><div style="padding:10px;color:#888;">Loading...</div></div>' +
          '<label>Display Name:</label>' +
          '<input type="text" id="dist-artifact-name" placeholder="(optional)">' +
          '<label>Icon:</label>' +
          '<input type="text" id="dist-artifact-icon" value="üéÆ" style="width:50px;">' +
          '<button class="dist-btn" id="dist-add-artifact-btn" style="margin-top:10px;">Add Artifact</button>' +
        '</div>' +
      '</div>' +
      '<div id="dist-status"></div>' +
    '</div>';

  // Tab switching
  ['current', 'add-doc', 'add-artifact'].forEach(function(name) {
    var tab = document.getElementById('dist-tab-' + name);
    if (tab) tab.onclick = function() {
      document.querySelectorAll('.dist-tab').forEach(function(t) { t.classList.remove('active'); });
      document.querySelectorAll('.dist-panel').forEach(function(p) { p.classList.remove('active'); });
      this.classList.add('active');
      document.getElementById('dist-panel-' + name).classList.add('active');
    };
  });

  function showStatus(msg, isError) {
    var el = document.getElementById('dist-status');
    if (el) {
      el.className = 'dist-status ' + (isError ? 'error' : 'success');
      el.textContent = msg;
      setTimeout(function() { if(el) el.textContent = ''; }, 5000);
    }
  }

  function loadCurrentItems() {
    fetch('/api/algo-desktop').then(function(r) { return r.json(); }).then(function(data) {
      currentItems = data.files || [];
      renderCurrentItems();
    }).catch(function(e) { showStatus('Failed to load: ' + e.message, true); });
  }

  function renderCurrentItems() {
    var el = document.getElementById('dist-current-list');
    if (!el) return;
    if (currentItems.length === 0) {
      el.innerHTML = '<div style="padding:20px;color:#888;text-align:center;">No global items</div>';
      return;
    }
    el.innerHTML = currentItems.map(function(item) {
      return '<div class="dist-item"><div><span class="dist-item-name">' + (item.icon || 'üìÑ') + ' ' + item.name +
        '</span><span class="dist-item-type">(' + (item.type || 'text') + ')</span></div>' +
        '<button class="dist-btn danger" data-name="' + item.name + '">Remove</button></div>';
    }).join('');
    el.querySelectorAll('.dist-btn.danger').forEach(function(btn) {
      btn.onclick = function() { removeItem(btn.dataset.name); };
    });
  }

  function loadArtifacts() {
    fetch('/api/artifacts/list?limit=20').then(function(r) { return r.json(); }).then(function(data) {
      availableArtifacts = data.artifacts || [];
      renderArtifactList();
    }).catch(function() {
      var el = document.getElementById('dist-artifact-list');
      if (el) el.innerHTML = '<div style="padding:10px;color:#a00;">Failed</div>';
    });
  }

  function renderArtifactList() {
    var el = document.getElementById('dist-artifact-list');
    if (!el) return;
    if (availableArtifacts.length === 0) {
      el.innerHTML = '<div style="padding:10px;color:#888;">No artifacts</div>';
      return;
    }
    el.innerHTML = availableArtifacts.map(function(a) {
      return '<div class="artifact-item" data-tag="' + a.tag + '" data-title="' + (a.title || '').replace(/"/g, '&quot;') + '">' +
        '<strong>' + a.tag + '</strong> - ' + a.title + '</div>';
    }).join('');
    el.querySelectorAll('.artifact-item').forEach(function(item) {
      item.onclick = function() {
        document.getElementById('dist-artifact-tag').value = item.dataset.tag;
        document.getElementById('dist-artifact-name').value = item.dataset.title;
      };
    });
  }

  document.getElementById('dist-add-doc-btn').onclick = function() {
    var name = document.getElementById('dist-doc-name').value.trim();
    var icon = document.getElementById('dist-doc-icon').value.trim();
    var content = document.getElementById('dist-doc-content').value;
    if (!name || !content) { showStatus('Name and content required', true); return; }
    fetch('/api/algo-desktop', {
      method: 'POST', headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ adminKey: ADMIN_KEY, action: 'add', name: name, content: content, type: 'text', icon: icon })
    }).then(function(r) { return r.json(); }).then(function(data) {
      if (data.success) {
        showStatus('Document added!', false);
        document.getElementById('dist-doc-name').value = '';
        document.getElementById('dist-doc-content').value = '';
        loadCurrentItems();
      } else { showStatus('Failed: ' + (data.error || 'Unknown'), true); }
    }).catch(function(e) { showStatus('Error: ' + e.message, true); });
  };

  document.getElementById('dist-add-artifact-btn').onclick = function() {
    var tag = document.getElementById('dist-artifact-tag').value.trim();
    var name = document.getElementById('dist-artifact-name').value.trim() || tag;
    var icon = document.getElementById('dist-artifact-icon').value.trim();
    if (!tag) { showStatus('Tag required', true); return; }
    showStatus('Fetching artifact...', false);
    fetch('/api/artifact?tag=' + encodeURIComponent(tag)).then(function(r) { return r.json(); }).then(function(artData) {
      if (!artData.success) { showStatus('Artifact not found: ' + tag, true); return; }
      return fetch('/api/algo-desktop', {
        method: 'POST', headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ adminKey: ADMIN_KEY, action: 'add', name: name + '.artifact', content: artData.content, type: 'artifact', icon: icon, sourceTag: tag })
      }).then(function(r) { return r.json(); });
    }).then(function(data) {
      if (data && data.success) {
        showStatus('Artifact added: ' + name, false);
        document.getElementById('dist-artifact-tag').value = '';
        document.getElementById('dist-artifact-name').value = '';
        loadCurrentItems();
      } else if (data) { showStatus('Failed: ' + (data.error || 'Unknown'), true); }
    }).catch(function(e) { showStatus('Error: ' + e.message, true); });
  };

  function removeItem(name) {
    if (!confirm('Remove "' + name + '" from all desktops?')) return;
    fetch('/api/algo-desktop', {
      method: 'POST', headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ adminKey: ADMIN_KEY, action: 'remove', name: name })
    }).then(function(r) { return r.json(); }).then(function(data) {
      if (data.success) { showStatus('Removed: ' + name, false); loadCurrentItems(); }
      else { showStatus('Failed: ' + (data.error || 'Unknown'), true); }
    }).catch(function(e) { showStatus('Error: ' + e.message, true); });
  }

  loadCurrentItems();
  loadArtifacts();
}

// ==================== BOX EDITOR ====================
// File type registration (FILE_TYPE_HANDLERS declared at top)

function getFileExtension(filename) {
  const match = filename.match(/\.([^.]+)$/);
  return match ? match[1].toLowerCase() : null;
}

function getFileHandlers(filename, content) {
  const handlers = [];
  const ext = getFileExtension(filename);

  // Check by extension
  if (ext && FILE_TYPE_HANDLERS[ext]) {
    handlers.push(...FILE_TYPE_HANDLERS[ext]);
  }

  // Check for .box files (start with //)
  if (content && content.trim().startsWith('//')) {
    if (FILE_TYPE_HANDLERS['box']) {
      handlers.push(...FILE_TYPE_HANDLERS['box']);
    }
  }

  return handlers;
}

// ==================== START MENU ====================
function toggleStartMenu() {
  document.getElementById('start-menu').classList.toggle('visible');
  document.getElementById('start-btn').classList.toggle('active');
}

function hideStartMenu() {
  document.getElementById('start-menu').classList.remove('visible');
  document.getElementById('start-btn').classList.remove('active');
}

// ==================== UTILITIES ====================
function globalClick(e) {
  if (!e.target.closest('#start-menu') && !e.target.closest('#start-btn')) hideStartMenu();
  if (!e.target.closest('#context-menu')) hideContextMenu();
  if (!e.target.closest('.dropdown-menu') && !e.target.closest('.menu-item')) hideMenus();
}

function hideContextMenu() { document.getElementById('context-menu').classList.remove('visible'); }
function hideMenus() { document.querySelectorAll('.dropdown-menu').forEach(m => m.classList.remove('visible')); }

function updateClock() {
  document.getElementById('clock').textContent = new Date().toLocaleTimeString('en-US', { hour:'numeric', minute:'2-digit', hour12:true });
}

function escapeHtml(s) {
  return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#039;');
}

function postToLaserbarf(text, room) {
  room = room || 'algo-world';
  const tag = (room === 'algo-world' || room === 'algo-dolphin') ? room + ':dolphin42' : room;
  fetch('/', {
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
    body: 'yo=489&text=' + encodeURIComponent(text + '\n\n#' + tag) + '&save=POST'
  });
}

function algoSpeak(text) {
  const bubble = document.getElementById('speech-bubble');
  const sprite = document.getElementById('algo-sprite');
  const rect = sprite.getBoundingClientRect();
  bubble.textContent = text;
  bubble.style.left = (rect.right + 5) + 'px';
  bubble.style.top = (rect.top - 10) + 'px';
  bubble.style.display = 'block';
  setTimeout(() => bubble.style.display = 'none', 4000);
}

function showAbout() {
  hideStartMenu();
  createWindow({
    title: 'About ALGO OS',
    stateKey: 'About ALGO OS',
    icon: 'üê¨',
    width: 300, height: 220,
    content: '<div style="padding:20px;text-align:center;">' +
      '<div style="font-size:48px;">üê¨</div>' +
      '<h2>ALGO OS</h2>' +
      '<p>Version 98.0</p>' +
      '<p style="margin-top:10px;font-size:10px;">Trusted Zone</p>' +
      '<p style="font-size:10px;">Key: dolphin42</p>' +
    '</div>'
  });
}

function openSettings() {
  hideStartMenu();
  const currentName = localStorage.getItem('algo-username') || '';
  const currentBg = localStorage.getItem('algo-bg-color') || '#008080';
  const currentBgMode = localStorage.getItem('algo-bg-mode') || 'cover';

  // Get available images for background
  const imageFiles = savedFiles.filter(f => f.type === 'image');
  const imageOptions = imageFiles.length > 0
    ? '<option value="">-- Select Image --</option>' + imageFiles.map((f, i) =>
        '<option value="' + i + '">' + escapeHtml(f.name) + '</option>').join('')
    : '<option value="">No images on desktop</option>';

  createWindow({
    title: 'Settings',
    stateKey: 'Settings',
    icon: '‚öôÔ∏è',
    width: 380, height: 380,
    content: '<div style="padding:15px;">' +
      '<h3 style="margin-bottom:15px;">‚öôÔ∏è ALGO OS Settings</h3>' +
      '<div style="margin-bottom:15px;">' +
        '<label style="display:block;margin-bottom:5px;font-weight:bold;">Username:</label>' +
        '<input type="text" id="settings-username" value="' + escapeHtml(currentName) + '" ' +
          'style="width:100%;padding:5px;border:2px inset #fff;" placeholder="Enter your display name">' +
        '<p style="font-size:10px;color:#666;margin-top:4px;">Used in ALGO Chat and Webcam</p>' +
      '</div>' +
      '<hr style="margin:15px 0;border:none;border-top:1px solid #808080;">' +
      '<div style="margin-bottom:10px;">' +
        '<label style="display:block;margin-bottom:5px;font-weight:bold;">Desktop Background:</label>' +
        '<div style="display:flex;gap:8px;align-items:center;margin-bottom:8px;">' +
          '<label>Color:</label>' +
          '<input type="color" id="settings-bg-color" value="' + currentBg + '" style="width:50px;height:25px;">' +
          '<button onclick="clearDesktopBg()" style="padding:3px 8px;font-size:10px;">Reset</button>' +
        '</div>' +
        '<div style="display:flex;gap:8px;align-items:center;margin-bottom:8px;">' +
          '<label>Image:</label>' +
          '<select id="settings-bg-image" style="flex:1;padding:3px;">' + imageOptions + '</select>' +
          '<button onclick="applyBgImage()" style="padding:3px 8px;">Apply</button>' +
        '</div>' +
        '<div style="display:flex;gap:8px;align-items:center;">' +
          '<label>Style:</label>' +
          '<select id="settings-bg-mode" style="padding:3px;">' +
            '<option value="cover"' + (currentBgMode === 'cover' ? ' selected' : '') + '>Fill (Cover)</option>' +
            '<option value="stretch"' + (currentBgMode === 'stretch' ? ' selected' : '') + '>Stretch</option>' +
            '<option value="tile"' + (currentBgMode === 'tile' ? ' selected' : '') + '>Tile</option>' +
            '<option value="center"' + (currentBgMode === 'center' ? ' selected' : '') + '>Center</option>' +
          '</select>' +
        '</div>' +
      '</div>' +
      '<div style="display:flex;gap:8px;justify-content:flex-end;margin-top:20px;">' +
        '<button onclick="saveSettings()" style="padding:5px 15px;">Save</button>' +
        '<button onclick="closeWindow(getWindowByTitle(\'Settings\').id)" style="padding:5px 15px;">Cancel</button>' +
      '</div>' +
    '</div>'
  });
}

function saveSettings() {
  const nameInput = document.getElementById('settings-username');
  if (nameInput) {
    const name = nameInput.value.trim();
    localStorage.setItem('algo-username', name);
  }

  // Save background color
  const bgColor = document.getElementById('settings-bg-color');
  if (bgColor) {
    localStorage.setItem('algo-bg-color', bgColor.value);
  }

  // Save background mode
  const bgMode = document.getElementById('settings-bg-mode');
  if (bgMode) {
    localStorage.setItem('algo-bg-mode', bgMode.value);
    applyBgMode(bgMode.value);
  }

  algoSpeak('Settings saved!');
  const win = getWindowByTitle('Settings');
  if (win) closeWindow(win.id);
}

function applyBgImage() {
  const select = document.getElementById('settings-bg-image');
  if (!select || select.value === '') return;

  const idx = parseInt(select.value);
  const imageFiles = savedFiles.filter(f => f.type === 'image');
  if (idx >= 0 && idx < imageFiles.length) {
    const img = imageFiles[idx];
    setDesktopBackground(img.content);
    localStorage.setItem('algo-bg-image', img.content);
    algoSpeak('Background set to ' + img.name);
  }
}

function setDesktopBackground(imageData) {
  const desktop = document.getElementById('desktop');
  desktop.style.backgroundImage = 'url(' + imageData + ')';
  const mode = localStorage.getItem('algo-bg-mode') || 'cover';
  applyBgMode(mode);
}

function applyBgMode(mode) {
  const desktop = document.getElementById('desktop');
  desktop.classList.remove('bg-tile', 'bg-stretch', 'bg-center');
  if (mode === 'tile') desktop.classList.add('bg-tile');
  else if (mode === 'stretch') desktop.classList.add('bg-stretch');
  else if (mode === 'center') desktop.classList.add('bg-center');
}

function clearDesktopBg() {
  const desktop = document.getElementById('desktop');
  desktop.style.backgroundImage = '';
  desktop.style.backgroundColor = '#008080';
  desktop.classList.remove('bg-tile', 'bg-stretch', 'bg-center');
  localStorage.removeItem('algo-bg-image');
  localStorage.setItem('algo-bg-color', '#008080');
  document.getElementById('settings-bg-color').value = '#008080';
  algoSpeak('Background reset');
}

function loadDesktopBackground() {
  const bgImage = localStorage.getItem('algo-bg-image');
  const bgColor = localStorage.getItem('algo-bg-color') || '#008080';
  const bgMode = localStorage.getItem('algo-bg-mode') || 'cover';

  const desktop = document.getElementById('desktop');
  desktop.style.backgroundColor = bgColor;

  if (bgImage) {
    desktop.style.backgroundImage = 'url(' + bgImage + ')';
    applyBgMode(bgMode);
  }
}

function setImageAsBackground(fileIdx) {
  const imageFiles = savedFiles.filter(f => f.type === 'image');
  if (fileIdx >= 0 && fileIdx < imageFiles.length) {
    const img = imageFiles[fileIdx];
    setDesktopBackground(img.content);
    localStorage.setItem('algo-bg-image', img.content);
    algoSpeak('Background set to ' + img.name);
  }
  hideContextMenu();
}

function getWindowByTitle(title) {
  return windows.find(w => w.title === title);
}

// ==================== PROGRAM MANAGER ====================
function openProgramManager() {
  hideStartMenu();
  const id = winId;

  createWindow({
    title: 'Program Manager',
    stateKey: 'Program Manager',
    icon: 'üìÇ',
    width: 550,
    height: 450,
    content: '<div style="display:flex;flex-direction:column;height:100%;">' +
      '<div style="padding:8px;background:#c0c0c0;border-bottom:1px solid #808080;">' +
        '<strong>üìÇ Program Manager</strong> - Manage applications and file associations' +
      '</div>' +
      '<div style="display:flex;flex:1;overflow:hidden;">' +
        '<div style="width:180px;border-right:1px solid #808080;overflow-y:auto;background:#fff;">' +
          '<div id="pm-categories-' + id + '" style="padding:4px;"></div>' +
        '</div>' +
        '<div style="flex:1;overflow-y:auto;padding:10px;" id="pm-content-' + id + '"></div>' +
      '</div>' +
    '</div>'
  });

  setTimeout(function() { initProgramManager(id); }, 100);
}

function initProgramManager(id) {
  var cats = document.getElementById('pm-categories-' + id);
  var content = document.getElementById('pm-content-' + id);
  if (!cats || !content) return;

  var categories = [
    { id: 'file-types', name: 'üìÑ File Types', icon: 'üìÑ' },
    { id: 'apps', name: 'üì¶ Applications', icon: 'üì¶' },
    { id: 'installed', name: 'üíæ Installed', icon: 'üíæ' }
  ];

  cats.innerHTML = categories.map(function(c) {
    return '<div class="pm-cat" onclick="pmShowCategory(' + id + ',\'' + c.id + '\')" ' +
      'style="padding:6px 10px;cursor:pointer;border-bottom:1px solid #e0e0e0;" ' +
      'onmouseover="this.style.background=\'#e8e8ff\'" onmouseout="this.style.background=\'\'"><span>' + c.icon + '</span> ' + c.name + '</div>';
  }).join('');

  pmShowCategory(id, 'file-types');
}

function pmShowCategory(id, cat) {
  var content = document.getElementById('pm-content-' + id);
  if (!content) return;

  if (cat === 'file-types') {
    var exts = Object.keys(FILE_TYPE_HANDLERS);
    if (exts.length === 0) {
      content.innerHTML = '<p style="color:#666;">No file type handlers registered yet.</p>';
      return;
    }

    var html = '<h3 style="margin:0 0 10px 0;">File Type Associations</h3>';
    html += '<p style="font-size:11px;color:#666;margin-bottom:10px;">Configure which application opens each file type.</p>';

    exts.forEach(function(ext) {
      var handlers = FILE_TYPE_HANDLERS[ext];
      var defaultId = defaultFileHandlers[ext];
      html += '<div style="margin-bottom:12px;padding:8px;background:#f8f8f8;border:1px solid #ddd;">';
      html += '<div style="font-weight:bold;margin-bottom:6px;">.' + ext.toUpperCase() + ' files</div>';
      html += '<select onchange="pmSetDefault(\'' + ext + '\', this.value)" style="width:100%;padding:4px;">';
      handlers.forEach(function(h) {
        var selected = h.appId === defaultId ? ' selected' : '';
        html += '<option value="' + h.appId + '"' + selected + '>' + h.icon + ' ' + h.name + '</option>';
      });
      html += '</select>';
      html += '</div>';
    });

    content.innerHTML = html;

  } else if (cat === 'apps') {
    var builtIn = [
      { name: 'Notepad', icon: 'üìù', desc: 'Text editor for .txt files' },
      { name: 'JavaScript.IDE', icon: 'üìú', desc: 'Create ALGO OS apps' },
      { name: 'Markdown Viewer', icon: 'üìÑ', desc: 'View .md files' }
    ];

    var html = '<h3 style="margin:0 0 10px 0;">Built-in Applications</h3>';
    builtIn.forEach(function(app) {
      html += '<div style="padding:8px;margin-bottom:6px;background:#f8f8f8;border:1px solid #ddd;display:flex;align-items:center;gap:10px;">';
      html += '<span style="font-size:24px;">' + app.icon + '</span>';
      html += '<div><strong>' + app.name + '</strong><br><span style="font-size:11px;color:#666;">' + app.desc + '</span></div>';
      html += '</div>';
    });

    content.innerHTML = html;

  } else if (cat === 'installed') {
    var jsApps = savedFiles.filter(function(f) { return f.name.endsWith('.js'); });

    var html = '<h3 style="margin:0 0 10px 0;">Installed JavaScript Apps</h3>';

    if (jsApps.length === 0) {
      html += '<p style="color:#666;">No JavaScript apps installed. Create one in JavaScript.IDE!</p>';
    } else {
      jsApps.forEach(function(app) {
        var meta = extractAppMetadata(app.content || '');
        var icon = meta.icon || 'üìú';
        var name = meta.name || app.name;
        html += '<div style="padding:8px;margin-bottom:6px;background:#f8f8f8;border:1px solid #ddd;display:flex;align-items:center;gap:10px;">';
        html += '<span style="font-size:24px;">' + icon + '</span>';
        html += '<div style="flex:1;"><strong>' + name + '</strong><br><span style="font-size:11px;color:#666;">' + app.name + '</span></div>';
        html += '<button onclick="pmRunApp(\'' + app.name.replace(/'/g, "\\'") + '\')" style="padding:4px 8px;">Run</button>';
        html += '</div>';
      });
    }

    content.innerHTML = html;
  }
}

function pmSetDefault(ext, appId) {
  setDefaultHandler(ext, appId);
  var handler = FILE_TYPE_HANDLERS[ext].find(function(h) { return h.appId === appId; });
  if (handler) {
    algoSpeak(handler.name + ' set as default for .' + ext);
  }
}

function pmRunApp(filename) {
  var file = savedFiles.find(function(f) { return f.name === filename; });
  if (file) {
    openJSIDE(file.content, file.name);
    setTimeout(function() {
      var codeEl = document.querySelector('[id^="ide-code-"]');
      if (codeEl) {
        var id = codeEl.id.replace('ide-code-', '');
        ideRun(parseInt(id));
      }
    }, 500);
  }
}

// ==================== PERSISTENCE ====================
function saveState() {
  localStorage.setItem('algo-files', JSON.stringify(savedFiles));
  localStorage.setItem('algo-programs', JSON.stringify(installedPrograms));
  localStorage.setItem('algo-rooms', JSON.stringify(roomFolders));
  localStorage.setItem('algo-windows', JSON.stringify(windowStates));
  localStorage.setItem('algo-apikeys', JSON.stringify(apiKeys));
  localStorage.setItem('algo-file-handlers', JSON.stringify(defaultFileHandlers));
}

function loadState() {
  try {
    savedFiles = JSON.parse(localStorage.getItem('algo-files') || '[]');
    installedPrograms = JSON.parse(localStorage.getItem('algo-programs') || '[]');
    roomFolders = JSON.parse(localStorage.getItem('algo-rooms') || '[]');
    windowStates = JSON.parse(localStorage.getItem('algo-windows') || '{}');
    apiKeys = JSON.parse(localStorage.getItem('algo-apikeys') || '{}');
    iconPositions = JSON.parse(localStorage.getItem('algo-icon-positions') || '{}');
    defaultFileHandlers = JSON.parse(localStorage.getItem('algo-file-handlers') || '{}');
    updateProgramsMenu();
  } catch(e) {}
}

// ==================== ALGO DOLPHIN MASCOT ====================
let dolphinX, dolphinY, dolphinVx, dolphinVy, dolphinFacingRight = true;

function initDolphin() {
  const dolphin = document.getElementById('algo-dolphin');
  if (!dolphin) return;

  // Start in center of screen
  dolphinX = window.innerWidth / 2 - 16;
  dolphinY = window.innerHeight / 2 - 16;

  // Random initial velocity
  dolphinVx = (Math.random() - 0.5) * 2;
  dolphinVy = (Math.random() - 0.5) * 1.5;

  dolphin.style.left = dolphinX + 'px';
  dolphin.style.top = dolphinY + 'px';

  // Update every 50ms
  setInterval(updateDolphin, 50);
}

function updateDolphin() {
  const dolphin = document.getElementById('algo-dolphin');
  if (!dolphin) return;

  // Move dolphin
  dolphinX += dolphinVx;
  dolphinY += dolphinVy;

  // Screen boundaries
  const maxX = window.innerWidth - 50;
  const maxY = window.innerHeight - 80; // Above taskbar
  const minY = 10;

  // Icon area boundary (avoid left side where icons are)
  const iconAreaRight = 200;

  // Bounce off edges
  if (dolphinX < iconAreaRight) {
    dolphinX = iconAreaRight;
    dolphinVx = Math.abs(dolphinVx) * 0.8 + 0.5;
  }
  if (dolphinX > maxX) {
    dolphinX = maxX;
    dolphinVx = -Math.abs(dolphinVx) * 0.8 - 0.5;
  }
  if (dolphinY < minY) {
    dolphinY = minY;
    dolphinVy = Math.abs(dolphinVy) * 0.8 + 0.3;
  }
  if (dolphinY > maxY) {
    dolphinY = maxY;
    dolphinVy = -Math.abs(dolphinVy) * 0.8 - 0.3;
  }

  // Add slight random drift
  dolphinVx += (Math.random() - 0.5) * 0.1;
  dolphinVy += (Math.random() - 0.5) * 0.08;

  // Limit velocity
  const maxSpeed = 3;
  if (Math.abs(dolphinVx) > maxSpeed) dolphinVx = maxSpeed * Math.sign(dolphinVx);
  if (Math.abs(dolphinVy) > maxSpeed * 0.7) dolphinVy = maxSpeed * 0.7 * Math.sign(dolphinVy);

  // Flip dolphin based on direction (use data attribute, CSS handles animation)
  if (dolphinVx > 0.1 && !dolphinFacingRight) {
    dolphinFacingRight = true;
    dolphin.dataset.facing = 'right';
  } else if (dolphinVx < -0.1 && dolphinFacingRight) {
    dolphinFacingRight = false;
    dolphin.dataset.facing = 'left';
  }

  dolphin.style.left = dolphinX + 'px';
  dolphin.style.top = dolphinY + 'px';
}

// ==================== MARKDOWN VIEWER ====================
function registerMarkdownFileType() {
  registerFileHandler('md', 'Markdown Viewer', 'üìÑ', openMarkdownFile, 'md-viewer');
}

// Register built-in Notepad for text files
function registerNotepadFileType() {
  registerFileHandler('txt', 'Notepad', 'üìù', function(content, filename, file) {
    openNotepad(content, filename, file ? file.room : null, file);
  }, 'notepad');
}

function openMarkdownFile(content, filename) {
  const html = parseMarkdown(content);
  createWindow({
    title: filename || 'Markdown',
    stateKey: 'Markdown:' + filename,
    icon: 'üìÑ',
    width: 520,
    height: 450,
    content: '<div style="padding:15px;overflow:auto;height:100%;background:#fff;font-family:system-ui,sans-serif;font-size:12px;">' + html + '</div>'
  });
}

function parseMarkdown(md) {
  let html = md;
  html = html.replace(/</g, '&lt;').replace(/>/g, '&gt;');
  html = html.replace(/```(\w*)\n([\s\S]*?)```/g, (m, lang, code) =>
    '<pre style="background:#1e1e1e;color:#d4d4d4;padding:10px;overflow-x:auto;border-radius:4px;font-size:11px;"><code>' + code.trim() + '</code></pre>');
  html = html.replace(/`([^`]+)`/g, '<code style="background:#e8e8e8;padding:1px 4px;font-size:11px;">$1</code>');
  const lines = html.split('\n');
  let inTable = false, tableHtml = '', isHeader = true;
  const result = [];
  for (let line of lines) {
    if (line.match(/^\|.*\|$/)) {
      if (!inTable) { inTable = true; tableHtml = '<table style="border-collapse:collapse;width:100%;margin:10px 0;font-size:11px;">'; isHeader = true; }
      if (line.match(/^\|[\s-:|]+\|$/)) { isHeader = false; continue; }
      const cells = line.split('|').slice(1, -1).map(c => c.trim());
      const tag = isHeader ? 'th' : 'td';
      const style = isHeader ? 'style="border:1px solid #ccc;padding:4px 8px;background:#e8e8e8;"' : 'style="border:1px solid #ccc;padding:4px 8px;"';
      tableHtml += '<tr>' + cells.map(c => '<' + tag + ' ' + style + '>' + c + '</' + tag + '>').join('') + '</tr>';
      if (isHeader) isHeader = false;
    } else {
      if (inTable) { tableHtml += '</table>'; result.push(tableHtml); inTable = false; tableHtml = ''; }
      result.push(line);
    }
  }
  if (inTable) { tableHtml += '</table>'; result.push(tableHtml); }
  html = result.join('\n');
  html = html.replace(/^### (.+)$/gm, '<h3 style="font-size:13px;margin:10px 0 6px;">$1</h3>');
  html = html.replace(/^## (.+)$/gm, '<h2 style="font-size:15px;border-bottom:1px solid #999;padding-bottom:3px;margin:12px 0 8px;">$1</h2>');
  html = html.replace(/^# (.+)$/gm, '<h1 style="font-size:18px;border-bottom:2px solid #333;padding-bottom:5px;margin:15px 0 10px;">$1</h1>');
  html = html.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
  html = html.replace(/\*([^*]+)\*/g, '<em>$1</em>');
  html = html.replace(/^&gt; (.+)$/gm, '<blockquote style="border-left:3px solid #0078d7;margin:10px 0;padding:5px 15px;background:#f0f7ff;">$1</blockquote>');
  html = html.replace(/^- (.+)$/gm, '<li style="margin:4px 0;">$1</li>');
  html = html.replace(/(<li[^>]*>.*<\/li>\n?)+/g, '<ul style="margin:8px 0;padding-left:25px;">$&</ul>');
  html = html.split('\n\n').map(p => {
    p = p.trim();
    if (!p || p.startsWith('<')) return p;
    return '<p style="margin:8px 0;line-height:1.5;">' + p.replace(/\n/g, '<br>') + '</p>';
  }).join('\n');
  return html;
}

// Start
initDolphin();
init();
</script>
</body>
</html>