<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Function Server</title>
<script>
// Early theme loading - runs before CSS to prevent flash
(function() {
  var theme = localStorage.getItem('fs-theme');
  if (theme) {
    var style = document.createElement('style');
    style.id = 'fs-theme-override';
    style.textContent = theme;
    document.head.appendChild(style);
  }
})();
</script>
<link rel="stylesheet" href="algo-os.css">
</head>
<body>

<!-- Login Overlay -->
<div id="login-overlay" style="display:none;">
  <div class="login-dialog">
    <h2>ğŸ–¥ï¸ Function Server</h2>
    <div class="tabs">
      <div class="tab active" data-tab="login" onclick="showLoginTab('login')">Login</div>
      <div class="tab" data-tab="register" onclick="showLoginTab('register')">Register</div>
    </div>
    <div id="login-form">
      <label>Username:</label>
      <input type="text" id="login-username" autocomplete="username">
      <label>Password:</label>
      <input type="password" id="login-password" autocomplete="current-password">
      <div style="margin:8px 0;display:flex;align-items:center;gap:6px;">
        <input type="checkbox" id="login-system-user" style="width:auto;margin:0;">
        <label for="login-system-user" style="font-size:12px;color:#888;cursor:pointer;margin:0;">System User (Linux admin login)</label>
      </div>
      <div class="buttons">
        <button onclick="doLogin()">Login</button>
      </div>
    </div>
    <div id="register-form" style="display:none;">
      <label>Username:</label>
      <input type="text" id="reg-username" autocomplete="username">
      <label>Password:</label>
      <input type="password" id="reg-password" autocomplete="new-password">
      <label>Confirm:</label>
      <input type="password" id="reg-confirm" autocomplete="new-password">
      <div class="buttons">
        <button onclick="doRegister()">Create Account</button>
      </div>
    </div>
    <div id="login-error" class="error"></div>
  </div>
</div>

<div id="desktop">
  <div id="desktop-toolbar">
    <div id="desktop-breadcrumbs">
      <span class="breadcrumb" data-path="~" onclick="navigateToPath('~')"><b style="font-size:1.2em;">~</b></span>
    </div>
    <div id="desktop-actions">
      <span class="desktop-action" title="Toggle hidden files" onclick="toggleHiddenFiles()">ğŸ‘</span>
      <span class="desktop-action" title="Toggle file extensions" onclick="toggleExtensions()">.js</span>
      <span class="desktop-action" title="New folder" onclick="createNewFolder()">ğŸ“+</span>
    </div>
  </div>
  <div id="desktop-icons"></div>
</div>
<div id="toast-container"></div>

<!-- macOS-style Menu Bar (Veil theme) -->
<div id="menubar">
  <div id="menubar-left">
    <div id="system-icon" onclick="toggleStartMenu()">Æ’</div>
    <div id="active-app-name">Desktop</div>
    <div id="app-menus"></div>
  </div>
  <div id="menubar-right">
    <div id="menubar-status">
      <span class="status-icon" id="status-eye" title="Eye Bridge" onclick="algoSpeak(eyeBridgeConnected ? 'Eye Bridge connected' : 'Eye Bridge disconnected')">ğŸ‘</span>
      <span class="status-icon" id="status-shadow" title="Shadow Tabs">ğŸ‘»</span>
    </div>
    <div id="menubar-user" onclick="toggleUserMenu()"></div>
    <div id="menubar-clock"></div>
  </div>
</div>
<div id="user-menu">
  <div class="user-menu-item" onclick="copyAuthInfo();hideUserMenu();">Copy Claude Auth</div>
  <div class="user-menu-item" onclick="openSettings();hideUserMenu();">Account Settings</div>
  <div class="user-menu-separator"></div>
  <div class="user-menu-item" onclick="logout();hideUserMenu();">Log Out</div>
</div>

<!-- Legacy taskbar (Classic theme) -->
<div id="taskbar">
  <div id="start-btn" onclick="toggleStartMenu()">
    <span style="font-size:14px;">ğŸ–¥ï¸</span> Start
  </div>
  <div id="taskbar-windows"></div>
  <div id="system-tray"></div>
  <div id="clock"></div>
</div>

<div id="start-menu">
  <div class="start-sidebar">FunctionServer</div>
  <div class="start-items">
    <div class="start-item has-sub" onclick="toggleSubmenu(event, this)" onmouseenter="openSubmenu(this)" onmouseleave="closeSubmenuDelay(this)">
      <span>ğŸ“</span> Programs
      <div class="start-submenu" id="programs-menu">
        <div class="start-item" onclick="openNotepad()"><span>ğŸ“</span> Notepad</div>
        <div class="start-item" onclick="openJSIDE()"><span>ğŸ’»</span> javascript.ide</div>
        <div class="start-item" onclick="openBrowser()"><span>ğŸŒ</span> Web Browser</div>
        <div class="start-separator"></div>
        <div id="installed-programs-menu"></div>
      </div>
    </div>
    <div class="start-item" onclick="openDocumentation()"><span style="color:#8B0000;">ğŸ“•</span> Documentation</div>
    <div class="start-item" onclick="openHelp()"><span style="color:#8B0000;">ğŸ“™</span> Help</div>
    <div class="start-separator"></div>
    <div class="start-item" onclick="showAbout()"><span>â„¹ï¸</span> About</div>
    <div class="start-item" onclick="openSettings()"><span>âš™ï¸</span> Settings</div>
    <div class="start-item" onclick="hardRefresh()"><span>ğŸ”„</span> Refresh</div>
    <div class="start-separator"></div>
    <div class="start-item" id="start-menu-auth" onclick="logout()"><span>ğŸšª</span> Log Out</div>
  </div>
</div>

<div id="context-menu"></div>

<script>
// ==================== CONFIG ====================
const API_BASE = '/api';
let currentUser = null;
let sessionToken = null;

// ==================== STATE ====================
let windows = [];
let winId = 0;
let activeWin = null;
let savedFiles = [];
let installedPrograms = [];
let systemApps = [];
let uninstalledSystemApps = [];
let windowStates = {};
let apiKeys = {};
let dragWin = null;
let dragOffset = { x: 0, y: 0 };
let contextTarget = null;
let submenuCloseTimeout = null;
let topZIndex = 100;  // Track highest z-index for window stacking

// ==================== FILE ASSOCIATION REGISTRY ====================
// Apps register handlers for file extensions. First handler is default.
// Structure: { ext: [{ id, name, icon, handler, isDefault }] }
const fileHandlers = {};

function registerFileHandler(config) {
  // config: { id, name, icon, extensions: ['html', 'htm'], handler: fn, isDefault: bool }
  const { id, name, icon, extensions, handler, isDefault } = config;
  if (!id || !extensions || !handler) return;

  extensions.forEach(ext => {
    const e = ext.toLowerCase().replace(/^\./, '');
    if (!fileHandlers[e]) fileHandlers[e] = [];

    // Remove existing handler with same id
    fileHandlers[e] = fileHandlers[e].filter(h => h.id !== id);

    const entry = { id, name: name || id, icon: icon || 'ğŸ“„', handler };

    if (isDefault) {
      fileHandlers[e].unshift(entry); // Default goes first
    } else {
      fileHandlers[e].push(entry);
    }
  });
}

function getFileHandlers(filename) {
  const ext = (filename.split('.').pop() || '').toLowerCase();
  return fileHandlers[ext] || [];
}

function getDefaultHandler(filename) {
  const handlers = getFileHandlers(filename);
  return handlers[0] || null;
}

function openFileWithHandler(handlerId, filePath, fileName, content) {
  const handlers = getFileHandlers(fileName);
  const handler = handlers.find(h => h.id === handlerId);
  if (handler) {
    handler.handler(filePath, fileName, content);
  } else {
    algoSpeak('No handler found: ' + handlerId);
  }
}

async function openFileWithDefaultHandler(filePath, fileName) {
  const handler = getDefaultHandler(fileName);
  if (handler) {
    const content = await getFileFromDisk(filePath);
    if (content !== null) {
      handler.handler(filePath, fileName, content);
    } else {
      algoSpeak('Failed to open file');
    }
  } else {
    // Fallback to notepad for unknown types
    const content = await getFileFromDisk(filePath);
    if (content !== null) {
      openNotepad(content, fileName);
    }
  }
}

// Expose registration API globally
window.registerFileHandler = registerFileHandler;

// ==================== ICON SYSTEM ====================
// Customizable icons with theme-aware colors for unicode characters
const ICON_DEFS = {
  system:        { default: 'Æ’', alts: ['Î»', 'â¬¡', 'â—ˆ', 'â–', 'âœ¦', 'âŒ˜', 'â˜°', 'âŠ', 'â—†', 'â—'] },
  programs:      { default: 'ğŸ“', alts: ['ğŸ“‚', 'ğŸ—‚ï¸', 'â–¤', 'â˜°', 'âŠ', 'â–¦', 'â–', 'â—ˆ', 'â¬¡', 'â”'] },
  documentation: { default: 'ğŸ“•', alts: ['ğŸ“–', 'ğŸ“š', 'ğŸ“’', 'ğŸ““', 'ğŸ“”', 'ğŸ•®', 'â˜·', 'â‰¡', 'â˜²', 'â¡'] },
  help:          { default: 'ğŸ“™', alts: ['ğŸ“—', 'ğŸ“˜', 'â“', 'â”', '?', 'Â¿', 'â‡', 'â°', 'â˜‰', 'â—'] },
  about:         { default: 'â„¹ï¸', alts: ['â“˜', 'ğŸ›ˆ', 'i', 'ğ•š', 'ğ’¾', 'âŒ˜', 'âœ¦', 'â—‰', 'â—', 'â—†'] },
  settings:      { default: 'âš™ï¸', alts: ['ğŸ”§', 'ğŸ› ï¸', 'â›­', 'âš¡', 'âœ§', 'â‚', 'â€»', 'âŒ—', 'â˜¸', 'âŸ'] },
  logout:        { default: 'ğŸšª', alts: ['ğŸ”“', 'ğŸš¶', 'âœ', 'â', 'â†©', 'â‡¤', 'â‹', 'âœ•', 'â—', 'â¬…'] },
  login:         { default: 'ğŸ”‘', alts: ['ğŸ”', 'ğŸ—ï¸', 'âš¿', 'âœ', 'â‡¥', 'â–·', 'âŠ³', 'â–º', 'â—‡', 'âœ¦'] },
  user:          { default: 'ğŸ‘¤', alts: ['ğŸ‘¨', 'ğŸ‘©', 'ğŸ§‘', 'â˜º', 'â˜»', 'â—‰', 'â—', 'â—‹', 'â—¯', 'â¬¤'] },
  eye:           { default: 'ğŸ‘', alts: ['ğŸ‘€', 'ğŸ”', 'â—‰', 'â—', 'â—', 'â—‹', 'âŠ™', 'â˜‰', 'â¦¿', 'â—¯'] },
  shadow:        { default: 'ğŸ‘»', alts: ['ğŸ«¥', 'ğŸ’¨', 'ğŸŒ«ï¸', 'â—Œ', 'â—', 'â—', 'â—‹', 'â—¯', 'â¬š', 'â–¢'] },
  notepad:       { default: 'ğŸ“', alts: ['ğŸ“„', 'ğŸ“ƒ', 'ğŸ—’ï¸', 'âœ', 'âœ', 'âœ', 'â˜°', 'â‰¡', 'â–¤', 'âŠŸ'] },
  ide:           { default: 'ğŸ’»', alts: ['ğŸ–¥ï¸', 'âŒ¨ï¸', 'ğŸ–³', 'âŒ˜', 'âŸ¨âŸ©', '<>', '{}', 'âŒ¥', 'â‡', 'â£'] },
  browser:       { default: 'ğŸŒ', alts: ['ğŸ”', 'ğŸŒ', 'ğŸŒ', 'ğŸŒ', 'âŠ•', 'âŠ›', 'â—', 'â˜‰', 'âœ¦', 'â—‰'] },
  toast:         { default: 'ğŸ–¥ï¸', alts: ['ğŸ“¢', 'ğŸ””', 'ğŸ’¬', 'â—ˆ', 'â—†', 'âœ¦', 'â˜†', 'â˜…', 'â—‰', 'â—'] },
  copy:          { default: 'ğŸ“‹', alts: ['ğŸ“‘', 'ğŸ—', 'â˜', 'â§‰', 'â', 'â–¢', 'âŠ', 'â§ˆ', 'â—«', 'â¬š'] },
  app:           { default: 'ğŸ“±', alts: ['ğŸ®', 'ğŸ”®', 'ğŸ’', 'â—†', 'â—ˆ', 'âœ¦', 'â˜…', 'â˜†', 'â—‰', 'â—'] }
};

// Load custom icons from localStorage (loaded early to prevent flash)
let customIcons = {};
try {
  const stored = localStorage.getItem('fs-icons');
  if (stored) customIcons = JSON.parse(stored);
} catch(e) {}

function getIcon(iconKey, fallback) {
  // If it's already an emoji/character, check if it's a known key
  if (ICON_DEFS[iconKey]) {
    const custom = customIcons[iconKey];
    if (custom) return renderIcon(custom);
    return ICON_DEFS[iconKey].default;
  }
  // Otherwise return the passed icon directly
  return fallback || iconKey;
}

// Render icon - supports simple string or complex object format
// Simple: "ğŸ“" or "Î»"
// Complex: { main: "ğŸ“", sub: "ğŸ”’", blend: "normal", scale: 0.5, pos: "br", skewX: 0, skewY: 0 }
// Dynamic: { main: "ğŸ“„", sub: "code here", dynamic: true, rows: 4, cols: 12, trimStart: true }
function renderIcon(icon, fileContent) {
  if (typeof icon === 'string') {
    return wrapIconWithColor(icon);
  }

  if (typeof icon !== 'object') return icon;

  const main = icon.main || 'ğŸ“„';
  const sub = icon.sub || icon.text || '';
  const blend = icon.blend || 'normal';
  const scale = icon.scale || 0.5;
  const pos = icon.pos || 'br'; // tl, tr, bl, br, c (center)
  const mono = icon.mono || false;
  const skewX = icon.skewX || 0;
  const skewY = icon.skewY || 0;
  const offsetX = icon.offsetX || 0;
  const offsetY = icon.offsetY || 0;
  const fontSize = icon.fontSize || 100;
  const rows = icon.rows || 4;
  const cols = icon.cols || 12;
  const trimStart = icon.trimStart !== false;
  const showBounds = icon.showBounds || false;
  // New: drop shadow and theme color support
  const shadow = icon.shadow || null; // e.g., "1px 1px 2px rgba(0,0,0,0.5)" or true for default
  const subColor = icon.subColor || null; // explicit color or null for theme
  const useThemeColors = icon.useThemeColors || false; // use CSS variables

  // Process sub content - apply rows/cols/trim if multiline or dynamic
  let displaySub = sub;
  if (icon.dynamic && fileContent) {
    displaySub = formatIconPreview(fileContent, rows, cols, trimStart);
  } else if (sub && (sub.includes('\n') || sub.length > cols)) {
    displaySub = formatIconPreview(sub, rows, cols, trimStart);
  }

  if (!displaySub) {
    return wrapIconWithColor(main);
  }

  // Build layered icon HTML
  const posStyles = {
    tl: 'top:0;left:0;',
    tr: 'top:0;right:0;',
    bl: 'bottom:0;left:0;',
    br: 'bottom:0;right:0;',
    c: 'top:50%;left:50%;'
  };

  // Build transform string
  let transform = '';
  if (pos === 'c') transform += 'translate(-50%,-50%) ';
  if (skewX || skewY) transform += `skew(${skewX}deg, ${skewY}deg) `;
  if (offsetX || offsetY) transform += `translate(${offsetX}px, ${offsetY}px)`;

  // Calculate effective font size: scale * fontSize%
  const effectiveSize = scale * fontSize;

  // Build shadow style
  let shadowStyle = '';
  if (shadow === true) {
    shadowStyle = useThemeColors
      ? 'text-shadow:1px 1px 2px var(--shadow-color, rgba(0,0,0,0.5));'
      : 'text-shadow:1px 1px 2px rgba(0,0,0,0.5);';
  } else if (shadow) {
    shadowStyle = `text-shadow:${shadow};`;
  }

  // Build color style
  let colorStyle = '';
  if (subColor) {
    colorStyle = `color:${subColor};`;
  } else if (useThemeColors) {
    colorStyle = 'color:var(--text);';
  }

  const boundsStyle = showBounds ? 'outline:1px solid rgba(100,180,255,0.8);outline-offset:-1px;' : '';
  const subStyle = `position:absolute;${posStyles[pos] || posStyles.br}font-size:${effectiveSize}%;mix-blend-mode:${blend};${mono ? 'font-family:monospace;' : ''}${transform ? 'transform:' + transform.trim() + ';' : ''}${shadowStyle}${colorStyle}${boundsStyle}`;

  // Handle multiline text
  const isMultiline = displaySub.includes('\n');
  const subHtml = isMultiline
    ? '<pre style="margin:0;line-height:1.1;font-size:inherit;background:inherit;padding:1px 2px;">' + escapeHtml(displaySub) + '</pre>'
    : escapeHtml(displaySub);

  return `<span class="layered-icon"><span class="icon-main">${wrapIconWithColor(main)}</span><span class="icon-sub" style="${subStyle}">${subHtml}</span></span>`;
}

// Format content for icon preview - efficient extraction of first n chars per line
function formatIconPreview(content, maxLines = 4, maxChars = 12, trimStart = true) {
  if (!content) return '';
  const lines = content.split('\n').slice(0, maxLines);
  return lines.map(line => {
    const processed = trimStart ? line.trimStart() : line;
    return processed.substring(0, maxChars);
  }).join('\n');
}

// Format file content for icon preview
function formatIconPreview(content, maxLines = 4, maxChars = 12) {
  const lines = content.split('\n').slice(0, maxLines);
  return lines.map(line => {
    const trimmed = line.trimStart();
    return trimmed.substring(0, maxChars);
  }).join('\n');
}

function wrapIconWithColor(icon) {
  // Check if it's a unicode character (not emoji) that needs color
  if (typeof icon === 'string' && icon.length <= 2 && !/\p{Emoji}/u.test(icon)) {
    return '<span style="color:var(--text)">' + icon + '</span>';
  }
  return icon;
}

function setCustomIcon(key, icon) {
  if (!ICON_DEFS[key]) return;
  if (icon === ICON_DEFS[key].default) {
    delete customIcons[key];
  } else {
    customIcons[key] = icon;
  }
  // Only store if there are custom icons
  if (Object.keys(customIcons).length > 0) {
    localStorage.setItem('fs-icons', JSON.stringify(customIcons));
  } else {
    localStorage.removeItem('fs-icons');
  }
  // Refresh UI
  refreshAllIcons();
}

function refreshAllIcons() {
  // Update menubar icons (Veil theme)
  const systemIcon = document.getElementById('system-icon');
  if (systemIcon) systemIcon.innerHTML = getIcon('system');
  const statusEye = document.getElementById('status-eye');
  if (statusEye) statusEye.innerHTML = getIcon('eye');
  const statusShadow = document.getElementById('status-shadow');
  if (statusShadow) statusShadow.innerHTML = getIcon('shadow');

  // Update start menu icons
  const authEl = document.getElementById('start-menu-auth');
  if (authEl && sessionToken) {
    authEl.querySelector('span').innerHTML = getIcon('logout');
  } else if (authEl) {
    authEl.querySelector('span').innerHTML = getIcon('login');
  }
  // Update other static menu items
  document.querySelectorAll('#start-menu .start-items > .start-item').forEach(item => {
    const text = item.textContent.trim();
    if (text.includes('Programs')) item.querySelector('span').innerHTML = getIcon('programs');
    else if (text.includes('Documentation')) item.querySelector('span').innerHTML = getIcon('documentation');
    else if (text.includes('Help')) item.querySelector('span').innerHTML = getIcon('help');
    else if (text.includes('About')) item.querySelector('span').innerHTML = getIcon('about');
    else if (text.includes('Settings')) item.querySelector('span').innerHTML = getIcon('settings');
  });
}

// Expose for Icons app
window.ICON_DEFS = ICON_DEFS;
window.customIcons = customIcons;
window.getIcon = getIcon;
window.setCustomIcon = setCustomIcon;

// Expose key state on window for dynamically loaded apps (Studio, etc.)
Object.defineProperty(window, 'savedFiles', { get: () => savedFiles, set: v => savedFiles = v });
Object.defineProperty(window, 'windows', { get: () => windows });
Object.defineProperty(window, 'systemApps', { get: () => systemApps });

// ==================== FILE API ====================
// Desktop files now live on disk at ~/

async function fetchDesktopFiles(path = '~/') {
  if (!sessionToken) return [];
  try {
    const res = await fetch(API_BASE + '/files/list?path=' + encodeURIComponent(path), {
      headers: { 'Authorization': 'Bearer ' + sessionToken }
    });
    if (!res.ok) return [];
    const data = await res.json();
    // Return both files and directories, sorted: folders first, then files
    const basePath = path.endsWith('/') ? path : path + '/';
    const items = (data.files || []).map(f => ({
      name: f.name,
      path: basePath + f.name,
      size: f.size,
      modified: f.modified,
      isDir: f.type === 'directory',
      type: 'disk'
    }));
    return items.sort((a, b) => {
      if (a.isDir !== b.isDir) return a.isDir ? -1 : 1;
      return a.name.localeCompare(b.name);
    });
  } catch (e) {
    console.error('Failed to fetch files:', e);
    return [];
  }
}

async function saveFileToDisk(name, content) {
  if (!sessionToken) { algoSpeak('Not logged in'); return false; }
  try {
    const res = await fetch(API_BASE + '/files/save', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': 'Bearer ' + sessionToken
      },
      body: JSON.stringify({ path: '~/' + name, content: content })
    });
    return res.ok;
  } catch (e) {
    console.error('Failed to save file:', e);
    return false;
  }
}

async function getFileFromDisk(path) {
  if (!sessionToken) return null;
  try {
    const res = await fetch(API_BASE + '/files/get?path=' + encodeURIComponent(path), {
      headers: { 'Authorization': 'Bearer ' + sessionToken }
    });
    if (!res.ok) return null;
    const data = await res.json();
    return data.content;
  } catch (e) {
    console.error('Failed to get file:', e);
    return null;
  }
}

async function deleteFileFromDisk(path) {
  if (!sessionToken) return false;
  try {
    const res = await fetch(API_BASE + '/files/delete', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': 'Bearer ' + sessionToken
      },
      body: JSON.stringify({ path: path })
    });
    return res.ok;
  } catch (e) {
    console.error('Failed to delete file:', e);
    return false;
  }
}

// File type registry
let fileTypeRegistry = {
  'txt': { icon: 'ğŸ“„', app: 'Notepad' },
  'js': { icon: 'ğŸ’»', app: 'javascript.ide' },
  'html': { icon: 'ğŸŒ', app: 'Browser' },
  'json': { icon: 'ğŸ“‹', app: 'Notepad' },
  'md': { icon: 'ğŸ“', app: 'Notepad' },
  'png': { icon: 'ğŸ–¼ï¸', app: 'Image Viewer' },
  'jpg': { icon: 'ğŸ–¼ï¸', app: 'Image Viewer' },
  'gif': { icon: 'ğŸ–¼ï¸', app: 'Image Viewer' }
};

// ==================== PUBSUB ====================
// Inter-app communication system
const ALGO = window.ALGO || {};
ALGO.pubsub = {
  subscribers: {},      // topic -> [callback, ...]
  queues: {},          // topic -> [messages waiting for subscriber]
  appRegistry: {},     // appName -> { autoOpen: bool, openFn: fn }

  // Register an app with the pubsub system
  register: function(appName, options = {}) {
    this.appRegistry[appName] = {
      autoOpen: options.autoOpen || false,
      openFn: options.openFn || null,
      running: true
    };
    // Deliver any queued messages
    if (this.queues[appName] && this.queues[appName].length > 0) {
      const queue = this.queues[appName];
      this.queues[appName] = [];
      queue.forEach(item => this.publish(appName, item.msg, item.options, item.from));
    }
  },

  // Unregister when app closes
  unregister: function(appName) {
    if (this.appRegistry[appName]) {
      this.appRegistry[appName].running = false;
    }
  },

  // Subscribe to messages for a topic
  subscribe: function(topic, callback) {
    if (!this.subscribers[topic]) {
      this.subscribers[topic] = [];
    }
    this.subscribers[topic].push(callback);
    return () => {
      this.subscribers[topic] = this.subscribers[topic].filter(cb => cb !== callback);
    };
  },

  // Publish a message to a topic
  publish: function(topic, msg, options = {}, from = null) {
    const { autoOpen = false, queue = true, timeout = 5000 } = options;

    const callbacks = this.subscribers[topic] || [];
    const app = this.appRegistry[topic];

    // If no subscribers and app not running
    if (callbacks.length === 0 && (!app || !app.running)) {
      // Try to auto-open the app
      if (autoOpen && app && app.openFn) {
        app.openFn();
        // Queue message to be delivered after app opens
        if (!this.queues[topic]) this.queues[topic] = [];
        this.queues[topic].push({ msg, options, from, timestamp: Date.now() });
        return { status: 'queued', reason: 'app opening' };
      }
      // Queue for later if requested
      if (queue) {
        if (!this.queues[topic]) this.queues[topic] = [];
        this.queues[topic].push({ msg, options, from, timestamp: Date.now() });
        // Clean old messages after timeout
        setTimeout(() => {
          if (this.queues[topic]) {
            this.queues[topic] = this.queues[topic].filter(m => Date.now() - m.timestamp < timeout);
          }
        }, timeout);
        return { status: 'queued', reason: 'no subscribers' };
      }
      return { status: 'dropped', reason: 'no subscribers' };
    }

    // Deliver to all subscribers
    callbacks.forEach(cb => {
      try {
        cb(msg, from);
      } catch (e) {
        console.error('Pubsub callback error:', e);
      }
    });

    return { status: 'delivered', count: callbacks.length };
  },

  // Request-response pattern
  request: function(topic, msg, options = {}) {
    return new Promise((resolve, reject) => {
      const timeout = options.timeout || 5000;
      const requestId = Date.now() + '-' + Math.random().toString(36).substr(2, 9);
      const responseTopic = '_response_' + requestId;

      const timer = setTimeout(() => {
        unsubscribe();
        reject(new Error('Request timeout'));
      }, timeout);

      const unsubscribe = this.subscribe(responseTopic, (response) => {
        clearTimeout(timer);
        unsubscribe();
        resolve(response);
      });

      this.publish(topic, { ...msg, _requestId: requestId, _responseTopic: responseTopic }, options);
    });
  },

  // Respond to a request
  respond: function(originalMsg, response) {
    if (originalMsg._responseTopic) {
      this.publish(originalMsg._responseTopic, response);
    }
  }
};

// ==================== BRIDGE ====================
// Direct JS VM access for terminal-based agents (Claude Code)
ALGO.bridge = {
  // Execute JavaScript code and return result
  eval: function(code) {
    try {
      const result = eval(code);
      // Handle non-serializable results
      if (result === undefined) {
        return { success: true, result: null, type: 'undefined' };
      }
      if (typeof result === 'function') {
        return { success: true, result: result.toString(), type: 'function' };
      }
      if (result instanceof Element) {
        return { success: true, result: result.outerHTML.substring(0, 1000), type: 'element' };
      }
      if (result instanceof NodeList || result instanceof HTMLCollection) {
        return { success: true, result: Array.from(result).map(e => e.outerHTML?.substring(0, 200) || String(e)), type: 'nodelist' };
      }
      return { success: true, result: result, type: typeof result };
    } catch(e) {
      return { success: false, error: e.message, stack: e.stack };
    }
  },

  // Query the DOM
  query: function(selector) {
    try {
      const el = document.querySelector(selector);
      if (!el) return { success: true, result: null };
      return {
        success: true,
        result: {
          tag: el.tagName,
          id: el.id,
          className: el.className,
          text: el.textContent?.substring(0, 500),
          html: el.outerHTML?.substring(0, 1000),
          rect: el.getBoundingClientRect()
        }
      };
    } catch(e) {
      return { success: false, error: e.message };
    }
  },

  // Query multiple elements
  queryAll: function(selector) {
    try {
      const els = document.querySelectorAll(selector);
      return {
        success: true,
        count: els.length,
        result: Array.from(els).slice(0, 50).map(el => ({
          tag: el.tagName,
          id: el.id,
          className: el.className,
          text: el.textContent?.substring(0, 100)
        }))
      };
    } catch(e) {
      return { success: false, error: e.message };
    }
  },

  // Get current state of the OS
  getState: function() {
    return {
      success: true,
      result: {
        user: currentUser,
        windows: windows.map(w => ({ id: w.id, title: w.title, minimized: w.minimized })),
        activeWindow: activeWin,
        systemApps: systemApps.map(a => ({ id: a.id, name: a.name, icon: a.icon })),
        pubsubApps: Object.keys(ALGO.pubsub.appRegistry).filter(k => ALGO.pubsub.appRegistry[k].running)
      }
    };
  },

  // Click an element
  click: function(selector) {
    try {
      const el = document.querySelector(selector);
      if (!el) return { success: false, error: 'Element not found: ' + selector };
      el.click();
      return { success: true, clicked: selector };
    } catch(e) {
      return { success: false, error: e.message };
    }
  },

  // Set value of an input
  setValue: function(selector, value) {
    try {
      const el = document.querySelector(selector);
      if (!el) return { success: false, error: 'Element not found: ' + selector };
      el.value = value;
      el.dispatchEvent(new Event('input', { bubbles: true }));
      el.dispatchEvent(new Event('change', { bubbles: true }));
      return { success: true, selector, value };
    } catch(e) {
      return { success: false, error: e.message };
    }
  },

  // Open an app by ID or name
  openApp: function(appIdOrName) {
    try {
      // Match by id, name, or case-insensitive name
      const app = systemApps.find(a =>
        a.id === appIdOrName ||
        a.name === appIdOrName ||
        a.name.toLowerCase() === appIdOrName.toLowerCase() ||
        a.id.toLowerCase() === appIdOrName.toLowerCase()
      );
      if (app) {
        runSystemApp(app.id);
        return { success: true, opened: app.id, name: app.name };
      }
      return { success: false, error: 'App not found: ' + appIdOrName };
    } catch(e) {
      return { success: false, error: e.message };
    }
  },

  // Focus a window by ID
  focusWindow: function(winId) {
    try {
      focusWindow(winId);
      return { success: true, focused: winId };
    } catch(e) {
      return { success: false, error: e.message };
    }
  },

  // Close a window by ID
  closeWindow: function(winId) {
    try {
      closeWindow(winId);
      return { success: true, closed: winId };
    } catch(e) {
      return { success: false, error: e.message };
    }
  }
};

// ==================== DOCK MANAGER ====================
// Central orchestration for dockable app instances (Ivory keyboards, etc.)
ALGO.dockManager = {
  docks: new Map(),  // id -> { element, height, compactHeight, order, compact, visible, onResize }
  nextId: 0,
  reservedHeight: 0,

  // Register a dock element with the manager
  register: function(element, options = {}) {
    const id = 'dock-' + this.nextId++;
    const dock = {
      id: id,
      element: element,
      height: options.height || 150,
      compactHeight: options.compactHeight || 80,
      order: this.docks.size,
      compact: false,
      visible: true,
      onResize: options.onResize || null
    };
    this.docks.set(id, dock);
    element.dataset.dockId = id;
    this.repositionAll();
    return id;
  },

  // Unregister and remove a dock
  unregister: function(id) {
    const dock = this.docks.get(id);
    if (dock) {
      if (dock.element && dock.element.parentNode) {
        dock.element.parentNode.removeChild(dock.element);
      }
      this.docks.delete(id);
      // Reorder remaining docks
      let order = 0;
      this.docks.forEach(d => { d.order = order++; });
      this.repositionAll();
    }
  },

  // Toggle compact mode for a dock
  setCompact: function(id, isCompact) {
    const dock = this.docks.get(id);
    if (!dock) return;
    dock.compact = isCompact;
    const height = isCompact ? dock.compactHeight : dock.height;
    dock.element.style.height = height + 'px';
    dock.element.classList.toggle('compact', isCompact);
    if (dock.onResize) {
      dock.onResize(height, isCompact);
    }
    this.repositionAll();
  },

  // Toggle visibility of a dock
  setVisible: function(id, visible) {
    const dock = this.docks.get(id);
    if (!dock) return;
    dock.visible = visible;
    dock.element.style.display = visible ? 'flex' : 'none';
    this.repositionAll();
  },

  // Reposition all docks from bottom up
  repositionAll: function() {
    // Sort by order
    const sorted = Array.from(this.docks.values())
      .filter(d => d.visible)
      .sort((a, b) => a.order - b.order);

    let bottom = 0;
    sorted.forEach(dock => {
      const height = dock.compact ? dock.compactHeight : dock.height;
      dock.element.style.bottom = bottom + 'px';
      bottom += height;
    });

    // Update CSS variable for desktop/window constraints
    this.reservedHeight = bottom;
    document.documentElement.style.setProperty('--dock-reserved-height', bottom + 'px');

    // Dispatch event for other components to react
    window.dispatchEvent(new CustomEvent('dockResize', { detail: { height: bottom } }));
  },

  // Get total height of all visible docks
  getTotalHeight: function() {
    return this.reservedHeight;
  },

  // Get dock by ID
  get: function(id) {
    return this.docks.get(id);
  },

  // Get all dock IDs
  getAll: function() {
    return Array.from(this.docks.keys());
  }
};

// ==================== LENS ====================
// Token-efficient API for AI agents
ALGO.lens = {
  // Persistent helper registry
  helpers: {},

  // Define a reusable helper function
  define: function(name, fn) {
    if (typeof fn === 'string') {
      this.helpers[name] = new Function('return ' + fn)();
    } else {
      this.helpers[name] = fn;
    }
    return 'âœ“ ' + name;
  },

  // Call a defined helper
  call: function(name, ...args) {
    if (!this.helpers[name]) return 'âœ— ' + name + ' not defined';
    try {
      return this.helpers[name](...args);
    } catch(e) {
      return 'âœ— ' + e.message;
    }
  },

  // Compact state query - one line output
  state: function() {
    const w = windows.filter(w => !w.minimized).map(w => w.title?.substring(0,12) || w.appName).join('|');
    const errs = document.querySelectorAll('.error:not(:empty), [class*="error"]:not(:empty)').length;
    return `w:${w || 'none'} e:${errs} u:${currentUser || 'guest'}`;
  },

  // Dashboard - compact status
  dash: function() {
    const wins = windows.map(w => (w.minimized ? '(' : '') + (w.title?.substring(0,8) || w.appName) + (w.minimized ? ')' : '')).join('|');
    const apps = systemApps.slice(0, 5).map(a => a.icon).join('');
    return `[${wins || 'desktop'}] ${apps}`;
  },

  // Render DOM to text grid with coordinates
  look: function(selector, opts = {}) {
    const el = document.querySelector(selector || 'body');
    if (!el) return 'âœ— not found: ' + selector;

    const width = opts.width || 60;
    const height = opts.height || 20;
    const rect = el.getBoundingClientRect();

    // Gather interactive elements
    const interactive = el.querySelectorAll('button, a, input, [onclick], [role="button"], .clickable');
    const items = [];

    interactive.forEach((e, i) => {
      const r = e.getBoundingClientRect();
      const x = Math.floor((r.left - rect.left) / rect.width * width);
      const y = Math.floor((r.top - rect.top) / rect.height * height);
      const text = (e.textContent || e.value || e.placeholder || e.title || '').trim().substring(0, 20);
      if (text && x >= 0 && x < width && y >= 0 && y < height) {
        items.push({ x, y, text, tag: e.tagName, el: e });
      }
    });

    // Build grid
    const grid = Array(height).fill(null).map(() => Array(width).fill(' '));
    items.forEach(item => {
      for (let i = 0; i < item.text.length && item.x + i < width; i++) {
        grid[item.y][item.x + i] = item.text[i];
      }
    });

    // Format with row numbers
    let out = items.length + ' elements\n';
    out += '  ' + '0123456789'.repeat(Math.ceil(width / 10)).substring(0, width) + '\n';
    grid.forEach((row, i) => {
      out += String(i).padStart(2) + 'â”‚' + row.join('') + '\n';
    });

    // Store for inspect()
    this._lastLook = { selector, items, rect };
    return out;
  },

  // Inspect what's at a position (row, col) from last look()
  at: function(row, col) {
    if (!this._lastLook) return 'âœ— call look() first';

    const { items } = this._lastLook;
    const found = items.filter(item => {
      return item.y === row && col >= item.x && col < item.x + item.text.length;
    });

    if (found.length === 0) return '(empty)';

    return found.map(item => {
      const el = item.el;
      const actions = [];
      if (el.onclick || el.tagName === 'BUTTON' || el.tagName === 'A') actions.push('click');
      if (el.tagName === 'INPUT') actions.push('type');
      if (el.href) actions.push('href:' + el.href.substring(0, 30));

      return `${item.tag}:"${item.text}" [${actions.join(',')}]`;
    }).join(' | ');
  },

  // Click at position from last look()
  click: function(row, col) {
    if (!this._lastLook) return 'âœ— call look() first';

    const { items } = this._lastLook;
    const found = items.find(item => {
      return item.y === row && col >= item.x && col < item.x + item.text.length;
    });

    if (!found) return 'âœ— nothing at ' + row + ',' + col;

    found.el.click();
    return 'âœ“ clicked "' + found.text + '"';
  },

  // Batch operations - run multiple lens commands
  batch: function(ops) {
    const results = [];
    for (const op of ops) {
      const [method, ...args] = op;
      if (typeof this[method] === 'function') {
        results.push('âœ“' + method);
        this[method](...args);
      } else if (this.helpers[method]) {
        results.push('âœ“' + method);
        this.helpers[method](...args);
      } else {
        results.push('âœ—' + method);
      }
    }
    return results.join(' ');
  },

  // Get all interactive elements in a selector
  actions: function(selector) {
    const el = document.querySelector(selector || 'body');
    if (!el) return 'âœ— not found';

    const interactive = el.querySelectorAll('button, a, input, select, textarea, [onclick], [role="button"]');
    const actions = [];

    interactive.forEach((e, i) => {
      const text = (e.textContent || e.value || e.placeholder || e.title || e.className || '').trim().substring(0, 25);
      if (text) {
        const type = e.tagName === 'INPUT' ? e.type : e.tagName.toLowerCase();
        actions.push(`${i}:${type}:"${text}"`);
      }
    });

    return actions.slice(0, 30).join('\n') || '(no actions)';
  },

  // Execute action by index from actions() output
  do: function(selector, index) {
    const el = document.querySelector(selector || 'body');
    if (!el) return 'âœ— not found';

    const interactive = el.querySelectorAll('button, a, input, select, textarea, [onclick], [role="button"]');
    if (index >= interactive.length) return 'âœ— index out of range';

    const target = interactive[index];
    if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA') {
      target.focus();
      return 'âœ“ focused';
    }
    target.click();
    return 'âœ“ clicked';
  },

  // === GIT SHORTCUTS (use ALGO.exec, work without Studio) ===

  // Get project root from a file path
  _projectRoot: function(path) {
    if (!path) return null;
    const match = path.match(/~\/repos\/([^\/]+)/);
    return match ? '~/repos/' + match[1] : null;
  },

  // Git commit with message
  commit: async function(msg, path) {
    const root = this._projectRoot(path) || (typeof Studio !== 'undefined' && Studio.getTabs?.()[0] ? this._projectRoot(Studio.getTabs()[0]) : null);
    if (!root) return 'âœ— no project detected';
    if (!msg) return 'âœ— provide commit message';
    const result = await ALGO.exec('git -C ' + root + ' add -A && git -C ' + root + ' commit -m "' + msg.replace(/"/g, '\\"') + '"');
    return result.includes('nothing to commit') ? 'âœ“ nothing to commit' : 'âœ“ committed';
  },

  // Git push to origin
  push: async function(path) {
    const root = this._projectRoot(path) || (typeof Studio !== 'undefined' && Studio.getTabs?.()[0] ? this._projectRoot(Studio.getTabs()[0]) : null);
    if (!root) return 'âœ— no project detected';
    if (!ALGO.github.isConfigured()) return 'âœ— GitHub not configured';
    const result = await ALGO.exec('git -C ' + root + ' push origin HEAD 2>&1');
    return result.includes('->') ? 'âœ“ pushed' : result.includes('up-to-date') ? 'âœ“ up-to-date' : 'âœ— ' + result.slice(0, 100);
  },

  // Git diff - show uncommitted changes
  diff: async function(path) {
    const root = this._projectRoot(path) || (typeof Studio !== 'undefined' && Studio.getTabs?.()[0] ? this._projectRoot(Studio.getTabs()[0]) : null);
    if (!root) return 'âœ— no project detected';
    const result = await ALGO.exec('git -C ' + root + ' diff --stat');
    return result.trim() || '(no changes)';
  },

  // Git status - short format
  gitStatus: async function(path) {
    const root = this._projectRoot(path) || (typeof Studio !== 'undefined' && Studio.getTabs?.()[0] ? this._projectRoot(Studio.getTabs()[0]) : null);
    if (!root) return 'âœ— no project detected';
    const result = await ALGO.exec('git -C ' + root + ' status -s');
    return result.trim() || '(clean)';
  },

  // Git log - recent commits
  log: async function(n = 5, path) {
    const root = this._projectRoot(path) || (typeof Studio !== 'undefined' && Studio.getTabs?.()[0] ? this._projectRoot(Studio.getTabs()[0]) : null);
    if (!root) return 'âœ— no project detected';
    return await ALGO.exec('git -C ' + root + ' log --oneline -' + n);
  },

  // Create new project (wraps setupHappyPath)
  project: async function(name) {
    if (!name) return 'âœ— provide project name';
    const result = await setupHappyPath(name);
    const slug = name.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '');
    return ALGO.github.isConfigured() ? 'âœ“ ' + slug + ' â†’ github' : 'âœ“ ' + slug;
  },

  // Help - list available Lens commands
  help: function() {
    return [
      'Lens.grep(pattern)     - Find in code',
      'Lens.code()            - View with line numbers',
      'Lens.line(n, count)    - Get line(s)',
      'Lens.setLine(n, code)  - Replace line',
      'Lens.insertLine(n, code) - Insert at line',
      'Lens.deleteLine(n)     - Delete line',
      'Lens.save()            - Save file',
      'Lens.run()             - Run code',
      'Lens.commit(msg)       - Git commit',
      'Lens.push()            - Push to GitHub',
      'Lens.diff()            - Show changes',
      'Lens.gitStatus()       - Git status',
      'Lens.log(n)            - Recent commits',
      'Lens.project(name)     - Create new project'
    ].join('\n');
  }
};
window.Lens = ALGO.lens;

window.ALGO = ALGO;

// ==================== AI EYES ====================
// Visual feedback for AI actions - shows humans what AI is looking at/editing
// Effects are silent side-effects, don't pollute return values
ALGO.eyes = {
  _initialized: false,
  _init() {
    if (this._initialized) return;
    const style = document.createElement('style');
    style.id = 'ai-eyes-styles';
    style.textContent = `
      @keyframes ai-saccade { 0% { opacity: 0; } 20% { opacity: 0.35; } 100% { opacity: 0; } }
      @keyframes ai-edit { 0% { box-shadow: inset 0 0 0 2px rgba(100,255,100,0.5); } 100% { box-shadow: none; } }
      @keyframes ai-delete { 0% { opacity: 0.8; transform: translateX(0); } 100% { opacity: 0; transform: translateX(20px); } }
      .ai-eye-box { position: fixed; pointer-events: none; border: 2px solid rgba(167,139,250,0.5); border-radius: 3px; animation: ai-saccade 0.5s ease-out forwards; z-index: 99999; }
      .ai-eye-edit { animation: ai-edit 0.4s ease-out forwards !important; }
      .ai-eye-ghost { position: fixed; pointer-events: none; animation: ai-delete 0.3s ease-out forwards; z-index: 99999; background: rgba(255,100,100,0.15); border-radius: 2px; }
    `;
    document.head.appendChild(style);
    this._initialized = true;
  },

  // Silent highlight - fire and forget
  look(el) {
    this._init();
    if (typeof el === 'string') el = document.querySelector(el);
    if (!el) return;
    const r = el.getBoundingClientRect();
    const box = document.createElement('div');
    box.className = 'ai-eye-box';
    box.style.cssText = `left:${r.left}px;top:${r.top}px;width:${r.width}px;height:${r.height}px`;
    document.body.appendChild(box);
    setTimeout(() => box.remove(), 500);
  },

  // Silent edit flash
  edit(el) {
    this._init();
    if (typeof el === 'string') el = document.querySelector(el);
    if (!el) return;
    el.classList.add('ai-eye-edit');
    setTimeout(() => el.classList.remove('ai-eye-edit'), 400);
  },

  // Silent delete ghost
  evaporate(el) {
    this._init();
    if (typeof el === 'string') el = document.querySelector(el);
    if (!el) return;
    const r = el.getBoundingClientRect();
    const ghost = document.createElement('div');
    ghost.className = 'ai-eye-ghost';
    ghost.style.cssText = `left:${r.left}px;top:${r.top}px;width:${r.width}px;height:${r.height}px`;
    document.body.appendChild(ghost);
    setTimeout(() => ghost.remove(), 300);
  },

  // Highlight editor region by line range
  codeRegion(startLine, count) {
    this._init();
    const ta = document.querySelector('#studio-code');
    if (!ta) return;
    const r = ta.getBoundingClientRect();
    const lineHeight = parseFloat(getComputedStyle(ta).lineHeight) || 18;
    const top = r.top + (startLine - 1) * lineHeight;
    const height = Math.min(count * lineHeight, r.height);
    const box = document.createElement('div');
    box.className = 'ai-eye-box';
    box.style.cssText = `left:${r.left}px;top:${Math.max(r.top, top)}px;width:${r.width}px;height:${height}px`;
    document.body.appendChild(box);
    setTimeout(() => box.remove(), 500);
  },

  // Wrap Lens functions to add visual feedback (called after Studio loads)
  wrapLens() {
    if (!Lens.code || Lens._eyesWrapped) return;
    const wrap = (name, before, after) => {
      const orig = Lens[name]?.bind(Lens);
      if (orig) Lens[name] = function(...args) {
        if (before) before(...args);
        const result = orig(...args);
        if (after) Promise.resolve(result).then(r => after(r, ...args));
        return result;
      };
    };
    wrap('code', (s, n) => this.codeRegion(s || 1, n || 20));
    wrap('setLine', (n) => this.codeRegion(n, 1), () => this.edit(document.querySelector('#studio-code')));
    wrap('insertLine', (n) => this.codeRegion(n, 1));
    wrap('deleteLine', (n) => this.codeRegion(n, 1));
    Lens._eyesWrapped = true;
  }
};

// Eye shortcuts - terse helpers for eye CLI
window.$ = s => document.querySelector(s);
window.$$ = s => [...document.querySelectorAll(s)];
window.apps = () => systemApps.map(a => a.name);
window.wins = () => windows.map(w => ({id: w.id, title: w.title, app: w.appName}));

// ==================== CORE UTILITIES ====================
// Shell execution - available without loading Studio
ALGO.exec = async function(cmd) {
  if (!sessionToken) return 'Error: Not logged in';
  try {
    const r = await fetch(API_BASE + '/terminal/exec', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', 'Authorization': 'Bearer ' + sessionToken },
      body: JSON.stringify({ command: cmd, cwd: '~' })
    });
    if (r.ok) {
      const data = await r.json();
      return data.output || data.error || '';
    }
    return 'Request failed: ' + r.status;
  } catch(e) { return 'Error: ' + e.message; }
};

// GitHub auth - read token from localStorage without loading github-auth.js
ALGO.github = {
  STORAGE_KEY: 'fs_github_auth',
  _load() { try { return JSON.parse(localStorage.getItem(this.STORAGE_KEY)) || {}; } catch { return {}; } },
  _save(auth) { localStorage.setItem(this.STORAGE_KEY, JSON.stringify(auth)); },
  getToken() { return this._load().token || null; },
  getUsername() { return this._load().username || null; },
  isConfigured() { const a = this._load(); return !!(a.token && a.username); },
  getAuthUrl(repoUrl) {
    const token = this.getToken();
    if (!token) return repoUrl;
    const m = repoUrl.match(/git@github\.com:(.+)\.git/);
    if (m) return 'https://' + token + '@github.com/' + m[1] + '.git';
    const h = repoUrl.match(/https:\/\/github\.com\/(.+)/);
    if (h) return 'https://' + token + '@github.com/' + h[1];
    return repoUrl;
  }
};

// setupHappyPath - one-command project creation, available globally
window.setupHappyPath = async function(projectName) {
  // Load Studio if needed
  if (typeof Studio === 'undefined') {
    const code = await getFileFromDisk('~/studio.js');
    if (code) await runApp(code, 'studio.js');
  }

  // If no project name, just load tools
  if (!projectName) {
    console.log('Tools loaded. Use Lens.help() for commands.');
    return 'Happy path ready!';
  }

  // Slugify: "pixel draw" -> "pixel-draw"
  const slug = projectName.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '');
  const repoPath = '~/repos/' + slug;

  // Check if exists
  const exists = await ALGO.exec('ls ' + repoPath + ' 2>/dev/null && echo yes || echo no');

  if (exists.trim() === 'no') {
    console.log('Creating new project: ' + slug);

    // Create folder and init
    await ALGO.exec('mkdir -p ' + repoPath);
    await ALGO.exec('git -C ' + repoPath + ' init');

    // Create skeleton files
    const appCode = '// ' + projectName + '\nALGO.app.name = "' + projectName + '";\nALGO.app.icon = "*";\n\nALGO.createWindow({\n  title: "' + projectName + '",\n  width: 400,\n  height: 300,\n  content: "<div style=\'padding:20px\'>Hello from ' + projectName + '!</div>"\n});';
    const readmeCode = '# ' + projectName + '\n\nA FunctionServer app.\n\n## Run\n\nOpen main.js in Studio and use Lens.run()';

    await saveFileToDisk('repos/' + slug + '/main.js', appCode);
    await saveFileToDisk('repos/' + slug + '/README.md', readmeCode);

    // Initial commit
    await ALGO.exec('git -C ' + repoPath + ' add -A');
    await ALGO.exec('git -C ' + repoPath + ' commit -m "Initial commit: ' + projectName + ' skeleton"');

    // If GitHub configured, create repo and push
    if (ALGO.github.isConfigured()) {
      const username = ALGO.github.getUsername();
      const token = ALGO.github.getToken();
      console.log('Creating GitHub repo: ' + username + '/' + slug);

      await ALGO.exec('curl -s -X POST -H "Authorization: token ' + token + '" -H "Accept: application/vnd.github.v3+json" https://api.github.com/user/repos -d \'{"name":"' + slug + '","private":false}\'');

      const remoteUrl = 'https://' + token + '@github.com/' + username + '/' + slug + '.git';
      await ALGO.exec('git -C ' + repoPath + ' remote add origin ' + remoteUrl);
      await ALGO.exec('git -C ' + repoPath + ' push -u origin master 2>&1 || git -C ' + repoPath + ' push -u origin main 2>&1');
      console.log('Pushed to GitHub: github.com/' + username + '/' + slug);
    } else {
      console.log('GitHub not configured. Use GitHub Auth app to enable push.');
    }
  } else {
    console.log('Opening existing project: ' + slug);
  }

  // Open in Studio - find main file for existing projects
  if (typeof Studio !== 'undefined') {
    let mainFile = repoPath + '/main.js';

    // For existing projects, find the first .js file if main.js doesn't exist
    const files = await ALGO.exec('ls ' + repoPath + '/*.js 2>/dev/null');
    if (files.trim()) {
      const jsFiles = files.trim().split('\n').filter(f => !f.includes('node_modules'));
      if (jsFiles.length > 0) {
        // Prefer main.js, index.js, app.js, or first found
        const basename = f => f.split('/').pop();
        const preferred = jsFiles.find(f => ['main.js', 'index.js', 'app.js'].includes(basename(f)));
        mainFile = preferred || jsFiles[0];
        // Convert full path to ~/repos/... format
        mainFile = mainFile.replace(/^\/home\/[^\/]+\//, '~/');
      }
    }

    Studio.close(mainFile);
    Studio.open(mainFile);
  }
  return 'Project ready: ' + slug;
};

// ==================== GUARDIAN - Console Monitor ====================
// Watches for errors/warnings, offers AI help with throttling
ALGO.guardian = {
  _watching: false,
  _callback: null,
  _throttleMs: 2000,
  _lastSent: 0,
  _lastMsg: '',
  _suppressedCount: 0,
  _origError: null,
  _origWarn: null,
  _origOnError: null,

  watch(callback) {
    if (this._watching) return 'Already watching';
    this._watching = true;
    this._callback = callback;
    this._suppressedCount = 0;

    // Store originals
    this._origError = console.error;
    this._origWarn = console.warn;
    this._origOnError = window.onerror;

    const self = this;

    // Hook console.error
    console.error = function(...args) {
      self._origError.apply(console, args);
      self._onMessage('error', args.map(a => String(a)).join(' '));
    };

    // Hook console.warn
    console.warn = function(...args) {
      self._origWarn.apply(console, args);
      self._onMessage('warn', args.map(a => String(a)).join(' '));
    };

    // Hook window.onerror
    window.onerror = function(msg, src, line, col, err) {
      if (self._origOnError) self._origOnError(msg, src, line, col, err);
      self._onMessage('error', msg + (src ? ' at ' + src + ':' + line : ''));
    };

    return 'Guardian watching';
  },

  _onMessage(level, msg) {
    const now = Date.now();

    // Dedupe: skip if same message within throttle window
    if (msg === this._lastMsg && now - this._lastSent < this._throttleMs) {
      this._suppressedCount++;
      return;
    }

    // Throttle: skip if too soon
    if (now - this._lastSent < this._throttleMs) {
      this._suppressedCount++;
      return;
    }

    this._lastSent = now;
    this._lastMsg = msg;

    // Call callback if provided
    if (this._callback) {
      const suppressed = this._suppressedCount;
      this._suppressedCount = 0;
      this._callback({ level, msg, suppressed });
    }

    // Show help toast for errors
    if (level === 'error') {
      this._offerHelp(msg);
    }
  },

  _offerHelp(errorMsg) {
    // Create toast
    const toast = document.createElement('div');
    toast.className = 'guardian-toast';
    toast.innerHTML =
      '<div style="font-weight:500;color:#f87171;">Error detected</div>' +
      '<div style="font-size:12px;color:#a1a1aa;margin:6px 0;max-height:60px;overflow:hidden;text-overflow:ellipsis;">' +
        errorMsg.slice(0, 150) + (errorMsg.length > 150 ? '...' : '') +
      '</div>' +
      '<div style="display:flex;gap:8px;margin-top:8px;">' +
        '<button onclick="ALGO.guardian._acceptHelp(this.closest(\'.guardian-toast\'))" style="flex:1;padding:6px 12px;background:#3b82f6;border:none;border-radius:4px;color:#fff;cursor:pointer;font-size:12px;">Get AI help</button>' +
        '<button onclick="this.closest(\'.guardian-toast\').remove()" style="padding:6px 12px;background:#27272a;border:1px solid #3f3f46;border-radius:4px;color:#a1a1aa;cursor:pointer;font-size:12px;">Dismiss</button>' +
      '</div>';
    toast.style.cssText = 'position:fixed;bottom:60px;right:20px;background:#18181b;border:1px solid #3f3f46;border-radius:8px;padding:12px 16px;width:300px;z-index:10001;box-shadow:0 4px 12px rgba(0,0,0,0.4);font:14px system-ui;color:#fafafa;animation:guardian-slide-in 0.3s ease-out;';

    // Add animation style if not present
    if (!document.getElementById('guardian-styles')) {
      const style = document.createElement('style');
      style.id = 'guardian-styles';
      style.textContent = '@keyframes guardian-slide-in { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } } @keyframes guardian-slide-out { from { transform: translateX(0); opacity: 1; } to { transform: translateX(100%); opacity: 0; } }';
      document.head.appendChild(style);
    }

    document.body.appendChild(toast);
    toast._errorMsg = errorMsg;

    // Auto-dismiss after 8 seconds
    setTimeout(() => {
      if (toast.parentNode) {
        toast.style.animation = 'guardian-slide-out 0.3s ease-out forwards';
        setTimeout(() => toast.remove(), 300);
      }
    }, 8000);
  },

  _acceptHelp(toast) {
    const errorMsg = toast._errorMsg;
    toast.remove();

    // Use algoSpeak to offer help (times out after 4s)
    algoSpeak('I noticed an error. Would you like me to help debug?', 4000);

    // Send to eye bridge if connected
    if (window.eyeBridge && window.eyeBridge.send) {
      window.eyeBridge.send(JSON.stringify({
        type: 'guardian',
        event: 'help_requested',
        error: errorMsg
      }));
    }
  },

  stop() {
    if (!this._watching) return 'Not watching';
    this._watching = false;

    // Restore originals
    if (this._origError) console.error = this._origError;
    if (this._origWarn) console.warn = this._origWarn;
    if (this._origOnError) window.onerror = this._origOnError;

    this._callback = null;
    return 'Guardian stopped. Suppressed ' + this._suppressedCount + ' messages.';
  },

  status() {
    return {
      watching: this._watching,
      suppressed: this._suppressedCount,
      throttleMs: this._throttleMs,
      lastMsg: this._lastMsg ? this._lastMsg.slice(0, 50) + '...' : null
    };
  }
};

// ==================== AUTH ====================
function checkSession() {
  const saved = localStorage.getItem('algo-session');
  if (saved) {
    try {
      const s = JSON.parse(saved);
      if (s.token && s.username) {
        fetch(API_BASE + '/auth/verify', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ token: s.token, username: s.username })
        }).then(r => r.json())
        .then(data => {
          if (data.valid) {
            loginSuccess(s.username, s.token, s.isSystemUser);
          } else {
            guestLogin();
          }
        }).catch(() => guestLogin());
        return;
      }
    } catch (e) {}
  }
  guestLogin();
}

function guestLogin() {
  currentUser = 'guest';
  sessionToken = null;
  hideLogin();
  document.getElementById('start-menu-auth').innerHTML = '<span>' + getIcon('login') + '</span> Login / Register';
  document.getElementById('start-menu-auth').onclick = showLogin;
  loadState();
  loadSystemApps();
  init();
  refreshAllIcons();
}

function showLogin() {
  document.getElementById('login-overlay').style.display = 'flex';
}

function hideLogin() {
  document.getElementById('login-overlay').style.display = 'none';
}

function showLoginTab(tab) {
  document.querySelectorAll('.login-dialog .tab').forEach(t => t.classList.remove('active'));
  document.querySelector('.login-dialog .tab[data-tab="' + tab + '"]').classList.add('active');
  document.getElementById('login-form').style.display = tab === 'login' ? 'block' : 'none';
  document.getElementById('register-form').style.display = tab === 'register' ? 'block' : 'none';
  document.getElementById('login-error').textContent = '';
}

let isSystemUser = false;

function loginSuccess(username, token, systemUser) {
  currentUser = username;
  sessionToken = token;
  isSystemUser = systemUser || false;
  localStorage.setItem('algo-session', JSON.stringify({ username, token, isSystemUser }));
  if (isSystemUser) localStorage.setItem('fs_system_user', 'true');
  else localStorage.removeItem('fs_system_user');
  hideLogin();
  document.getElementById('start-menu-auth').innerHTML = '<span>' + getIcon('logout') + '</span> Log Out (' + username + ')';
  loadState();
  loadSystemApps();
  init();
  refreshAllIcons();
  updateMenubarUser();
}

function copyAuthInfo(event) {
  if (event) event.stopPropagation();
  const server = window.location.origin.replace('https://', 'wss://').replace('http://', 'ws://') + '/api/eye';
  const config = JSON.stringify({ token: sessionToken, server: server }, null, 2);

  fetch('/core/apps/eye-instructions.txt').then(r => r.text()).then(template => {
    const instructions = template
      .replace('{{CONFIG}}', config)
      .replace('{{USER}}', currentUser)
      .replace('{{SERVER}}', server);
    navigator.clipboard.writeText(instructions).then(() => {
      algoSpeak('Copied eye instructions + config to clipboard');
    });
  }).catch(() => {
    // Fallback to just config if template not found
    navigator.clipboard.writeText(config).then(() => {
      algoSpeak('Copied eye config. Save to ~/.algo/config.json');
    });
  });
}

function doLogin() {
  const username = document.getElementById('login-username').value.trim();
  const password = document.getElementById('login-password').value;
  const isSystemUser = document.getElementById('login-system-user').checked;
  const error = document.getElementById('login-error');

  if (!username || !password) {
    error.textContent = 'Please enter username and password';
    return;
  }

  const endpoint = isSystemUser ? '/auth/system-login' : '/auth/login';

  fetch(API_BASE + endpoint, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ username, password })
  })
  .then(r => r.json())
  .then(data => {
    if (data.token) {
      loginSuccess(username, data.token, data.isSystemUser);
    } else {
      error.textContent = data.error || 'Login failed';
    }
  })
  .catch(e => {
    error.textContent = 'Connection error';
  });
}

function doRegister() {
  const username = document.getElementById('reg-username').value.trim();
  const password = document.getElementById('reg-password').value;
  const confirm = document.getElementById('reg-confirm').value;
  const error = document.getElementById('login-error');

  if (!username || !password) {
    error.textContent = 'Please fill all fields';
    return;
  }
  if (password !== confirm) {
    error.textContent = 'Passwords do not match';
    return;
  }

  fetch(API_BASE + '/register', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ username, password })
  })
  .then(r => r.json())
  .then(data => {
    if (data.token) {
      loginSuccess(username, data.token);
    } else {
      error.textContent = data.error || 'Registration failed';
    }
  })
  .catch(e => {
    error.textContent = 'Connection error';
  });
}

function logout() {
  hideStartMenu();
  localStorage.removeItem('algo-session');
  currentUser = null;
  sessionToken = null;
  location.reload();
}

// ==================== INIT ====================
async function init() {
  await createDesktopIcons();
  updateTaskbar();
  updateClock();
  setInterval(updateClock, 1000);
  refreshAllIcons();
  updateMenubarUser();

  // Global event listeners
  document.addEventListener('click', globalClick);
  document.addEventListener('mousemove', onDrag);
  document.addEventListener('mouseup', endDrag);
  document.addEventListener('touchmove', onDrag, { passive: false });
  document.addEventListener('touchend', endDrag);
  document.addEventListener('contextmenu', handleContextMenu);
  document.addEventListener('keydown', handleKeyDown);

  setTimeout(() => algoSpeak("Welcome to Function Server!"), 1500);

  // Restore shader background if saved
  restoreShaderBackground();

  // Connect eye bridge for Claude integration
  connectEyeBridge();
  updateEyeTray();

  // Initialize shadow bridge for browser extension support
  ShadowBridge.init();
}

function restoreShaderBackground() {
  const code = localStorage.getItem('algo-shader-bg');
  if (!code) return;

  const canvas = document.createElement('canvas');
  canvas.id = 'shader-background';
  canvas.style.cssText = 'position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:-1;pointer-events:none;';
  document.body.appendChild(canvas);

  const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
  if (!gl) return;

  const vertSource = 'attribute vec2 a_position;void main(){gl_Position=vec4(a_position,0,1);}';
  const vertShader = gl.createShader(gl.VERTEX_SHADER);
  gl.shaderSource(vertShader, vertSource);
  gl.compileShader(vertShader);

  const fragShader = gl.createShader(gl.FRAGMENT_SHADER);
  gl.shaderSource(fragShader, code);
  gl.compileShader(fragShader);
  if (!gl.getShaderParameter(fragShader, gl.COMPILE_STATUS)) { canvas.remove(); return; }

  const program = gl.createProgram();
  gl.attachShader(program, vertShader);
  gl.attachShader(program, fragShader);
  gl.linkProgram(program);
  gl.useProgram(program);

  const posBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1,1,-1,-1,1,1,1]), gl.STATIC_DRAW);
  const posLoc = gl.getAttribLocation(program, 'a_position');
  gl.enableVertexAttribArray(posLoc);
  gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

  function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; gl.viewport(0, 0, canvas.width, canvas.height); }
  resize();
  window.addEventListener('resize', resize);

  let time = 0, mouse = [0, 0];
  document.addEventListener('mousemove', (e) => { mouse = [e.clientX, window.innerHeight - e.clientY]; });

  function render() {
    if (!document.getElementById('shader-background')) return;
    time += 0.016;
    gl.clearColor(0, 0, 0, 1);
    gl.clear(gl.COLOR_BUFFER_BIT);
    const tLoc = gl.getUniformLocation(program, 'u_time');
    const rLoc = gl.getUniformLocation(program, 'u_resolution');
    const mLoc = gl.getUniformLocation(program, 'u_mouse');
    if (tLoc) gl.uniform1f(tLoc, time);
    if (rLoc) gl.uniform2f(rLoc, canvas.width, canvas.height);
    if (mLoc) gl.uniform2f(mLoc, mouse[0], mouse[1]);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    window._shaderBgAnimFrame = requestAnimationFrame(render);
  }
  render();
}

function handleKeyDown(e) {
  if (e.key === 'Escape') {
    hideStartMenu();
    hideContextMenu();
  }
}

function handleContextMenu(e) {
  // Shift+right-click or inspect passthrough: let native menu through
  if (e.shiftKey || _inspectPassthrough) {
    _inspectPassthrough = false;
    return;
  }

  // Store position for inspect fallback
  _lastContextPos = { x: e.clientX, y: e.clientY };

  const desktop = document.getElementById('desktop');

  // Check if click is inside a window - if so, don't show desktop menu
  const windowEl = e.target.closest('.window');
  if (windowEl) {
    // Apps can define their own contextmenu handler on their content
    // If they don't, we just prevent the default browser menu
    e.preventDefault();
    return;
  }

  // Only show desktop context menu when clicking on desktop itself
  if (e.target === desktop || (desktop.contains(e.target) && !e.target.closest('.window'))) {
    e.preventDefault();
    contextTarget = e.target; // Store for inspect
    showDesktopContextMenu(e);
  }
}

// ==================== DESKTOP ICONS ====================
// Desktop shows app shortcuts + navigable folder view

let desktopFiles = []; // Cache of files from disk
let desktopPath = '~'; // Current path (~ = desktop view, other = folder view)
let showHiddenFiles = false;
let showExtensions = false; // Default: hide file extensions
const ICON_GRID_SIZE = 80; // Grid cell size for icons
const ICON_COLS = 10; // Icons per row
const TOOLBAR_HEIGHT = 36; // Height of desktop toolbar

// Default desktop app icons (always shown on desktop view)
const defaultDesktopIcons = [
  { id: 'notepad', name: 'Notepad', icon: 'ğŸ“', action: 'openNotepad' },
  { id: 'jside', name: 'javascript.ide', icon: 'ğŸ’»', action: 'openJSIDE' },
  { id: 'browser', name: 'Web Browser', icon: 'ğŸŒ', action: 'openBrowser' },
  { id: 'docs', name: 'Documentation', icon: 'ğŸ“•', action: 'openDocumentation' },
  {
    id: 'home',
    name: 'Home',
    icon: {
      main: 'ğŸ“',
      sub: '~',
      pos: 'c',
      scale: 0.9,
      skewX: -8,
      offsetY: 2,
      subColor: '#fff',
      shadow: '1px 1px 3px rgba(0,0,0,0.7)'
    },
    action: 'openHomeFolder',
    isFolder: true
  },
];

function getIconPosition(index) {
  const col = index % ICON_COLS;
  const row = Math.floor(index / ICON_COLS);
  return { x: 20 + col * ICON_GRID_SIZE, y: 20 + row * ICON_GRID_SIZE };
}

function findNextEmptySlot(existingIcons) {
  const occupied = new Set(existingIcons.map(ic => `${Math.floor(ic.x / ICON_GRID_SIZE)},${Math.floor(ic.y / ICON_GRID_SIZE)}`));
  for (let i = 0; i < 100; i++) {
    const pos = getIconPosition(i);
    const key = `${Math.floor(pos.x / ICON_GRID_SIZE)},${Math.floor(pos.y / ICON_GRID_SIZE)}`;
    if (!occupied.has(key)) return pos;
  }
  return getIconPosition(existingIcons.length);
}

async function createDesktopIcons() {
  const container = document.getElementById('desktop-icons');
  if (!container) return;
  container.innerHTML = '';

  updateBreadcrumbs();

  if (desktopPath === '~') {
    // Desktop view: show app shortcuts + Home folder
    defaultDesktopIcons.forEach((ic, idx) => {
      const pos = getIconPosition(idx);
      createDesktopIcon({ ...ic, x: pos.x, y: pos.y });
    });
  } else {
    // Folder view: show folder contents
    desktopFiles = await fetchDesktopFiles(desktopPath);

    // Filter hidden files if needed
    const files = showHiddenFiles ? desktopFiles : desktopFiles.filter(f => !f.name.startsWith('.'));

    files.forEach((file, idx) => {
      const pos = getIconPosition(idx);
      createDesktopIcon({
        id: 'file-' + idx,
        name: getDisplayName(file.name, file.isDir),
        icon: file.isDir ? 'ğŸ“' : getFileIcon(file.name),
        x: pos.x,
        y: pos.y,
        action: file.isDir ? 'openFolder' : 'openDiskFile',
        filePath: file.path,
        fileName: file.name,
        isFolder: file.isDir
      });
    });
  }

  updateDesktopActions();
}

function updateBreadcrumbs() {
  const breadcrumbs = document.getElementById('desktop-breadcrumbs');
  if (!breadcrumbs) return;

  if (desktopPath === '~') {
    breadcrumbs.innerHTML = '<span class="breadcrumb active"><b style="font-size:1.2em;">~</b></span>';
    return;
  }

  // Build breadcrumb trail
  let html = '<span class="breadcrumb" onclick="navigateToPath(\'~\')"><b style="font-size:1.2em;">~</b></span>';

  if (desktopPath === '~/' || desktopPath.startsWith('~/')) {
    // Home folder path
    html += '<span class="breadcrumb-sep">â€º</span>';
    const subPath = desktopPath.slice(2); // Remove ~/
    if (!subPath) {
      html += '<span class="breadcrumb active">Home</span>';
    } else {
      html += '<span class="breadcrumb" onclick="navigateToPath(\'~/\')">Home</span>';
      const parts = subPath.split('/').filter(p => p);
      let path = '~/';
      parts.forEach((part, i) => {
        path += part;
        const isLast = i === parts.length - 1;
        html += '<span class="breadcrumb-sep">â€º</span>';
        if (isLast) {
          html += '<span class="breadcrumb active">' + escapeHtml(part) + '</span>';
        } else {
          html += '<span class="breadcrumb" onclick="navigateToPath(\'' + escapeHtml(path) + '\')">' + escapeHtml(part) + '</span>';
          path += '/';
        }
      });
    }
  } else {
    // Absolute path (shouldn't normally happen)
    const parts = desktopPath.split('/').filter(p => p);
    let path = '';
    parts.forEach((part, i) => {
      path += '/' + part;
      const isLast = i === parts.length - 1;
      html += '<span class="breadcrumb-sep">â€º</span>';
      if (isLast) {
        html += '<span class="breadcrumb active">' + escapeHtml(part) + '</span>';
      } else {
        html += '<span class="breadcrumb" onclick="navigateToPath(\'' + escapeHtml(path) + '\')">' + escapeHtml(part) + '</span>';
      }
    });
  }

  breadcrumbs.innerHTML = html;
}

function updateDesktopActions() {
  const hiddenBtn = document.querySelector('#desktop-actions .desktop-action[title="Toggle hidden files"]');
  if (hiddenBtn) {
    hiddenBtn.classList.toggle('active', showHiddenFiles);
    hiddenBtn.innerHTML = showHiddenFiles ? 'ğŸ‘' : 'ğŸ‘â€ğŸ—¨';
  }
  const extBtn = document.querySelector('#desktop-actions .desktop-action[title="Toggle file extensions"]');
  if (extBtn) {
    extBtn.classList.toggle('active', showExtensions);
    extBtn.style.opacity = showExtensions ? '1' : '0.5';
  }
}

function navigateToPath(path) {
  desktopPath = path;
  createDesktopIcons();
}

function openHomeFolder() {
  // Navigate to user's home directory (~ is resolved by backend)
  navigateToPath('~/');
}

function openFolder(path) {
  navigateToPath(path);
}

function toggleHiddenFiles() {
  showHiddenFiles = !showHiddenFiles;
  createDesktopIcons();
  algoSpeak(showHiddenFiles ? 'Showing hidden files' : 'Hiding hidden files');
}

function toggleExtensions() {
  showExtensions = !showExtensions;
  createDesktopIcons();
  algoSpeak(showExtensions ? 'Showing extensions' : 'Hiding extensions');
}

function getDisplayName(fileName, isDir) {
  // Directories always show full name
  if (isDir) return fileName;
  // If showing extensions, return full name
  if (showExtensions) return fileName;
  // Strip extension for display
  const lastDot = fileName.lastIndexOf('.');
  if (lastDot > 0) return fileName.substring(0, lastDot);
  return fileName;
}

async function createNewFolder() {
  if (desktopPath === '~') {
    algoSpeak('Navigate to a folder first');
    return;
  }

  // Find next empty slot
  const container = document.getElementById('desktop-icons');
  const existingIcons = Array.from(container.querySelectorAll('.desktop-icon')).map(el => ({
    x: parseInt(el.style.left),
    y: parseInt(el.style.top)
  }));
  const pos = findNextEmptySlot(existingIcons);

  // Create placeholder icon with editable name
  const icon = document.createElement('div');
  icon.className = 'desktop-icon new-folder';
  icon.style.left = pos.x + 'px';
  icon.style.top = pos.y + 'px';
  icon.innerHTML = '<div class="icon-img">ğŸ“</div><input type="text" class="icon-rename" value="New Folder" onkeydown="handleNewFolderKey(event, this)" onblur="cancelNewFolder(this)">';
  container.appendChild(icon);

  // Focus and select the input
  const input = icon.querySelector('input');
  input.focus();
  input.select();
}

async function handleNewFolderKey(e, input) {
  if (e.key === 'Enter') {
    e.preventDefault();
    const name = input.value.trim();
    if (!name) {
      cancelNewFolder(input);
      return;
    }

    const folderPath = desktopPath + '/' + name;
    const success = await createFolderOnDisk(folderPath);

    if (success) {
      await createDesktopIcons();
      algoSpeak('Created folder: ' + name);
    } else {
      algoSpeak('Failed to create folder');
      cancelNewFolder(input);
    }
  } else if (e.key === 'Escape') {
    cancelNewFolder(input);
  }
}

function cancelNewFolder(input) {
  const icon = input.closest('.desktop-icon');
  if (icon) icon.remove();
}

async function createFolderOnDisk(path) {
  if (!sessionToken) return false;
  try {
    const res = await fetch(API_BASE + '/files/mkdir?path=' + encodeURIComponent(path), {
      method: 'POST',
      headers: { 'Authorization': 'Bearer ' + sessionToken }
    });
    return res.ok;
  } catch (e) {
    return false;
  }
}

function createDesktopIcon(ic) {
  const container = document.getElementById('desktop-icons');
  if (!container) return;

  const icon = document.createElement('div');
  icon.className = 'desktop-icon' + (ic.isFolder ? ' folder' : '');
  icon.id = 'icon-' + ic.id;
  icon.dataset.id = ic.id;
  icon.style.left = ic.x + 'px';
  icon.style.top = ic.y + 'px';
  const iconHtml = typeof ic.icon === 'object' ? renderIcon(ic.icon) : ic.icon;
  icon.innerHTML = '<div class="icon-img">' + iconHtml + '</div><div class="icon-label">' + escapeHtml(ic.name) + '</div>';

  icon.ondblclick = async () => {
    if (ic.action === 'openFolder') {
      navigateToPath(ic.filePath);
    } else if (ic.action === 'openDiskFile') {
      // Use registered file handlers
      await openFileWithDefaultHandler(ic.filePath, ic.fileName);
    } else if (typeof window[ic.action] === 'function') {
      window[ic.action](ic.filePath);
    }
  };

  // Right-click context menu for files/folders
  if (ic.action === 'openDiskFile' || ic.action === 'openFolder') {
    icon.oncontextmenu = (e) => {
      e.preventDefault();
      e.stopPropagation();
      showFileContextMenu(e, ic.filePath, ic.fileName, ic.isFolder);
    };
  }

  container.appendChild(icon);
}

function showFileContextMenu(e, filePath, fileName, isFolder) {
  const menu = document.getElementById('context-menu');
  const isJS = fileName && fileName.endsWith('.js');

  if (isFolder) {
    menu.innerHTML =
      '<div class="ctx-item" onclick="navigateToPath(\'' + escapeHtml(filePath) + '\');hideContextMenu();">ğŸ“‚ Open</div>' +
      '<div class="ctx-item" onclick="renameDiskFile(\'' + escapeHtml(filePath) + '\', \'' + escapeHtml(fileName) + '\')">âœï¸ Rename</div>' +
      '<div class="ctx-separator"></div>' +
      '<div class="ctx-item" style="color:#f66;" onclick="deleteDiskFile(\'' + escapeHtml(filePath) + '\')">ğŸ—‘ï¸ Delete</div>';
  } else {
    // Get all registered handlers for this file type
    const handlers = getFileHandlers(fileName);
    let html = '';

    // Run option for JS files
    if (isJS) {
      html += '<div class="ctx-item" onclick="runDiskFile(\'' + escapeHtml(filePath) + '\', \'' + escapeHtml(fileName) + '\')">â–¶ Run</div>';
    }

    // "Open" uses default handler
    if (handlers.length > 0) {
      const defaultHandler = handlers[0];
      html += '<div class="ctx-item" onclick="openFileWithApp(\'' + escapeHtml(defaultHandler.id) + '\', \'' + escapeHtml(filePath) + '\', \'' + escapeHtml(fileName) + '\')">' + defaultHandler.icon + ' Open</div>';
    } else {
      html += '<div class="ctx-item" onclick="openDiskFileByPath(\'' + escapeHtml(filePath) + '\', \'' + escapeHtml(fileName) + '\')">ğŸ“‚ Open</div>';
    }

    // "Open With" submenu if multiple handlers
    if (handlers.length > 1) {
      html += '<div class="ctx-item has-submenu">ğŸ“‚ Open With...<div class="ctx-submenu">';
      handlers.forEach(h => {
        html += '<div class="ctx-item" onclick="openFileWithApp(\'' + escapeHtml(h.id) + '\', \'' + escapeHtml(filePath) + '\', \'' + escapeHtml(fileName) + '\')">' + h.icon + ' ' + escapeHtml(h.name) + '</div>';
      });
      html += '</div></div>';
    }

    html += '<div class="ctx-item" onclick="renameDiskFile(\'' + escapeHtml(filePath) + '\', \'' + escapeHtml(fileName) + '\')">âœï¸ Rename</div>';
    html += '<div class="ctx-separator"></div>';
    html += '<div class="ctx-item" style="color:#f66;" onclick="deleteDiskFile(\'' + escapeHtml(filePath) + '\')">ğŸ—‘ï¸ Delete</div>';

    menu.innerHTML = html;
  }
  menu.style.left = e.clientX + 'px';
  menu.style.top = e.clientY + 'px';
  menu.classList.add('visible');
}

async function openFileWithApp(handlerId, filePath, fileName) {
  hideContextMenu();
  const content = await getFileFromDisk(filePath);
  if (content !== null) {
    openFileWithHandler(handlerId, filePath, fileName, content);
  } else {
    algoSpeak('Failed to open file');
  }
}

async function runDiskFile(path, name) {
  hideContextMenu();
  const content = await getFileFromDisk(path);
  if (content !== null) {
    runApp(content, name);
  } else {
    algoSpeak('Failed to load file');
  }
}

async function openDiskFileByPath(path, name) {
  hideContextMenu();
  const content = await getFileFromDisk(path);
  if (content !== null) {
    openSavedFile({ name: name, content: content }, path);
  } else {
    algoSpeak('Failed to open file');
  }
}

async function renameDiskFile(oldPath, oldName) {
  hideContextMenu();
  const newName = prompt('New name:', oldName);
  if (!newName || newName === oldName) return;

  const content = await getFileFromDisk(oldPath);
  if (content === null) { algoSpeak('Failed to read file'); return; }

  const saved = await saveFileToDisk(newName, content);
  if (!saved) { algoSpeak('Failed to save new file'); return; }

  const deleted = await deleteFileFromDisk(oldPath);
  if (!deleted) { algoSpeak('Renamed but failed to delete old file'); }

  await createDesktopIcons();
  algoSpeak('Renamed to ' + newName);
}

async function deleteDiskFile(path) {
  hideContextMenu();
  if (!confirm('Delete this file?')) return;

  const deleted = await deleteFileFromDisk(path);
  if (deleted) {
    await createDesktopIcons();
    algoSpeak('File deleted');
  } else {
    algoSpeak('Failed to delete file');
  }
}

function getFileIcon(filename) {
  const ext = filename.split('.').pop().toLowerCase();
  return fileTypeRegistry[ext]?.icon || 'ğŸ“„';
}

// ==================== WINDOWS ====================
function createWindow(opts) {
  const id = winId++;
  const win = {
    id,
    title: opts.title || 'Window',
    icon: opts.icon || 'ğŸ“„',
    width: opts.width || 400,
    height: opts.height || 300,
    x: opts.x || 100 + (id % 5) * 30,
    y: opts.y || 50 + (id % 5) * 30,
    minimized: false,
    maximized: false,
    content: opts.content || '',
    onClose: opts.onClose
  };
  windows.push(win);
  renderWindow(win);
  focusWindow(id);
  updateTaskbar();
  return id;
}

function renderWindow(win) {
  const desktop = document.getElementById('desktop');
  const el = document.createElement('div');
  el.className = 'window inactive';
  el.id = 'win-' + win.id;
  el.style.cssText = 'left:' + win.x + 'px;top:' + win.y + 'px;width:' + win.width + 'px;height:' + win.height + 'px;';

  // Build resize handles HTML
  const resizeHandles = isMobile
    ? '<div class="resize-handle resize-grippy" onmousedown="startResize(event,' + win.id + ',\'se\')" ontouchstart="startResize(event,' + win.id + ',\'se\')"></div>'
    : '<div class="resize-handle resize-n" onmousedown="startResize(event,' + win.id + ',\'n\')"></div>' +
      '<div class="resize-handle resize-s" onmousedown="startResize(event,' + win.id + ',\'s\')"></div>' +
      '<div class="resize-handle resize-e" onmousedown="startResize(event,' + win.id + ',\'e\')"></div>' +
      '<div class="resize-handle resize-w" onmousedown="startResize(event,' + win.id + ',\'w\')"></div>' +
      '<div class="resize-handle resize-ne" onmousedown="startResize(event,' + win.id + ',\'ne\')"></div>' +
      '<div class="resize-handle resize-nw" onmousedown="startResize(event,' + win.id + ',\'nw\')"></div>' +
      '<div class="resize-handle resize-se" onmousedown="startResize(event,' + win.id + ',\'se\')"></div>' +
      '<div class="resize-handle resize-sw" onmousedown="startResize(event,' + win.id + ',\'sw\')"></div>';

  el.innerHTML =
    '<div class="window-titlebar" onmousedown="startDrag(event,' + win.id + ')" ontouchstart="startDrag(event,' + win.id + ')">' +
      '<div class="window-controls">' +
        '<button class="window-btn close" onclick="event.stopPropagation();closeWindow(' + win.id + ')"></button>' +
        '<button class="window-btn minimize" onclick="event.stopPropagation();minimizeWindow(' + win.id + ')"></button>' +
        '<button class="window-btn maximize" onclick="event.stopPropagation();maximizeWindow(' + win.id + ')"></button>' +
      '</div>' +
      '<span class="window-title">' + escapeHtml(win.title) + '</span>' +
    '</div>' +
    '<div class="window-content">' + win.content + '</div>' +
    resizeHandles;

  el.onmousedown = () => focusWindow(win.id);
  el.ontouchstart = () => focusWindow(win.id);
  desktop.appendChild(el);
}

function focusWindow(id) {
  windows.forEach(w => {
    const el = document.getElementById('win-' + w.id);
    if (el) {
      el.classList.remove('active');
      el.classList.add('inactive');
    }
  });
  const el = document.getElementById('win-' + id);
  if (el) {
    el.classList.add('active');
    el.classList.remove('inactive');
    el.style.zIndex = ++topZIndex;
  }
  activeWin = id;
  updateMenubarAppName();
}

function minimizeWindow(id) {
  const el = document.getElementById('win-' + id);
  if (el) el.classList.add('minimized');
  const win = windows.find(w => w.id === id);
  if (win) win.minimized = true;
  updateTaskbar();
}

function restoreWindow(id) {
  const el = document.getElementById('win-' + id);
  if (el) el.classList.remove('minimized');
  const win = windows.find(w => w.id === id);
  if (win) win.minimized = false;
  focusWindow(id);
  updateTaskbar();
}

function maximizeWindow(id) {
  const el = document.getElementById('win-' + id);
  const win = windows.find(w => w.id === id);
  if (!el || !win) return;

  if (win.maximized) {
    el.style.left = win.restoreX + 'px';
    el.style.top = win.restoreY + 'px';
    el.style.width = win.restoreW + 'px';
    el.style.height = win.restoreH + 'px';
    win.maximized = false;
  } else {
    win.restoreX = el.offsetLeft;
    win.restoreY = el.offsetTop;
    win.restoreW = el.offsetWidth;
    win.restoreH = el.offsetHeight;
    el.style.left = '0';
    el.style.top = '0';
    el.style.width = '100%';
    el.style.height = '100%';
    win.maximized = true;
  }
}

function closeWindow(id) {
  const win = windows.find(w => w.id === id);
  if (win && win.onClose) win.onClose();
  const el = document.getElementById('win-' + id);
  if (el) el.remove();
  windows = windows.filter(w => w.id !== id);
  // Focus next window or clear active
  if (activeWin === id) {
    const nextWin = windows.find(w => !w.minimized);
    if (nextWin) {
      focusWindow(nextWin.id);
    } else {
      activeWin = null;
      updateMenubarAppName();
    }
  }
  updateTaskbar();
}

function updateTaskbar() {
  const tb = document.getElementById('taskbar-windows');
  tb.innerHTML = windows.map(w =>
    '<div class="taskbar-item' + (w.id === activeWin ? ' active' : '') + (w.minimized ? ' minimized' : '') +
    '" onclick="' + (w.minimized ? 'restoreWindow(' + w.id + ')' : 'focusWindow(' + w.id + ')') + '">' +
    w.icon + ' ' + escapeHtml(w.title.substring(0, 20)) + '</div>'
  ).join('');
}

// ==================== DRAG & RESIZE ====================
let resizeWin = null;
let resizeDir = null;
let resizeStart = { x: 0, y: 0, w: 0, h: 0, left: 0, top: 0 };
const isMobile = /Android|iPhone|iPad|iPod|webOS|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

function getEventPos(e) {
  if (e.touches && e.touches.length > 0) {
    return { x: e.touches[0].clientX, y: e.touches[0].clientY };
  }
  return { x: e.clientX, y: e.clientY };
}

function startDrag(e, id) {
  if (e.target.classList.contains('window-btn') || e.target.classList.contains('win-btn')) return;
  e.preventDefault();
  const el = document.getElementById('win-' + id);
  if (!el) return;
  const pos = getEventPos(e);
  dragWin = { id, el };
  dragOffset = { x: pos.x - el.offsetLeft, y: pos.y - el.offsetTop };
  focusWindow(id);
}

function onDrag(e) {
  if (!dragWin && !resizeWin) return;
  const pos = getEventPos(e);

  if (dragWin) {
    dragWin.el.style.left = (pos.x - dragOffset.x) + 'px';
    dragWin.el.style.top = (pos.y - dragOffset.y) + 'px';
  }

  if (resizeWin) {
    e.preventDefault();
    const dx = pos.x - resizeStart.x;
    const dy = pos.y - resizeStart.y;
    const minW = 200, minH = 150;

    if (resizeDir.includes('e')) {
      resizeWin.el.style.width = Math.max(minW, resizeStart.w + dx) + 'px';
    }
    if (resizeDir.includes('w')) {
      const newW = Math.max(minW, resizeStart.w - dx);
      resizeWin.el.style.width = newW + 'px';
      resizeWin.el.style.left = (resizeStart.left + resizeStart.w - newW) + 'px';
    }
    if (resizeDir.includes('s')) {
      resizeWin.el.style.height = Math.max(minH, resizeStart.h + dy) + 'px';
    }
    if (resizeDir.includes('n')) {
      const newH = Math.max(minH, resizeStart.h - dy);
      resizeWin.el.style.height = newH + 'px';
      resizeWin.el.style.top = (resizeStart.top + resizeStart.h - newH) + 'px';
    }
  }
}

function endDrag() {
  dragWin = null;
  resizeWin = null;
  resizeDir = null;
}

function startResize(e, id, dir) {
  e.preventDefault();
  e.stopPropagation();
  const el = document.getElementById('win-' + id);
  if (!el) return;
  const pos = getEventPos(e);
  resizeWin = { id, el };
  resizeDir = dir;
  resizeStart = {
    x: pos.x,
    y: pos.y,
    w: el.offsetWidth,
    h: el.offsetHeight,
    left: el.offsetLeft,
    top: el.offsetTop
  };
  focusWindow(id);
}

// ==================== NOTEPAD ====================
function openNotepad(content, filename) {
  hideStartMenu();
  const id = winId;
  const text = content || '';
  const name = filename || 'Untitled.txt';

  createWindow({
    title: name,
    icon: 'ğŸ“',
    width: 500,
    height: 400,
    content:
      '<div class="notepad-container">' +
        '<div class="notepad-toolbar">' +
          '<button onclick="notepadNew(' + id + ')">New</button>' +
          '<button onclick="notepadSave(' + id + ')">Save</button>' +
        '</div>' +
        '<textarea id="notepad-text-' + id + '" class="notepad-textarea">' + escapeHtml(text) + '</textarea>' +
      '</div>'
  });
}

function notepadNew(id) {
  const textarea = document.getElementById('notepad-text-' + id);
  if (textarea) textarea.value = '';
}

async function notepadSave(id) {
  const textarea = document.getElementById('notepad-text-' + id);
  if (!textarea) return;
  const name = prompt('Filename:', 'document.txt');
  if (!name) return;

  const saved = await saveFileToDisk(name, textarea.value);
  if (saved) {
    await createDesktopIcons();
    algoSpeak('Saved ' + name + ' to ~/');
  } else {
    algoSpeak('Failed to save file');
  }
}

// ==================== JAVASCRIPT IDE ====================
const ALGO_API_CODE = `
// Extend global ALGO (don't shadow it - we need pubsub and bridge!)
ALGO.app = { name: 'App', icon: 'ğŸ“±' };
ALGO.title = (t) => { document.title = t; };
ALGO.html = (h) => { document.body.innerHTML = h; };
ALGO.createWindow = (opts) => createWindow(opts);
ALGO.notify = (msg) => algoSpeak(msg);
ALGO.state = ALGO.state || {};
ALGO.ui = ALGO.ui || {
  button: (text, onclick) => '<button onclick="(' + onclick + ')()">' + text + '</button>'
};
`;

const IDE_EXAMPLES = {
  'hello': {
    name: 'Hello World',
    code: '// Hello World\\nALGO.app.name = "Hello";\\nALGO.app.icon = "ğŸ‘‹";\\n\\nALGO.html("<h1>Hello, World!</h1>");'
  },
  'counter': {
    name: 'Counter',
    code: '// Counter App\\nALGO.app.name = "Counter";\\nALGO.app.icon = "ğŸ”¢";\\n\\nlet count = 0;\\n\\nfunction render() {\\n  ALGO.html(`\\n    <div style="text-align:center;padding:20px;">\\n      <h1>${count}</h1>\\n      <button onclick="count--;render()">-</button>\\n      <button onclick="count++;render()">+</button>\\n    </div>\\n  `);\\n}\\n\\nrender();'
  }
};

function openJSIDE(content, filename) {
  hideStartMenu();
  const id = winId;
  const code = content || '// Function Server App\\nALGO.app.name = "My App";\\nALGO.app.icon = "ğŸ“±";\\n\\nALGO.html("<h1>Hello!</h1>");';

  createWindow({
    title: filename || 'javascript.ide',
    icon: 'ğŸ’»',
    width: 700,
    height: 500,
    content:
      '<div class="ide-container">' +
        '<div class="ide-toolbar">' +
          '<button onclick="ideRun(' + id + ')">â–¶ Run</button>' +
          '<button onclick="ideSave(' + id + ')">ğŸ’¾ Save</button>' +
          '<select onchange="ideLoadExample(' + id + ',this.value)">' +
            '<option value="">Examples...</option>' +
            '<option value="hello">Hello World</option>' +
            '<option value="counter">Counter</option>' +
          '</select>' +
        '</div>' +
        '<div class="ide-main">' +
          '<textarea id="ide-code-' + id + '" class="ide-editor">' + escapeHtml(code) + '</textarea>' +
          '<div class="ide-preview" id="ide-preview-' + id + '"></div>' +
        '</div>' +
      '</div>'
  });
}

function ideRun(id) {
  const code = document.getElementById('ide-code-' + id).value;
  const preview = document.getElementById('ide-preview-' + id);

  try {
    preview.innerHTML = '<div id="app-root"></div>';
    const fullCode = ALGO_API_CODE + '\n' +
      'const ALGO_ROOT = document.getElementById("ide-preview-' + id + '").querySelector("#app-root");\n' +
      'ALGO.html = (h) => { ALGO_ROOT.innerHTML = h; };\n' +
      code;
    eval(fullCode);
  } catch (e) {
    preview.innerHTML = '<div style="color:red;padding:10px;">Error: ' + escapeHtml(e.message) + '</div>';
  }
}

async function ideSave(id) {
  const code = document.getElementById('ide-code-' + id).value;
  const name = prompt('Filename:', 'app.js');
  if (!name) return;

  const saved = await saveFileToDisk(name, code);
  if (saved) {
    await createDesktopIcons();
    algoSpeak('Saved ' + name + ' to ~/');
  } else {
    algoSpeak('Failed to save file');
  }
}

function ideLoadExample(id, key) {
  if (!key || !IDE_EXAMPLES[key]) return;
  document.getElementById('ide-code-' + id).value = IDE_EXAMPLES[key].code.replace(/\\\\n/g, '\\n');
}

// ==================== WEB BROWSER ====================
function openBrowser(url) {
  hideStartMenu();
  const id = winId;
  const startUrl = url || 'https://example.com';

  createWindow({
    title: 'Web Browser',
    icon: 'ğŸŒ',
    width: 800,
    height: 600,
    content:
      '<div class="browser-container">' +
        '<div class="browser-toolbar">' +
          '<button onclick="browserBack(' + id + ')">â—€</button>' +
          '<button onclick="browserFwd(' + id + ')">â–¶</button>' +
          '<input type="text" id="browser-url-' + id + '" value="' + escapeHtml(startUrl) + '" onkeypress="if(event.key===\'Enter\')browserGo(' + id + ')">' +
          '<button onclick="browserGo(' + id + ')">Go</button>' +
        '</div>' +
        '<iframe id="browser-frame-' + id + '" src="' + escapeHtml(startUrl) + '" class="browser-frame"></iframe>' +
      '</div>'
  });
}

function browserGo(id) {
  let url = document.getElementById('browser-url-' + id).value;
  if (!url.startsWith('http')) url = 'https://' + url;
  document.getElementById('browser-frame-' + id).src = url;
}

function browserBack(id) {
  try { document.getElementById('browser-frame-' + id).contentWindow.history.back(); } catch(e) {}
}

function browserFwd(id) {
  try { document.getElementById('browser-frame-' + id).contentWindow.history.forward(); } catch(e) {}
}

// Open HTML content in browser using data URL
function openBrowserWithContent(filePath, fileName, content) {
  hideStartMenu();
  const id = winId;
  // Create a blob URL for the HTML content
  const blob = new Blob([content], { type: 'text/html' });
  const blobUrl = URL.createObjectURL(blob);

  createWindow({
    title: 'Web Browser - ' + fileName,
    icon: 'ğŸŒ',
    width: 800,
    height: 600,
    content:
      '<div class="browser-container">' +
        '<div class="browser-toolbar">' +
          '<button onclick="browserBack(' + id + ')">â—€</button>' +
          '<button onclick="browserFwd(' + id + ')">â–¶</button>' +
          '<input type="text" id="browser-url-' + id + '" value="' + escapeHtml(filePath) + '" readonly style="background:#333;">' +
          '<button onclick="browserGo(' + id + ')">Go</button>' +
        '</div>' +
        '<iframe id="browser-frame-' + id + '" src="' + blobUrl + '" class="browser-frame"></iframe>' +
      '</div>'
  });
}

// ==================== FILE HANDLER REGISTRATIONS ====================
// Register built-in apps as file handlers
// Order matters: first registered with isDefault=true becomes default
//
// External apps can also register handlers by calling registerFileHandler()
// when they initialize. Notable external app repos:
//   - Studio (IDE): https://github.com/williamsharkey/fs-studio
//
// To add a new file handler from an external app:
//   registerFileHandler({
//     id: 'myapp',
//     name: 'My App',
//     icon: 'ğŸ“±',
//     extensions: ['ext1', 'ext2'],
//     handler: (filePath, fileName, content) => myApp.open(content, fileName),
//     isDefault: false  // true to become default for these extensions
//   });

// Web Browser: default for HTML files
registerFileHandler({
  id: 'browser',
  name: 'Web Browser',
  icon: 'ğŸŒ',
  extensions: ['html', 'htm'],
  handler: openBrowserWithContent,
  isDefault: true
});

// Notepad: handles many text formats
registerFileHandler({
  id: 'notepad',
  name: 'Notepad',
  icon: 'ğŸ“',
  extensions: ['txt', 'html', 'htm', 'css', 'json', 'md', 'xml', 'csv', 'log', 'ini', 'cfg', 'conf', 'yaml', 'yml'],
  handler: (filePath, fileName, content) => openNotepad(content, fileName),
  isDefault: false
});

// JavaScript IDE: default for JS files
registerFileHandler({
  id: 'jside',
  name: 'javascript.ide',
  icon: 'ğŸ’»',
  extensions: ['js'],
  handler: (filePath, fileName, content) => openJSIDE(content, fileName),
  isDefault: true
});

// Notepad also handles JS as secondary
registerFileHandler({
  id: 'notepad',
  name: 'Notepad',
  icon: 'ğŸ“',
  extensions: ['js'],
  handler: (filePath, fileName, content) => openNotepad(content, fileName),
  isDefault: false
});

// ==================== DOCUMENTATION ====================
const DOCS = {
  'getting-started': {
    title: 'Getting Started',
    content: '<h2>Welcome to Function Server</h2><p>A cloud operating system in your browser.</p><h3>Quick Start</h3><ul><li>Double-click icons to open programs</li><li>Right-click for context menus</li><li>Use Start menu for all programs</li></ul>'
  },
  'apps': {
    title: 'Building Apps',
    content: '<h2>Building Apps</h2><p>Use JavaScript.IDE to create apps.</p><pre style="background:#e8e0f0;color:#222;padding:12px;border-radius:6px;">ALGO.app.name = "My App";\\nALGO.html("<h1>Hello!</h1>");</pre>'
  }
};

function openDocumentation() {
  hideStartMenu();
  createWindow({
    title: 'Documentation',
    icon: 'ğŸ“•',
    width: 500,
    height: 400,
    content:
      '<div class="docs-container">' +
        '<div class="docs-sidebar">' +
          Object.keys(DOCS).map(k => '<div class="docs-item" onclick="showDoc(\'' + k + '\')">' + DOCS[k].title + '</div>').join('') +
        '</div>' +
        '<div class="docs-content" id="docs-content">' +
          '<p>Select a topic from the sidebar.</p>' +
        '</div>' +
      '</div>'
  });
}

function showDoc(key) {
  const doc = DOCS[key];
  if (doc) {
    document.getElementById('docs-content').innerHTML = doc.content;
  }
}

function openHelp() {
  hideStartMenu();
  createWindow({
    title: 'Help',
    icon: 'ğŸ“™',
    width: 400,
    height: 300,
    content: '<div style="padding:20px;"><h2>Help</h2><p>Function Server is a cloud OS.</p><ul><li>Use Start menu for programs</li><li>System Apps load from /core/apps/</li><li>Create apps with JavaScript.IDE</li></ul></div>'
  });
}

// ==================== FILE HANDLING ====================
function openSavedFile(file, filePath) {
  // Files in ~/apps/ or ~/games/ folder auto-run instead of opening in editor
  // Also auto-run if file contains ALGO.app.name (marks it as an app)
  const isAppFolder = filePath && (
    filePath.startsWith('~/apps/') || filePath.startsWith('~/apps\\') ||
    filePath.startsWith('~/games/') || filePath.startsWith('~/games\\')
  );
  const isApp = isAppFolder || (file.content && /ALGO\.app\.name\s*=/.test(file.content));
  if (file.name.endsWith('.js')) {
    if (isApp) {
      runApp(file.content, file.name);
    } else {
      openJSIDE(file.content, file.name);
    }
  } else if (file.type === 'image') {
    viewImage(file);
  } else {
    openNotepad(file.content, file.name);
  }
}

function viewImage(file) {
  createWindow({
    title: file.name,
    icon: 'ğŸ–¼ï¸',
    width: 500,
    height: 400,
    content: '<div style="display:flex;align-items:center;justify-content:center;height:100%;background:#222;"><img src="' + file.data + '" style="max-width:100%;max-height:100%;"></div>'
  });
}

// ==================== CONTEXT MENU ====================
function showDesktopContextMenu(e) {
  const menu = document.getElementById('context-menu');
  menu.innerHTML =
    '<div class="ctx-item" onclick="openNotepad()">ğŸ“ New Text File</div>' +
    '<div class="ctx-item" onclick="openJSIDE()">ğŸ“œ New App</div>' +
    '<div class="ctx-separator"></div>' +
    '<div class="ctx-item" onclick="refreshDesktop()">ğŸ”„ Refresh</div>' +
    '<div class="ctx-separator"></div>' +
    '<div class="ctx-item" onclick="inspectElement()">ğŸ” Inspect Element</div>';
  menu.style.left = e.clientX + 'px';
  menu.style.top = e.clientY + 'px';
  menu.classList.add('visible');
}

let _inspectPassthrough = false;
let _lastContextPos = { x: 0, y: 0 };

function inspectElement() {
  hideContextMenu();
  // Chrome DevTools inspect() function - only works when DevTools is open
  if (typeof inspect === 'function' && contextTarget) {
    inspect(contextTarget);
  } else {
    // Fallback: trigger native context menu by setting passthrough flag
    _inspectPassthrough = true;
    // Small delay to ensure context menu is fully hidden before triggering native menu
    setTimeout(() => {
      const target = contextTarget || document.elementFromPoint(_lastContextPos.x, _lastContextPos.y) || document.body;
      const evt = new MouseEvent('contextmenu', {
        bubbles: true,
        cancelable: true,
        clientX: _lastContextPos.x,
        clientY: _lastContextPos.y,
        button: 2,
        view: window
      });
      target.dispatchEvent(evt);
    }, 50);
  }
}

async function refreshDesktop() {
  hideContextMenu();
  await createDesktopIcons();
  algoSpeak('Desktop refreshed');
}

function hideContextMenu() {
  document.getElementById('context-menu').classList.remove('visible');
}

// ==================== START MENU ====================
function toggleStartMenu() {
  document.getElementById('start-menu').classList.toggle('visible');
}

function hideStartMenu() {
  document.getElementById('start-menu').classList.remove('visible');
}

function openSubmenu(el) {
  if (submenuCloseTimeout) {
    clearTimeout(submenuCloseTimeout);
    submenuCloseTimeout = null;
  }
  // Only close sibling submenus, not all submenus
  const parent = el.parentElement;
  if (parent) {
    parent.querySelectorAll(':scope > .start-item.has-sub').forEach(item => {
      if (item !== el) item.classList.remove('submenu-open');
    });
  }
  el.classList.add('submenu-open');

  // Fix submenu position
  const submenu = el.querySelector(':scope > .start-submenu');
  if (submenu) {
    const isNested = el.closest('.start-submenu') !== null;
    const menubarHeight = 28; // var(--menubar-height)

    if (isNested) {
      // Nested submenu: position relative to parent item
      const parentRect = el.getBoundingClientRect();
      submenu.style.setProperty('position', 'fixed', 'important');
      submenu.style.setProperty('left', parentRect.right + 'px', 'important');
      submenu.style.setProperty('top', parentRect.top + 'px', 'important');
      submenu.style.setProperty('bottom', 'auto', 'important');
      submenu.style.setProperty('max-height', (window.innerHeight - menubarHeight - 20) + 'px', 'important');
    } else {
      // Top-level submenu: align with start menu item (drops down from top)
      const startMenu = document.getElementById('start-menu');
      const startRect = startMenu.getBoundingClientRect();
      const itemRect = el.getBoundingClientRect();
      submenu.style.setProperty('position', 'fixed', 'important');
      submenu.style.setProperty('left', (startRect.right - 2) + 'px', 'important');
      submenu.style.setProperty('top', itemRect.top + 'px', 'important');
      submenu.style.setProperty('bottom', 'auto', 'important');
      submenu.style.setProperty('max-height', (window.innerHeight - menubarHeight - 20) + 'px', 'important');
    }
  }
}

function closeSubmenuDelay(el) {
  submenuCloseTimeout = setTimeout(() => {
    el.classList.remove('submenu-open');
  }, 300);
}

function toggleSubmenu(e, el) {
  if (window.innerWidth <= 768) {
    e.stopPropagation();
    el.classList.toggle('submenu-open');
  }
}

// ==================== PROGRAMS MENU ====================
const CATEGORY_INFO = {
  media:        { name: 'Media',        icon: 'ğŸµ' },
  graphics:     { name: 'Graphics',     icon: 'ğŸ¨' },
  development:  { name: 'Development',  icon: 'ğŸ’»' },
  productivity: { name: 'Productivity', icon: 'ğŸ“‹' },
  system:       { name: 'System',       icon: 'âš™ï¸' }
};

function updateProgramsMenu() {
  const el = document.getElementById('installed-programs-menu');
  if (!el) return;

  let html = '';
  const visibleSystemApps = systemApps.filter(a => !uninstalledSystemApps.includes(a.id));

  // Group apps by category
  const categories = {};
  const uncategorized = [];

  visibleSystemApps.forEach(a => {
    const cat = a.category || '';
    if (cat && CATEGORY_INFO[cat]) {
      if (!categories[cat]) categories[cat] = [];
      categories[cat].push(a);
    } else {
      uncategorized.push(a);
    }
  });

  // Render category submenus
  const categoryOrder = ['media', 'graphics', 'development', 'productivity', 'system'];
  categoryOrder.forEach(cat => {
    const apps = categories[cat];
    if (!apps || apps.length === 0) return;
    const info = CATEGORY_INFO[cat];

    html += '<div class="start-item has-sub" onmouseenter="openSubmenu(this)" onmouseleave="closeSubmenuDelay(this)">';
    html += '<span>' + info.icon + '</span> ' + info.name;
    html += '<div class="start-submenu">';
    apps.sort((a, b) => a.name.localeCompare(b.name)).forEach(a => {
      html += '<div class="start-item" onclick="runSystemApp(\'' + a.id + '\')">' +
        '<span class="menu-icon">' + (a.icon || 'ğŸ“±') + '</span> ' + escapeHtml(a.name) + '</div>';
    });
    html += '</div></div>';
  });

  // Uncategorized apps (if any)
  if (uncategorized.length > 0) {
    html += '<div class="start-separator"></div>';
    uncategorized.forEach(a => {
      html += '<div class="start-item" onclick="runSystemApp(\'' + a.id + '\')">' +
        '<span class="menu-icon">' + (a.icon || 'ğŸ“±') + '</span> ' + escapeHtml(a.name) + '</div>';
    });
  }

  // User apps
  if (installedPrograms.length > 0) {
    html += '<div class="start-separator"></div>';
    html += '<div class="start-separator-label">My Apps</div>';
    html += installedPrograms.map(p =>
      '<div class="start-item" onclick="runUserApp(\'' + p.id + '\')">' +
      '<span class="menu-icon">' + getIcon(p.icon || 'ğŸ®') + '</span> ' + escapeHtml(p.name) + '</div>'
    ).join('');
  }

  el.innerHTML = html;

  // Setup scroll indicator
  setupScrollIndicator();
}

function setupScrollIndicator() {
  const menu = document.getElementById('programs-menu');
  if (!menu) return;

  // Add scroll indicator if not present
  let indicator = menu.querySelector('.scroll-indicator');
  if (!indicator) {
    indicator = document.createElement('div');
    indicator.className = 'scroll-indicator';
    indicator.innerHTML = '<svg viewBox="0 0 20 8"><path d="M0 0 L10 8 L20 0 Z"/></svg>';
    menu.appendChild(indicator);
  }

  const updateIndicator = () => {
    const canScroll = menu.scrollHeight > menu.clientHeight;
    const atBottom = menu.scrollTop + menu.clientHeight >= menu.scrollHeight - 5;
    indicator.classList.toggle('visible', canScroll && !atBottom);
  };

  menu.removeEventListener('scroll', updateIndicator);
  menu.addEventListener('scroll', updateIndicator);

  // Check on menu show
  const observer = new MutationObserver(() => {
    if (menu.offsetParent) setTimeout(updateIndicator, 10);
  });
  observer.observe(menu, { attributes: true, attributeFilter: ['style'] });

  setTimeout(updateIndicator, 100);
}

// ==================== APP RUNNING ====================
function loadSystemApps() {
  fetch(API_BASE + '/system-apps')
    .then(r => r.json())
    .then(data => {
      systemApps = data.apps || [];
      updateProgramsMenu();
    })
    .catch(() => {});
}

function runSystemApp(appId) {
  hideStartMenu();
  const app = systemApps.find(a => a.id === appId);
  if (app) runApp(app);
}

function runUserApp(appId) {
  hideStartMenu();
  const app = installedPrograms.find(a => a.id === appId);
  if (app) runApp(app);
}

function runApp(appOrCode, name) {
  // Handle both object {code, name} and direct (code, name) arguments
  const code = typeof appOrCode === 'string' ? appOrCode : appOrCode?.code;
  const appName = name || appOrCode?.name || 'App';
  if (code) {
    try {
      const fullCode = ALGO_API_CODE + '\n' + code;
      eval(fullCode);
      // Hook AI Eyes after app loads (wraps Lens if Studio added functions)
      if (ALGO.eyes?.wrapLens) ALGO.eyes.wrapLens();
    } catch (e) {
      algoSpeak('Error in ' + appName + ': ' + e.message);
    }
  }
}

// ==================== UTILITIES ====================
function globalClick(e) {
  if (!e.target.closest('#start-menu') && !e.target.closest('#start-btn') && !e.target.closest('#system-icon')) {
    hideStartMenu();
  }
  if (!e.target.closest('#user-menu') && !e.target.closest('#menubar-user')) {
    hideUserMenu();
  }
  if (!e.target.closest('#context-menu')) {
    hideContextMenu();
  }
}

function updateClock() {
  const now = new Date();
  const timeStr = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
  const legacyClock = document.getElementById('clock');
  if (legacyClock) legacyClock.textContent = timeStr;

  // Menubar clock with full format: Mon Jan 26 10:41 AM
  const menubarClock = document.getElementById('menubar-clock');
  if (menubarClock) {
    const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
    const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    const day = days[now.getDay()];
    const month = months[now.getMonth()];
    const date = now.getDate();
    const hour = now.getHours();
    const minute = now.getMinutes().toString().padStart(2, '0');
    const ampm = hour >= 12 ? 'PM' : 'AM';
    const hour12 = hour % 12 || 12;
    menubarClock.textContent = `${day} ${month} ${date} ${hour12}:${minute} ${ampm}`;
  }
}

function updateMenubarAppName() {
  const appNameEl = document.getElementById('active-app-name');
  if (!appNameEl) return;

  const activeWindow = windows.find(w => w.id === activeWin);
  if (activeWindow) {
    appNameEl.textContent = activeWindow.title || activeWindow.appName || 'Window';
  } else {
    appNameEl.textContent = 'Desktop';
  }
}

function updateMenubarUser() {
  const userEl = document.getElementById('menubar-user');
  if (!userEl) return;
  if (currentUser) {
    const isSystem = sessionToken && localStorage.getItem('fs_system_user') === 'true';
    userEl.textContent = currentUser + (isSystem ? ' (system)' : '');
    userEl.style.display = '';
  } else {
    userEl.style.display = 'none';
  }
}

function toggleUserMenu() {
  const menu = document.getElementById('user-menu');
  if (menu) menu.classList.toggle('visible');
}

function hideUserMenu() {
  const menu = document.getElementById('user-menu');
  if (menu) menu.classList.remove('visible');
}

function escapeHtml(s) {
  return String(s).replace(/[&<>"']/g, c => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[c]));
}

function algoSpeak(text) {
  const container = document.getElementById('toast-container');
  if (!container) return;
  const toast = document.createElement('div');
  toast.className = 'algo-toast';
  toast.innerHTML = '<span class="toast-icon">ğŸ–¥ï¸</span><span class="toast-text">' + escapeHtml(text) + '</span>';
  container.appendChild(toast);
  requestAnimationFrame(() => toast.classList.add('show'));
  setTimeout(() => {
    toast.classList.remove('show');
    setTimeout(() => toast.remove(), 300);
  }, 3500);
}

function showAbout() {
  hideStartMenu();
  createWindow({
    title: 'About',
    icon: 'ğŸ–¥ï¸',
    width: 320,
    height: 220,
    content: '<div style="padding:20px;text-align:center;"><div style="font-size:48px;">ğŸ–¥ï¸</div><h2>Function Server</h2><p style="color:#666;">A Cloud Operating System</p><p style="font-size:11px;margin-top:15px;">MIT License â€¢ Open Source</p></div>'
  });
}

function hardRefresh() {
  hideStartMenu();
  // Cache-busting reload
  location.href = location.href.split('?')[0] + '?v=' + Date.now();
}

function openSettings() {
  hideStartMenu();
  const currentBg = localStorage.getItem('algo-bg-color') || '#008080';
  createWindow({
    title: 'Settings',
    icon: 'âš™ï¸',
    width: 350,
    height: 250,
    content:
      '<div style="padding:20px;">' +
        '<h3>Settings</h3>' +
        '<label>Background Color:</label><br>' +
        '<input type="color" id="settings-bg" value="' + currentBg + '">' +
        '<button onclick="applySettings()" style="margin-left:10px;">Apply</button>' +
      '</div>'
  });
}

function applySettings() {
  const bg = document.getElementById('settings-bg').value;
  localStorage.setItem('algo-bg-color', bg);
  document.getElementById('desktop').style.background = bg;
  algoSpeak('Settings applied');
}

// ==================== PERSISTENCE ====================
function saveState() {
  const state = {
    savedFiles,
    installedPrograms,
    uninstalledSystemApps,
    apiKeys,
    windowStates
  };
  localStorage.setItem('algo-state-' + currentUser, JSON.stringify(state));
}

function loadState() {
  try {
    const saved = localStorage.getItem('algo-state-' + currentUser);
    if (saved) {
      const state = JSON.parse(saved);
      savedFiles = state.savedFiles || [];
      installedPrograms = state.installedPrograms || [];
      uninstalledSystemApps = state.uninstalledSystemApps || [];
      apiKeys = state.apiKeys || {};
      windowStates = state.windowStates || {};
    }
  } catch (e) {}

  // Apply saved background
  const bg = localStorage.getItem('algo-bg-color');
  if (bg) document.getElementById('desktop').style.background = bg;
}

// ==================== SYSTEM TRAY ====================
const systemTray = {
  icons: {},  // id -> { element, onClick, onContextMenu }

  add(id, icon, options = {}) {
    if (this.icons[id]) return this.icons[id].element;

    const el = document.createElement('div');
    el.className = 'tray-icon' + (options.className ? ' ' + options.className : '');
    el.innerHTML = icon;
    el.title = options.title || id;

    if (options.onClick) {
      el.onclick = options.onClick;
    }
    if (options.onContextMenu) {
      el.oncontextmenu = (e) => {
        e.preventDefault();
        options.onContextMenu(e);
      };
    }

    const container = document.getElementById('system-tray');
    if (container) container.appendChild(el);

    this.icons[id] = { element: el, ...options };
    return el;
  },

  remove(id) {
    const item = this.icons[id];
    if (item && item.element) {
      item.element.remove();
      delete this.icons[id];
    }
  },

  update(id, icon) {
    const item = this.icons[id];
    if (item && item.element) {
      item.element.innerHTML = icon;
    }
  },

  get(id) {
    return this.icons[id]?.element;
  }
};

// ==================== EYE BRIDGE ====================
let eyeBridgeWs = null;
let eyeBridgeReconnectTimer = null;
let eyeBridgeConnected = false;
let eyeBridgePingInterval = null;

function connectEyeBridge() {
  if (!sessionToken) return;
  if (eyeBridgeWs && eyeBridgeWs.readyState === WebSocket.OPEN) return;

  const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
  const wsUrl = `${protocol}//${location.host}/api/eye-bridge?token=${sessionToken}`;

  try {
    eyeBridgeWs = new WebSocket(wsUrl);

    eyeBridgeWs.onopen = () => {
      console.log('[EyeBridge] Connected');
      // Start keepalive ping every 25 seconds
      if (eyeBridgePingInterval) clearInterval(eyeBridgePingInterval);
      eyeBridgePingInterval = setInterval(() => {
        if (eyeBridgeWs && eyeBridgeWs.readyState === WebSocket.OPEN) {
          eyeBridgeWs.send('ping');
        }
      }, 25000);
    };

    eyeBridgeWs.onmessage = (event) => {
      const msg = event.data;

      if (msg === 'EYE_BRIDGE:ready') {
        eyeBridgeConnected = true;
        updateEyeTray();
        return;
      }

      // Handle eye commands from Claude
      // Format: EYE_CMD:id:expression
      if (msg.startsWith('EYE_CMD:')) {
        handleEyeCommand(msg.slice(8));
        return;
      }
    };

    eyeBridgeWs.onclose = () => {
      console.log('[EyeBridge] Disconnected');
      eyeBridgeConnected = false;
      if (eyeBridgePingInterval) {
        clearInterval(eyeBridgePingInterval);
        eyeBridgePingInterval = null;
      }
      updateEyeTray();
      scheduleEyeBridgeReconnect();
    };

    eyeBridgeWs.onerror = (err) => {
      console.error('[EyeBridge] Error:', err);
    };
  } catch (e) {
    console.error('[EyeBridge] Connect failed:', e);
    scheduleEyeBridgeReconnect();
  }
}

function scheduleEyeBridgeReconnect() {
  if (eyeBridgeReconnectTimer) return;
  eyeBridgeReconnectTimer = setTimeout(() => {
    eyeBridgeReconnectTimer = null;
    if (sessionToken) connectEyeBridge();
  }, 3000);
}

function handleEyeCommand(data) {
  // Parse id:expression
  const colonIdx = data.indexOf(':');
  if (colonIdx === -1) return;

  const id = data.slice(0, colonIdx);
  const expression = data.slice(colonIdx + 1);

  // Visual feedback - blink the eye
  blinkEyeTray();

  // Execute and send response
  (async () => {
    try {
      let result = eval(expression);
      // Await promises
      if (result && typeof result.then === 'function') {
        result = await result;
      }

      // Serialize result
      let response;
      try {
        response = JSON.stringify(result);
      } catch (e) {
        response = String(result);
      }

      sendEyeResponse(id, response, false);
    } catch (e) {
      // Enhanced error with line number extraction
      let errorMsg = e.message || String(e);

      // Try to extract line number from stack
      if (e.stack) {
        const match = e.stack.match(/<anonymous>:(\d+):(\d+)/);
        if (match) {
          errorMsg += ` (line ${match[1]}, col ${match[2]})`;
        }
      }

      // For syntax errors, try to get more context
      if (e instanceof SyntaxError && expression) {
        const lines = expression.split('\n');
        if (lines.length > 1) {
          errorMsg += ` [${lines.length} lines]`;
        }
      }

      sendEyeResponse(id, errorMsg, true);
    }
  })();
}

function sendEyeResponse(id, result, isError) {
  if (!eyeBridgeWs || eyeBridgeWs.readyState !== WebSocket.OPEN) return;

  // Format: EYE:id:result or EYE:id!:error
  const sep = isError ? '!:' : ':';
  eyeBridgeWs.send(`EYE:${id}${sep}${result}`);
}

function updateEyeTray() {
  // Legacy taskbar tray
  let el = systemTray.get('eye');
  if (!el) {
    el = systemTray.add('eye', 'ğŸ‘ï¸<span class="eye-indicator"></span>', {
      className: 'eye-tray',
      title: 'Claude Eye Bridge',
      onClick: () => {
        // Try to open Claude Eyes app if it exists
        const eyeApp = systemApps.find(a => a.name.toLowerCase().includes('eye') || a.name.toLowerCase().includes('claude'));
        if (eyeApp) {
          loadSystemApp(eyeApp.file);
        } else {
          algoSpeak(eyeBridgeConnected ? 'Eye bridge connected' : 'Eye bridge disconnected');
        }
      }
    });
  }

  if (el) {
    el.classList.toggle('connected', eyeBridgeConnected);
    el.title = eyeBridgeConnected ? 'Claude Eye Bridge (connected)' : 'Claude Eye Bridge (disconnected)';
  }

  // Menubar status icon
  const menubarEye = document.getElementById('status-eye');
  if (menubarEye) {
    menubarEye.classList.toggle('connected', eyeBridgeConnected);
    menubarEye.title = eyeBridgeConnected ? 'Eye Bridge (connected)' : 'Eye Bridge (disconnected)';
  }
}

function blinkEyeTray() {
  const el = systemTray.get('eye');
  if (!el) return;

  el.classList.remove('active');
  void el.offsetWidth; // Force reflow
  el.classList.add('active');
}

// Disconnect eye bridge on logout
const originalLogout = logout;
logout = function() {
  if (eyeBridgeWs) {
    eyeBridgeWs.close();
    eyeBridgeWs = null;
  }
  eyeBridgeConnected = false;
  ShadowBridge.disconnect();
  originalLogout();
};

// ==================== SHADOW BRIDGE SERVICE ====================
const ShadowBridge = {
  ws: null,
  connected: false,
  ready: false,
  tabs: [],
  shadowTabs: new Map(), // tabId -> { url, shadowId }
  pendingRequests: {},
  trayVisible: false,
  MAX_SHADOW_TABS: 10,

  // Check if browser supports the extension (Chrome/Edge)
  isSupported() {
    const ua = navigator.userAgent;
    return /Chrome|Edg/.test(ua) && !/OPR|Opera/.test(ua);
  },

  // Initialize - only shows tray if supported
  init() {
    if (!this.isSupported()) return;
    this.connect();
  },

  connect() {
    if (!sessionToken) return;
    if (this.ws && this.ws.readyState === WebSocket.OPEN) return;

    const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
    const wsUrl = `${protocol}//${location.host}/api/content-bridge`;

    try {
      this.ws = new WebSocket(wsUrl);

      this.ws.onopen = () => {
        console.log('[ShadowBridge] Connected to server');
        this.send({ action: 'listTabs' });
      };

      this.ws.onmessage = (event) => {
        try {
          const msg = JSON.parse(event.data);
          this.handleMessage(msg);
        } catch (e) {
          console.error('[ShadowBridge] Parse error:', e);
        }
      };

      this.ws.onclose = () => {
        console.log('[ShadowBridge] Disconnected');
        this.connected = false;
        this.ready = false;
        this.updateTray();
        // Reconnect after delay
        setTimeout(() => this.connect(), 5000);
      };

      this.ws.onerror = () => {
        console.error('[ShadowBridge] WebSocket error');
      };
    } catch (e) {
      console.error('[ShadowBridge] Connect failed:', e);
    }
  },

  disconnect() {
    if (this.ws) {
      this.ws.close();
      this.ws = null;
    }
    this.connected = false;
    this.ready = false;
  },

  handleMessage(msg) {
    // Handle tab list (extension is connected) - check this FIRST
    // because tabList responses also have an id for request routing
    if (msg.action === 'tabList') {
      this.tabs = msg.tabs || [];
      if (!this.connected) {
        this.connected = true;
        this.ready = true;
        console.log('[ShadowBridge] Extension connected');
        this.showTray();
        this.updateTray();
      }
    }

    // Handle responses to pending requests
    if (msg.id && this.pendingRequests[msg.id]) {
      const { resolve, reject } = this.pendingRequests[msg.id];
      delete this.pendingRequests[msg.id];

      if (msg.error) {
        // Check for auth required
        if (msg.error === 'AUTH_REQUIRED') {
          reject(new Error('AUTH_REQUIRED'));
        } else {
          reject(new Error(msg.error));
        }
      } else {
        resolve(msg.result);
      }
    }
  },

  send(msg) {
    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
      return Promise.reject(new Error('Not connected'));
    }

    return new Promise((resolve, reject) => {
      const id = 'sb_' + Date.now() + '_' + Math.random().toString(36).slice(2);
      msg.id = id;
      this.pendingRequests[id] = { resolve, reject };

      // Timeout after 30s
      setTimeout(() => {
        if (this.pendingRequests[id]) {
          delete this.pendingRequests[id];
          reject(new Error('Request timeout'));
        }
      }, 30000);

      this.ws.send(JSON.stringify(msg));
    });
  },

  // Public API for apps
  get available() {
    return this.ready && this.connected;
  },

  async open(url, options = {}) {
    if (!this.available) {
      this.promptInstall();
      throw new Error('Shadow Bridge not available');
    }

    if (this.shadowTabs.size >= this.MAX_SHADOW_TABS) {
      throw new Error(`Maximum ${this.MAX_SHADOW_TABS} shadow tabs allowed`);
    }

    const shadowId = options.shadowId || 'shadow_' + Date.now();
    const result = await this.send({
      action: 'openShadow',
      data: { url, shadowId }
    });

    this.shadowTabs.set(result.tabId, { url, shadowId });
    this.pulseIcon();
    this.updateTray();
    return result;
  },

  async close(tabId) {
    if (!this.available) return;

    await this.send({
      action: 'closeShadow',
      data: { tabId }
    });
    this.shadowTabs.delete(tabId);
    this.updateTray();
  },

  async query(tabId, selector, all = true) {
    if (!this.available) throw new Error('Shadow Bridge not available');

    this.pulseIcon();
    return await this.send({
      action: 'query',
      tabId,
      data: { selector, all }
    });
  },

  async getContent(tabId) {
    if (!this.available) throw new Error('Shadow Bridge not available');

    this.pulseIcon();
    return await this.send({
      action: 'getContent',
      tabId
    });
  },

  async click(tabId, selector) {
    if (!this.available) throw new Error('Shadow Bridge not available');

    return await this.send({
      action: 'click',
      tabId,
      data: { selector }
    });
  },

  // Convenience method: open, wait, query, close
  async fetch(url, options = {}) {
    const { selector, waitFor = 3000 } = options;

    const tab = await this.open(url);
    await new Promise(r => setTimeout(r, waitFor));

    let result;
    if (selector) {
      result = await this.query(tab.tabId, selector);
    } else {
      result = await this.getContent(tab.tabId);
    }

    if (!options.keepOpen) {
      await this.close(tab.tabId);
    }

    return result;
  },

  // Tray management
  showTray() {
    if (this.trayVisible) return;
    this.trayVisible = true;

    // Legacy taskbar tray
    systemTray.add('shadow', 'ğŸ‘»<span class="shadow-indicator"></span>', {
      className: 'shadow-tray',
      title: 'Shadow Bridge',
      onClick: () => this.showPanel()
    });

    // Menubar status icon
    const menubarShadow = document.getElementById('status-shadow');
    if (menubarShadow) {
      menubarShadow.style.display = '';
      menubarShadow.onclick = () => this.showPanel();
    }
  },

  updateTray() {
    // Legacy taskbar tray
    const el = systemTray.get('shadow');
    if (el) {
      el.classList.toggle('connected', this.connected);
      el.title = this.connected
        ? `Shadow Bridge (${this.shadowTabs.size} tabs)`
        : 'Shadow Bridge (disconnected)';
    }

    // Menubar status icon
    const menubarShadow = document.getElementById('status-shadow');
    if (menubarShadow) {
      menubarShadow.classList.toggle('active', this.connected && this.shadowTabs.size > 0);
      menubarShadow.title = this.connected
        ? `Shadow Tabs (${this.shadowTabs.size} active)`
        : 'Shadow Tabs (disconnected)';
    }
  },

  pulseIcon() {
    // Legacy taskbar tray
    const el = systemTray.get('shadow');
    if (el) {
      el.classList.remove('active');
      void el.offsetWidth;
      el.classList.add('active');
    }

    // Menubar status icon
    const menubarShadow = document.getElementById('status-shadow');
    if (menubarShadow) {
      menubarShadow.classList.remove('pulse');
      void menubarShadow.offsetWidth;
      menubarShadow.classList.add('pulse');
    }
  },

  showPanel() {
    // Show status and instructions
    const tabs = Array.from(this.shadowTabs.entries()).map(([id, info]) =>
      `â€¢ ${info.url.slice(0, 40)}... (${id})`
    ).join('\n') || 'No active shadow tabs';

    const status = this.connected
      ? `âœ… Connected\n\nActive Shadow Tabs:\n${tabs}`
      : `âŒ Extension not connected\n\nğŸ“‹ To install:\n1. Open chrome://extensions\n2. Enable Developer mode\n3. Load unpacked: functionserver/extension\n4. Click the extension, set server URL\n5. Refresh this page`;

    algoSpeak(status);
  },

  promptInstall() {
    if (!this.isSupported()) return;
    if (this.connected) return;

    algoSpeak('Shadow Bridge extension needed. Click ğŸ‘» in taskbar for instructions.');
    this.showTray();
    this.updateTray();
  }
};

// Export for apps
window.ShadowBridge = ShadowBridge;

// ==================== BOOT ====================
checkSession();
</script>
</body>
</html>
