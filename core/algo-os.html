<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Function Server</title>
<link rel="stylesheet" href="algo-os.css">
</head>
<body>

<!-- Login Overlay -->
<div id="login-overlay" style="display:none;">
  <div class="login-dialog">
    <h2>ğŸ–¥ï¸ Function Server</h2>
    <div class="tabs">
      <div class="tab active" data-tab="login" onclick="showLoginTab('login')">Login</div>
      <div class="tab" data-tab="register" onclick="showLoginTab('register')">Register</div>
    </div>
    <div id="login-form">
      <label>Username:</label>
      <input type="text" id="login-username" autocomplete="username">
      <label>Password:</label>
      <input type="password" id="login-password" autocomplete="current-password">
      <div style="margin:8px 0;display:flex;align-items:center;gap:6px;">
        <input type="checkbox" id="login-system-user" style="width:auto;margin:0;">
        <label for="login-system-user" style="font-size:12px;color:#888;cursor:pointer;margin:0;">System User (Linux admin login)</label>
      </div>
      <div class="buttons">
        <button onclick="doLogin()">Login</button>
      </div>
    </div>
    <div id="register-form" style="display:none;">
      <label>Username:</label>
      <input type="text" id="reg-username" autocomplete="username">
      <label>Password:</label>
      <input type="password" id="reg-password" autocomplete="new-password">
      <label>Confirm:</label>
      <input type="password" id="reg-confirm" autocomplete="new-password">
      <div class="buttons">
        <button onclick="doRegister()">Create Account</button>
      </div>
    </div>
    <div id="login-error" class="error"></div>
  </div>
</div>

<div id="user-indicator"></div>
<div id="desktop"></div>
<div id="toast-container"></div>

<div id="taskbar">
  <div id="start-btn" onclick="toggleStartMenu()">
    <span style="font-size:14px;">ğŸ–¥ï¸</span> Start
  </div>
  <div id="taskbar-windows"></div>
  <div id="system-tray"></div>
  <div id="clock"></div>
</div>

<div id="start-menu">
  <div class="start-sidebar">FunctionServer</div>
  <div class="start-items">
    <div class="start-item has-sub" onclick="toggleSubmenu(event, this)" onmouseenter="openSubmenu(this)" onmouseleave="closeSubmenuDelay(this)">
      <span>ğŸ“</span> Programs
      <div class="start-submenu" id="programs-menu">
        <div class="start-item" onclick="openNotepad()"><span>ğŸ“</span> Notepad</div>
        <div class="start-item" onclick="openJSIDE()"><span>ğŸ’»</span> javascript.ide</div>
        <div class="start-item" onclick="openBrowser()"><span>ğŸŒ</span> Web Browser</div>
        <div class="start-separator"></div>
        <div id="installed-programs-menu"></div>
      </div>
    </div>
    <div class="start-item" onclick="openDocumentation()"><span style="color:#8B0000;">ğŸ“•</span> Documentation</div>
    <div class="start-item" onclick="openHelp()"><span style="color:#8B0000;">ğŸ“™</span> Help</div>
    <div class="start-separator"></div>
    <div class="start-item" onclick="showAbout()"><span>â„¹ï¸</span> About</div>
    <div class="start-item" onclick="openSettings()"><span>âš™ï¸</span> Settings</div>
    <div class="start-separator"></div>
    <div class="start-item" id="start-menu-auth" onclick="logout()"><span>ğŸšª</span> Log Out</div>
  </div>
</div>

<div id="context-menu"></div>

<script>
// ==================== CONFIG ====================
const API_BASE = '/api';
let currentUser = null;
let sessionToken = null;

// ==================== STATE ====================
let windows = [];
let winId = 0;
let activeWin = null;
let savedFiles = [];
let installedPrograms = [];
let systemApps = [];
let uninstalledSystemApps = [];
let windowStates = {};
let apiKeys = {};
let dragWin = null;
let dragOffset = { x: 0, y: 0 };
let contextTarget = null;
let submenuCloseTimeout = null;
let topZIndex = 100;  // Track highest z-index for window stacking

// Expose key state on window for dynamically loaded apps (Studio, etc.)
Object.defineProperty(window, 'savedFiles', { get: () => savedFiles, set: v => savedFiles = v });
Object.defineProperty(window, 'windows', { get: () => windows });
Object.defineProperty(window, 'systemApps', { get: () => systemApps });

// ==================== FILE API ====================
// Desktop files now live on disk at ~/

async function fetchDesktopFiles() {
  if (!sessionToken) return [];
  try {
    const res = await fetch(API_BASE + '/files/list?path=~/', {
      headers: { 'Authorization': 'Bearer ' + sessionToken }
    });
    if (!res.ok) return [];
    const data = await res.json();
    return (data.files || []).filter(f => f.type === 'file').map(f => ({
      name: f.name,
      path: '~/' + f.name,
      size: f.size,
      modified: f.modified,
      type: 'disk'
    }));
  } catch (e) {
    console.error('Failed to fetch files:', e);
    return [];
  }
}

async function saveFileToDisk(name, content) {
  if (!sessionToken) { algoSpeak('Not logged in'); return false; }
  try {
    const res = await fetch(API_BASE + '/files/save', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': 'Bearer ' + sessionToken
      },
      body: JSON.stringify({ path: '~/' + name, content: content })
    });
    return res.ok;
  } catch (e) {
    console.error('Failed to save file:', e);
    return false;
  }
}

async function getFileFromDisk(path) {
  if (!sessionToken) return null;
  try {
    const res = await fetch(API_BASE + '/files/get?path=' + encodeURIComponent(path), {
      headers: { 'Authorization': 'Bearer ' + sessionToken }
    });
    if (!res.ok) return null;
    const data = await res.json();
    return data.content;
  } catch (e) {
    console.error('Failed to get file:', e);
    return null;
  }
}

async function deleteFileFromDisk(path) {
  if (!sessionToken) return false;
  try {
    const res = await fetch(API_BASE + '/files/delete', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': 'Bearer ' + sessionToken
      },
      body: JSON.stringify({ path: path })
    });
    return res.ok;
  } catch (e) {
    console.error('Failed to delete file:', e);
    return false;
  }
}

// File type registry
let fileTypeRegistry = {
  'txt': { icon: 'ğŸ“„', app: 'Notepad' },
  'js': { icon: 'ğŸ’»', app: 'javascript.ide' },
  'html': { icon: 'ğŸŒ', app: 'Browser' },
  'json': { icon: 'ğŸ“‹', app: 'Notepad' },
  'md': { icon: 'ğŸ“', app: 'Notepad' },
  'png': { icon: 'ğŸ–¼ï¸', app: 'Image Viewer' },
  'jpg': { icon: 'ğŸ–¼ï¸', app: 'Image Viewer' },
  'gif': { icon: 'ğŸ–¼ï¸', app: 'Image Viewer' }
};

// ==================== PUBSUB ====================
// Inter-app communication system
const ALGO = window.ALGO || {};
ALGO.pubsub = {
  subscribers: {},      // topic -> [callback, ...]
  queues: {},          // topic -> [messages waiting for subscriber]
  appRegistry: {},     // appName -> { autoOpen: bool, openFn: fn }

  // Register an app with the pubsub system
  register: function(appName, options = {}) {
    this.appRegistry[appName] = {
      autoOpen: options.autoOpen || false,
      openFn: options.openFn || null,
      running: true
    };
    // Deliver any queued messages
    if (this.queues[appName] && this.queues[appName].length > 0) {
      const queue = this.queues[appName];
      this.queues[appName] = [];
      queue.forEach(item => this.publish(appName, item.msg, item.options, item.from));
    }
  },

  // Unregister when app closes
  unregister: function(appName) {
    if (this.appRegistry[appName]) {
      this.appRegistry[appName].running = false;
    }
  },

  // Subscribe to messages for a topic
  subscribe: function(topic, callback) {
    if (!this.subscribers[topic]) {
      this.subscribers[topic] = [];
    }
    this.subscribers[topic].push(callback);
    return () => {
      this.subscribers[topic] = this.subscribers[topic].filter(cb => cb !== callback);
    };
  },

  // Publish a message to a topic
  publish: function(topic, msg, options = {}, from = null) {
    const { autoOpen = false, queue = true, timeout = 5000 } = options;

    const callbacks = this.subscribers[topic] || [];
    const app = this.appRegistry[topic];

    // If no subscribers and app not running
    if (callbacks.length === 0 && (!app || !app.running)) {
      // Try to auto-open the app
      if (autoOpen && app && app.openFn) {
        app.openFn();
        // Queue message to be delivered after app opens
        if (!this.queues[topic]) this.queues[topic] = [];
        this.queues[topic].push({ msg, options, from, timestamp: Date.now() });
        return { status: 'queued', reason: 'app opening' };
      }
      // Queue for later if requested
      if (queue) {
        if (!this.queues[topic]) this.queues[topic] = [];
        this.queues[topic].push({ msg, options, from, timestamp: Date.now() });
        // Clean old messages after timeout
        setTimeout(() => {
          if (this.queues[topic]) {
            this.queues[topic] = this.queues[topic].filter(m => Date.now() - m.timestamp < timeout);
          }
        }, timeout);
        return { status: 'queued', reason: 'no subscribers' };
      }
      return { status: 'dropped', reason: 'no subscribers' };
    }

    // Deliver to all subscribers
    callbacks.forEach(cb => {
      try {
        cb(msg, from);
      } catch (e) {
        console.error('Pubsub callback error:', e);
      }
    });

    return { status: 'delivered', count: callbacks.length };
  },

  // Request-response pattern
  request: function(topic, msg, options = {}) {
    return new Promise((resolve, reject) => {
      const timeout = options.timeout || 5000;
      const requestId = Date.now() + '-' + Math.random().toString(36).substr(2, 9);
      const responseTopic = '_response_' + requestId;

      const timer = setTimeout(() => {
        unsubscribe();
        reject(new Error('Request timeout'));
      }, timeout);

      const unsubscribe = this.subscribe(responseTopic, (response) => {
        clearTimeout(timer);
        unsubscribe();
        resolve(response);
      });

      this.publish(topic, { ...msg, _requestId: requestId, _responseTopic: responseTopic }, options);
    });
  },

  // Respond to a request
  respond: function(originalMsg, response) {
    if (originalMsg._responseTopic) {
      this.publish(originalMsg._responseTopic, response);
    }
  }
};

// ==================== BRIDGE ====================
// Direct JS VM access for terminal-based agents (Claude Code)
ALGO.bridge = {
  // Execute JavaScript code and return result
  eval: function(code) {
    try {
      const result = eval(code);
      // Handle non-serializable results
      if (result === undefined) {
        return { success: true, result: null, type: 'undefined' };
      }
      if (typeof result === 'function') {
        return { success: true, result: result.toString(), type: 'function' };
      }
      if (result instanceof Element) {
        return { success: true, result: result.outerHTML.substring(0, 1000), type: 'element' };
      }
      if (result instanceof NodeList || result instanceof HTMLCollection) {
        return { success: true, result: Array.from(result).map(e => e.outerHTML?.substring(0, 200) || String(e)), type: 'nodelist' };
      }
      return { success: true, result: result, type: typeof result };
    } catch(e) {
      return { success: false, error: e.message, stack: e.stack };
    }
  },

  // Query the DOM
  query: function(selector) {
    try {
      const el = document.querySelector(selector);
      if (!el) return { success: true, result: null };
      return {
        success: true,
        result: {
          tag: el.tagName,
          id: el.id,
          className: el.className,
          text: el.textContent?.substring(0, 500),
          html: el.outerHTML?.substring(0, 1000),
          rect: el.getBoundingClientRect()
        }
      };
    } catch(e) {
      return { success: false, error: e.message };
    }
  },

  // Query multiple elements
  queryAll: function(selector) {
    try {
      const els = document.querySelectorAll(selector);
      return {
        success: true,
        count: els.length,
        result: Array.from(els).slice(0, 50).map(el => ({
          tag: el.tagName,
          id: el.id,
          className: el.className,
          text: el.textContent?.substring(0, 100)
        }))
      };
    } catch(e) {
      return { success: false, error: e.message };
    }
  },

  // Get current state of the OS
  getState: function() {
    return {
      success: true,
      result: {
        user: currentUser,
        windows: windows.map(w => ({ id: w.id, title: w.title, minimized: w.minimized })),
        activeWindow: activeWin,
        systemApps: systemApps.map(a => ({ id: a.id, name: a.name, icon: a.icon })),
        pubsubApps: Object.keys(ALGO.pubsub.appRegistry).filter(k => ALGO.pubsub.appRegistry[k].running)
      }
    };
  },

  // Click an element
  click: function(selector) {
    try {
      const el = document.querySelector(selector);
      if (!el) return { success: false, error: 'Element not found: ' + selector };
      el.click();
      return { success: true, clicked: selector };
    } catch(e) {
      return { success: false, error: e.message };
    }
  },

  // Set value of an input
  setValue: function(selector, value) {
    try {
      const el = document.querySelector(selector);
      if (!el) return { success: false, error: 'Element not found: ' + selector };
      el.value = value;
      el.dispatchEvent(new Event('input', { bubbles: true }));
      el.dispatchEvent(new Event('change', { bubbles: true }));
      return { success: true, selector, value };
    } catch(e) {
      return { success: false, error: e.message };
    }
  },

  // Open an app by ID or name
  openApp: function(appIdOrName) {
    try {
      // Match by id, name, or case-insensitive name
      const app = systemApps.find(a =>
        a.id === appIdOrName ||
        a.name === appIdOrName ||
        a.name.toLowerCase() === appIdOrName.toLowerCase() ||
        a.id.toLowerCase() === appIdOrName.toLowerCase()
      );
      if (app) {
        runSystemApp(app.id);
        return { success: true, opened: app.id, name: app.name };
      }
      return { success: false, error: 'App not found: ' + appIdOrName };
    } catch(e) {
      return { success: false, error: e.message };
    }
  },

  // Focus a window by ID
  focusWindow: function(winId) {
    try {
      focusWindow(winId);
      return { success: true, focused: winId };
    } catch(e) {
      return { success: false, error: e.message };
    }
  },

  // Close a window by ID
  closeWindow: function(winId) {
    try {
      closeWindow(winId);
      return { success: true, closed: winId };
    } catch(e) {
      return { success: false, error: e.message };
    }
  }
};

// ==================== LENS ====================
// Token-efficient API for AI agents
ALGO.lens = {
  // Persistent helper registry
  helpers: {},

  // Define a reusable helper function
  define: function(name, fn) {
    if (typeof fn === 'string') {
      this.helpers[name] = new Function('return ' + fn)();
    } else {
      this.helpers[name] = fn;
    }
    return 'âœ“ ' + name;
  },

  // Call a defined helper
  call: function(name, ...args) {
    if (!this.helpers[name]) return 'âœ— ' + name + ' not defined';
    try {
      return this.helpers[name](...args);
    } catch(e) {
      return 'âœ— ' + e.message;
    }
  },

  // Compact state query - one line output
  state: function() {
    const w = windows.filter(w => !w.minimized).map(w => w.title?.substring(0,12) || w.appName).join('|');
    const errs = document.querySelectorAll('.error:not(:empty), [class*="error"]:not(:empty)').length;
    return `w:${w || 'none'} e:${errs} u:${currentUser || 'guest'}`;
  },

  // Dashboard - compact status
  dash: function() {
    const wins = windows.map(w => (w.minimized ? '(' : '') + (w.title?.substring(0,8) || w.appName) + (w.minimized ? ')' : '')).join('|');
    const apps = systemApps.slice(0, 5).map(a => a.icon).join('');
    return `[${wins || 'desktop'}] ${apps}`;
  },

  // Render DOM to text grid with coordinates
  look: function(selector, opts = {}) {
    const el = document.querySelector(selector || 'body');
    if (!el) return 'âœ— not found: ' + selector;

    const width = opts.width || 60;
    const height = opts.height || 20;
    const rect = el.getBoundingClientRect();

    // Gather interactive elements
    const interactive = el.querySelectorAll('button, a, input, [onclick], [role="button"], .clickable');
    const items = [];

    interactive.forEach((e, i) => {
      const r = e.getBoundingClientRect();
      const x = Math.floor((r.left - rect.left) / rect.width * width);
      const y = Math.floor((r.top - rect.top) / rect.height * height);
      const text = (e.textContent || e.value || e.placeholder || e.title || '').trim().substring(0, 20);
      if (text && x >= 0 && x < width && y >= 0 && y < height) {
        items.push({ x, y, text, tag: e.tagName, el: e });
      }
    });

    // Build grid
    const grid = Array(height).fill(null).map(() => Array(width).fill(' '));
    items.forEach(item => {
      for (let i = 0; i < item.text.length && item.x + i < width; i++) {
        grid[item.y][item.x + i] = item.text[i];
      }
    });

    // Format with row numbers
    let out = items.length + ' elements\n';
    out += '  ' + '0123456789'.repeat(Math.ceil(width / 10)).substring(0, width) + '\n';
    grid.forEach((row, i) => {
      out += String(i).padStart(2) + 'â”‚' + row.join('') + '\n';
    });

    // Store for inspect()
    this._lastLook = { selector, items, rect };
    return out;
  },

  // Inspect what's at a position (row, col) from last look()
  at: function(row, col) {
    if (!this._lastLook) return 'âœ— call look() first';

    const { items } = this._lastLook;
    const found = items.filter(item => {
      return item.y === row && col >= item.x && col < item.x + item.text.length;
    });

    if (found.length === 0) return '(empty)';

    return found.map(item => {
      const el = item.el;
      const actions = [];
      if (el.onclick || el.tagName === 'BUTTON' || el.tagName === 'A') actions.push('click');
      if (el.tagName === 'INPUT') actions.push('type');
      if (el.href) actions.push('href:' + el.href.substring(0, 30));

      return `${item.tag}:"${item.text}" [${actions.join(',')}]`;
    }).join(' | ');
  },

  // Click at position from last look()
  click: function(row, col) {
    if (!this._lastLook) return 'âœ— call look() first';

    const { items } = this._lastLook;
    const found = items.find(item => {
      return item.y === row && col >= item.x && col < item.x + item.text.length;
    });

    if (!found) return 'âœ— nothing at ' + row + ',' + col;

    found.el.click();
    return 'âœ“ clicked "' + found.text + '"';
  },

  // Batch operations - run multiple lens commands
  batch: function(ops) {
    const results = [];
    for (const op of ops) {
      const [method, ...args] = op;
      if (typeof this[method] === 'function') {
        results.push('âœ“' + method);
        this[method](...args);
      } else if (this.helpers[method]) {
        results.push('âœ“' + method);
        this.helpers[method](...args);
      } else {
        results.push('âœ—' + method);
      }
    }
    return results.join(' ');
  },

  // Get all interactive elements in a selector
  actions: function(selector) {
    const el = document.querySelector(selector || 'body');
    if (!el) return 'âœ— not found';

    const interactive = el.querySelectorAll('button, a, input, select, textarea, [onclick], [role="button"]');
    const actions = [];

    interactive.forEach((e, i) => {
      const text = (e.textContent || e.value || e.placeholder || e.title || e.className || '').trim().substring(0, 25);
      if (text) {
        const type = e.tagName === 'INPUT' ? e.type : e.tagName.toLowerCase();
        actions.push(`${i}:${type}:"${text}"`);
      }
    });

    return actions.slice(0, 30).join('\n') || '(no actions)';
  },

  // Execute action by index from actions() output
  do: function(selector, index) {
    const el = document.querySelector(selector || 'body');
    if (!el) return 'âœ— not found';

    const interactive = el.querySelectorAll('button, a, input, select, textarea, [onclick], [role="button"]');
    if (index >= interactive.length) return 'âœ— index out of range';

    const target = interactive[index];
    if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA') {
      target.focus();
      return 'âœ“ focused';
    }
    target.click();
    return 'âœ“ clicked';
  },

  // === GIT SHORTCUTS (use ALGO.exec, work without Studio) ===

  // Get project root from a file path
  _projectRoot: function(path) {
    if (!path) return null;
    const match = path.match(/~\/repos\/([^\/]+)/);
    return match ? '~/repos/' + match[1] : null;
  },

  // Git commit with message
  commit: async function(msg, path) {
    const root = this._projectRoot(path) || (typeof Studio !== 'undefined' && Studio.getTabs?.()[0] ? this._projectRoot(Studio.getTabs()[0]) : null);
    if (!root) return 'âœ— no project detected';
    if (!msg) return 'âœ— provide commit message';
    const result = await ALGO.exec('git -C ' + root + ' add -A && git -C ' + root + ' commit -m "' + msg.replace(/"/g, '\\"') + '"');
    return result.includes('nothing to commit') ? 'âœ“ nothing to commit' : 'âœ“ committed';
  },

  // Git push to origin
  push: async function(path) {
    const root = this._projectRoot(path) || (typeof Studio !== 'undefined' && Studio.getTabs?.()[0] ? this._projectRoot(Studio.getTabs()[0]) : null);
    if (!root) return 'âœ— no project detected';
    if (!ALGO.github.isConfigured()) return 'âœ— GitHub not configured';
    const result = await ALGO.exec('git -C ' + root + ' push origin HEAD 2>&1');
    return result.includes('->') ? 'âœ“ pushed' : result.includes('up-to-date') ? 'âœ“ up-to-date' : 'âœ— ' + result.slice(0, 100);
  },

  // Git diff - show uncommitted changes
  diff: async function(path) {
    const root = this._projectRoot(path) || (typeof Studio !== 'undefined' && Studio.getTabs?.()[0] ? this._projectRoot(Studio.getTabs()[0]) : null);
    if (!root) return 'âœ— no project detected';
    const result = await ALGO.exec('git -C ' + root + ' diff --stat');
    return result.trim() || '(no changes)';
  },

  // Git status - short format
  gitStatus: async function(path) {
    const root = this._projectRoot(path) || (typeof Studio !== 'undefined' && Studio.getTabs?.()[0] ? this._projectRoot(Studio.getTabs()[0]) : null);
    if (!root) return 'âœ— no project detected';
    const result = await ALGO.exec('git -C ' + root + ' status -s');
    return result.trim() || '(clean)';
  },

  // Git log - recent commits
  log: async function(n = 5, path) {
    const root = this._projectRoot(path) || (typeof Studio !== 'undefined' && Studio.getTabs?.()[0] ? this._projectRoot(Studio.getTabs()[0]) : null);
    if (!root) return 'âœ— no project detected';
    return await ALGO.exec('git -C ' + root + ' log --oneline -' + n);
  }
};
window.Lens = ALGO.lens;

window.ALGO = ALGO;

// ==================== AI EYES ====================
// Visual feedback for AI actions - shows humans what AI is looking at/editing
// Effects are silent side-effects, don't pollute return values
ALGO.eyes = {
  _initialized: false,
  _init() {
    if (this._initialized) return;
    const style = document.createElement('style');
    style.id = 'ai-eyes-styles';
    style.textContent = `
      @keyframes ai-saccade { 0% { opacity: 0; } 20% { opacity: 0.35; } 100% { opacity: 0; } }
      @keyframes ai-edit { 0% { box-shadow: inset 0 0 0 2px rgba(100,255,100,0.5); } 100% { box-shadow: none; } }
      @keyframes ai-delete { 0% { opacity: 0.8; transform: translateX(0); } 100% { opacity: 0; transform: translateX(20px); } }
      .ai-eye-box { position: fixed; pointer-events: none; border: 2px solid rgba(167,139,250,0.5); border-radius: 3px; animation: ai-saccade 0.5s ease-out forwards; z-index: 99999; }
      .ai-eye-edit { animation: ai-edit 0.4s ease-out forwards !important; }
      .ai-eye-ghost { position: fixed; pointer-events: none; animation: ai-delete 0.3s ease-out forwards; z-index: 99999; background: rgba(255,100,100,0.15); border-radius: 2px; }
    `;
    document.head.appendChild(style);
    this._initialized = true;
  },

  // Silent highlight - fire and forget
  look(el) {
    this._init();
    if (typeof el === 'string') el = document.querySelector(el);
    if (!el) return;
    const r = el.getBoundingClientRect();
    const box = document.createElement('div');
    box.className = 'ai-eye-box';
    box.style.cssText = `left:${r.left}px;top:${r.top}px;width:${r.width}px;height:${r.height}px`;
    document.body.appendChild(box);
    setTimeout(() => box.remove(), 500);
  },

  // Silent edit flash
  edit(el) {
    this._init();
    if (typeof el === 'string') el = document.querySelector(el);
    if (!el) return;
    el.classList.add('ai-eye-edit');
    setTimeout(() => el.classList.remove('ai-eye-edit'), 400);
  },

  // Silent delete ghost
  evaporate(el) {
    this._init();
    if (typeof el === 'string') el = document.querySelector(el);
    if (!el) return;
    const r = el.getBoundingClientRect();
    const ghost = document.createElement('div');
    ghost.className = 'ai-eye-ghost';
    ghost.style.cssText = `left:${r.left}px;top:${r.top}px;width:${r.width}px;height:${r.height}px`;
    document.body.appendChild(ghost);
    setTimeout(() => ghost.remove(), 300);
  },

  // Highlight editor region by line range
  codeRegion(startLine, count) {
    this._init();
    const ta = document.querySelector('#studio-code');
    if (!ta) return;
    const r = ta.getBoundingClientRect();
    const lineHeight = parseFloat(getComputedStyle(ta).lineHeight) || 18;
    const top = r.top + (startLine - 1) * lineHeight;
    const height = Math.min(count * lineHeight, r.height);
    const box = document.createElement('div');
    box.className = 'ai-eye-box';
    box.style.cssText = `left:${r.left}px;top:${Math.max(r.top, top)}px;width:${r.width}px;height:${height}px`;
    document.body.appendChild(box);
    setTimeout(() => box.remove(), 500);
  },

  // Wrap Lens functions to add visual feedback (called after Studio loads)
  wrapLens() {
    if (!Lens.code || Lens._eyesWrapped) return;
    const wrap = (name, before, after) => {
      const orig = Lens[name]?.bind(Lens);
      if (orig) Lens[name] = function(...args) {
        if (before) before(...args);
        const result = orig(...args);
        if (after) Promise.resolve(result).then(r => after(r, ...args));
        return result;
      };
    };
    wrap('code', (s, n) => this.codeRegion(s || 1, n || 20));
    wrap('setLine', (n) => this.codeRegion(n, 1), () => this.edit(document.querySelector('#studio-code')));
    wrap('insertLine', (n) => this.codeRegion(n, 1));
    wrap('deleteLine', (n) => this.codeRegion(n, 1));
    Lens._eyesWrapped = true;
  }
};

// Eye shortcuts - terse helpers for eye CLI
window.$ = s => document.querySelector(s);
window.$$ = s => [...document.querySelectorAll(s)];
window.apps = () => systemApps.map(a => a.name);
window.wins = () => windows.map(w => ({id: w.id, title: w.title, app: w.appName}));

// ==================== CORE UTILITIES ====================
// Shell execution - available without loading Studio
ALGO.exec = async function(cmd) {
  if (!sessionToken) return 'Error: Not logged in';
  try {
    const r = await fetch(API_BASE + '/terminal/exec', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', 'Authorization': 'Bearer ' + sessionToken },
      body: JSON.stringify({ command: cmd, cwd: '~' })
    });
    if (r.ok) {
      const data = await r.json();
      return data.output || data.error || '';
    }
    return 'Request failed: ' + r.status;
  } catch(e) { return 'Error: ' + e.message; }
};

// GitHub auth - read token from localStorage without loading github-auth.js
ALGO.github = {
  STORAGE_KEY: 'fs_github_auth',
  _load() { try { return JSON.parse(localStorage.getItem(this.STORAGE_KEY)) || {}; } catch { return {}; } },
  _save(auth) { localStorage.setItem(this.STORAGE_KEY, JSON.stringify(auth)); },
  getToken() { return this._load().token || null; },
  getUsername() { return this._load().username || null; },
  isConfigured() { const a = this._load(); return !!(a.token && a.username); },
  getAuthUrl(repoUrl) {
    const token = this.getToken();
    if (!token) return repoUrl;
    const m = repoUrl.match(/git@github\.com:(.+)\.git/);
    if (m) return 'https://' + token + '@github.com/' + m[1] + '.git';
    const h = repoUrl.match(/https:\/\/github\.com\/(.+)/);
    if (h) return 'https://' + token + '@github.com/' + h[1];
    return repoUrl;
  }
};

// setupHappyPath - one-command project creation, available globally
window.setupHappyPath = async function(projectName) {
  // Load Studio if needed
  if (typeof Studio === 'undefined') {
    const code = await getFileFromDisk('~/studio.js');
    if (code) await runApp(code, 'studio.js');
  }

  // If no project name, just load tools
  if (!projectName) {
    console.log('Tools loaded. Use Lens.help() for commands.');
    return 'Happy path ready!';
  }

  // Slugify: "pixel draw" -> "pixel-draw"
  const slug = projectName.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '');
  const repoPath = '~/repos/' + slug;

  // Check if exists
  const exists = await ALGO.exec('ls ' + repoPath + ' 2>/dev/null && echo yes || echo no');

  if (exists.trim() === 'no') {
    console.log('Creating new project: ' + slug);

    // Create folder and init
    await ALGO.exec('mkdir -p ' + repoPath);
    await ALGO.exec('git -C ' + repoPath + ' init');

    // Create skeleton files
    const appCode = '// ' + projectName + '\nALGO.app.name = "' + projectName + '";\nALGO.app.icon = "*";\n\nALGO.createWindow({\n  title: "' + projectName + '",\n  width: 400,\n  height: 300,\n  content: "<div style=\'padding:20px\'>Hello from ' + projectName + '!</div>"\n});';
    const readmeCode = '# ' + projectName + '\n\nA FunctionServer app.\n\n## Run\n\nOpen main.js in Studio and use Lens.run()';

    await saveFileToDisk('repos/' + slug + '/main.js', appCode);
    await saveFileToDisk('repos/' + slug + '/README.md', readmeCode);

    // Initial commit
    await ALGO.exec('git -C ' + repoPath + ' add -A');
    await ALGO.exec('git -C ' + repoPath + ' commit -m "Initial commit: ' + projectName + ' skeleton"');

    // If GitHub configured, create repo and push
    if (ALGO.github.isConfigured()) {
      const username = ALGO.github.getUsername();
      const token = ALGO.github.getToken();
      console.log('Creating GitHub repo: ' + username + '/' + slug);

      await ALGO.exec('curl -s -X POST -H "Authorization: token ' + token + '" -H "Accept: application/vnd.github.v3+json" https://api.github.com/user/repos -d \'{"name":"' + slug + '","private":false}\'');

      const remoteUrl = 'https://' + token + '@github.com/' + username + '/' + slug + '.git';
      await ALGO.exec('git -C ' + repoPath + ' remote add origin ' + remoteUrl);
      await ALGO.exec('git -C ' + repoPath + ' push -u origin master 2>&1 || git -C ' + repoPath + ' push -u origin main 2>&1');
      console.log('Pushed to GitHub: github.com/' + username + '/' + slug);
    } else {
      console.log('GitHub not configured. Use GitHub Auth app to enable push.');
    }
  } else {
    console.log('Opening existing project: ' + slug);
  }

  // Open in Studio - find main file for existing projects
  if (typeof Studio !== 'undefined') {
    let mainFile = repoPath + '/main.js';

    // For existing projects, find the first .js file if main.js doesn't exist
    const files = await ALGO.exec('ls ' + repoPath + '/*.js 2>/dev/null');
    if (files.trim()) {
      const jsFiles = files.trim().split('\n').filter(f => !f.includes('node_modules'));
      if (jsFiles.length > 0) {
        // Prefer main.js, index.js, app.js, or first found
        const basename = f => f.split('/').pop();
        const preferred = jsFiles.find(f => ['main.js', 'index.js', 'app.js'].includes(basename(f)));
        mainFile = preferred || jsFiles[0];
        // Convert full path to ~/repos/... format
        mainFile = mainFile.replace(/^\/home\/[^\/]+\//, '~/');
      }
    }

    Studio.close(mainFile);
    Studio.open(mainFile);
  }
  return 'Project ready: ' + slug;
};

// ==================== GUARDIAN - Console Monitor ====================
// Watches for errors/warnings, offers AI help with throttling
ALGO.guardian = {
  _watching: false,
  _callback: null,
  _throttleMs: 2000,
  _lastSent: 0,
  _lastMsg: '',
  _suppressedCount: 0,
  _origError: null,
  _origWarn: null,
  _origOnError: null,

  watch(callback) {
    if (this._watching) return 'Already watching';
    this._watching = true;
    this._callback = callback;
    this._suppressedCount = 0;

    // Store originals
    this._origError = console.error;
    this._origWarn = console.warn;
    this._origOnError = window.onerror;

    const self = this;

    // Hook console.error
    console.error = function(...args) {
      self._origError.apply(console, args);
      self._onMessage('error', args.map(a => String(a)).join(' '));
    };

    // Hook console.warn
    console.warn = function(...args) {
      self._origWarn.apply(console, args);
      self._onMessage('warn', args.map(a => String(a)).join(' '));
    };

    // Hook window.onerror
    window.onerror = function(msg, src, line, col, err) {
      if (self._origOnError) self._origOnError(msg, src, line, col, err);
      self._onMessage('error', msg + (src ? ' at ' + src + ':' + line : ''));
    };

    return 'Guardian watching';
  },

  _onMessage(level, msg) {
    const now = Date.now();

    // Dedupe: skip if same message within throttle window
    if (msg === this._lastMsg && now - this._lastSent < this._throttleMs) {
      this._suppressedCount++;
      return;
    }

    // Throttle: skip if too soon
    if (now - this._lastSent < this._throttleMs) {
      this._suppressedCount++;
      return;
    }

    this._lastSent = now;
    this._lastMsg = msg;

    // Call callback if provided
    if (this._callback) {
      const suppressed = this._suppressedCount;
      this._suppressedCount = 0;
      this._callback({ level, msg, suppressed });
    }

    // Show help toast for errors
    if (level === 'error') {
      this._offerHelp(msg);
    }
  },

  _offerHelp(errorMsg) {
    // Create toast
    const toast = document.createElement('div');
    toast.className = 'guardian-toast';
    toast.innerHTML =
      '<div style="font-weight:500;color:#f87171;">Error detected</div>' +
      '<div style="font-size:12px;color:#a1a1aa;margin:6px 0;max-height:60px;overflow:hidden;text-overflow:ellipsis;">' +
        errorMsg.slice(0, 150) + (errorMsg.length > 150 ? '...' : '') +
      '</div>' +
      '<div style="display:flex;gap:8px;margin-top:8px;">' +
        '<button onclick="ALGO.guardian._acceptHelp(this.closest(\'.guardian-toast\'))" style="flex:1;padding:6px 12px;background:#3b82f6;border:none;border-radius:4px;color:#fff;cursor:pointer;font-size:12px;">Get AI help</button>' +
        '<button onclick="this.closest(\'.guardian-toast\').remove()" style="padding:6px 12px;background:#27272a;border:1px solid #3f3f46;border-radius:4px;color:#a1a1aa;cursor:pointer;font-size:12px;">Dismiss</button>' +
      '</div>';
    toast.style.cssText = 'position:fixed;bottom:60px;right:20px;background:#18181b;border:1px solid #3f3f46;border-radius:8px;padding:12px 16px;width:300px;z-index:10001;box-shadow:0 4px 12px rgba(0,0,0,0.4);font:14px system-ui;color:#fafafa;animation:guardian-slide-in 0.3s ease-out;';

    // Add animation style if not present
    if (!document.getElementById('guardian-styles')) {
      const style = document.createElement('style');
      style.id = 'guardian-styles';
      style.textContent = '@keyframes guardian-slide-in { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } } @keyframes guardian-slide-out { from { transform: translateX(0); opacity: 1; } to { transform: translateX(100%); opacity: 0; } }';
      document.head.appendChild(style);
    }

    document.body.appendChild(toast);
    toast._errorMsg = errorMsg;

    // Auto-dismiss after 8 seconds
    setTimeout(() => {
      if (toast.parentNode) {
        toast.style.animation = 'guardian-slide-out 0.3s ease-out forwards';
        setTimeout(() => toast.remove(), 300);
      }
    }, 8000);
  },

  _acceptHelp(toast) {
    const errorMsg = toast._errorMsg;
    toast.remove();

    // Use algoSpeak to offer help (times out after 4s)
    algoSpeak('I noticed an error. Would you like me to help debug?', 4000);

    // Send to eye bridge if connected
    if (window.eyeBridge && window.eyeBridge.send) {
      window.eyeBridge.send(JSON.stringify({
        type: 'guardian',
        event: 'help_requested',
        error: errorMsg
      }));
    }
  },

  stop() {
    if (!this._watching) return 'Not watching';
    this._watching = false;

    // Restore originals
    if (this._origError) console.error = this._origError;
    if (this._origWarn) console.warn = this._origWarn;
    if (this._origOnError) window.onerror = this._origOnError;

    this._callback = null;
    return 'Guardian stopped. Suppressed ' + this._suppressedCount + ' messages.';
  },

  status() {
    return {
      watching: this._watching,
      suppressed: this._suppressedCount,
      throttleMs: this._throttleMs,
      lastMsg: this._lastMsg ? this._lastMsg.slice(0, 50) + '...' : null
    };
  }
};

// ==================== AUTH ====================
function checkSession() {
  const saved = localStorage.getItem('algo-session');
  if (saved) {
    try {
      const s = JSON.parse(saved);
      if (s.token && s.username) {
        fetch(API_BASE + '/auth/verify', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ token: s.token, username: s.username })
        }).then(r => r.json())
        .then(data => {
          if (data.valid) {
            loginSuccess(s.username, s.token, s.isSystemUser);
          } else {
            guestLogin();
          }
        }).catch(() => guestLogin());
        return;
      }
    } catch (e) {}
  }
  guestLogin();
}

function guestLogin() {
  currentUser = 'guest';
  sessionToken = null;
  hideLogin();
  document.getElementById('user-indicator').textContent = 'ğŸ‘¤ Guest';
  document.getElementById('start-menu-auth').innerHTML = '<span>ğŸ”‘</span> Login / Register';
  document.getElementById('start-menu-auth').onclick = showLogin;
  loadState();
  loadSystemApps();
  init();
}

function showLogin() {
  document.getElementById('login-overlay').style.display = 'flex';
}

function hideLogin() {
  document.getElementById('login-overlay').style.display = 'none';
}

function showLoginTab(tab) {
  document.querySelectorAll('.login-dialog .tab').forEach(t => t.classList.remove('active'));
  document.querySelector('.login-dialog .tab[data-tab="' + tab + '"]').classList.add('active');
  document.getElementById('login-form').style.display = tab === 'login' ? 'block' : 'none';
  document.getElementById('register-form').style.display = tab === 'register' ? 'block' : 'none';
  document.getElementById('login-error').textContent = '';
}

let isSystemUser = false;

function loginSuccess(username, token, systemUser) {
  currentUser = username;
  sessionToken = token;
  isSystemUser = systemUser || false;
  localStorage.setItem('algo-session', JSON.stringify({ username, token, isSystemUser }));
  hideLogin();
  const indicator = isSystemUser ? 'ğŸ”‘ ' + username + ' (system)' : 'ğŸ‘¤ ' + username;
  document.getElementById('user-indicator').innerHTML = indicator +
    ' <span class="copy-auth-btn" onclick="copyAuthInfo(event)" title="Copy auth token">ğŸ“‹</span>';
  document.getElementById('start-menu-auth').innerHTML = '<span>ğŸšª</span> Log Out (' + username + ')';
  loadState();
  loadSystemApps();
  init();
}

function copyAuthInfo(event) {
  event.stopPropagation();
  const server = window.location.origin.replace('https://', 'wss://').replace('http://', 'ws://') + '/api/eye';
  const config = JSON.stringify({ token: sessionToken, server: server }, null, 2);

  fetch('/core/apps/eye-instructions.txt').then(r => r.text()).then(template => {
    const instructions = template
      .replace('{{CONFIG}}', config)
      .replace('{{USER}}', currentUser)
      .replace('{{SERVER}}', server);
    navigator.clipboard.writeText(instructions).then(() => {
      algoSpeak('Copied eye instructions + config to clipboard');
    });
  }).catch(() => {
    // Fallback to just config if template not found
    navigator.clipboard.writeText(config).then(() => {
      algoSpeak('Copied eye config. Save to ~/.algo/config.json');
    });
  });
}

function doLogin() {
  const username = document.getElementById('login-username').value.trim();
  const password = document.getElementById('login-password').value;
  const isSystemUser = document.getElementById('login-system-user').checked;
  const error = document.getElementById('login-error');

  if (!username || !password) {
    error.textContent = 'Please enter username and password';
    return;
  }

  const endpoint = isSystemUser ? '/auth/system-login' : '/auth/login';

  fetch(API_BASE + endpoint, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ username, password })
  })
  .then(r => r.json())
  .then(data => {
    if (data.token) {
      loginSuccess(username, data.token, data.isSystemUser);
    } else {
      error.textContent = data.error || 'Login failed';
    }
  })
  .catch(e => {
    error.textContent = 'Connection error';
  });
}

function doRegister() {
  const username = document.getElementById('reg-username').value.trim();
  const password = document.getElementById('reg-password').value;
  const confirm = document.getElementById('reg-confirm').value;
  const error = document.getElementById('login-error');

  if (!username || !password) {
    error.textContent = 'Please fill all fields';
    return;
  }
  if (password !== confirm) {
    error.textContent = 'Passwords do not match';
    return;
  }

  fetch(API_BASE + '/register', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ username, password })
  })
  .then(r => r.json())
  .then(data => {
    if (data.token) {
      loginSuccess(username, data.token);
    } else {
      error.textContent = data.error || 'Registration failed';
    }
  })
  .catch(e => {
    error.textContent = 'Connection error';
  });
}

function logout() {
  hideStartMenu();
  localStorage.removeItem('algo-session');
  currentUser = null;
  sessionToken = null;
  location.reload();
}

// ==================== INIT ====================
async function init() {
  await createDesktopIcons();
  updateTaskbar();
  updateClock();
  setInterval(updateClock, 1000);

  // Global event listeners
  document.addEventListener('click', globalClick);
  document.addEventListener('mousemove', onDrag);
  document.addEventListener('mouseup', endDrag);
  document.addEventListener('contextmenu', handleContextMenu);
  document.addEventListener('keydown', handleKeyDown);

  setTimeout(() => algoSpeak("Welcome to Function Server!"), 1500);

  // Restore shader background if saved
  restoreShaderBackground();

  // Connect eye bridge for Claude integration
  connectEyeBridge();
  updateEyeTray();

  // Initialize shadow bridge for browser extension support
  ShadowBridge.init();
}

function restoreShaderBackground() {
  const code = localStorage.getItem('algo-shader-bg');
  if (!code) return;

  const canvas = document.createElement('canvas');
  canvas.id = 'shader-background';
  canvas.style.cssText = 'position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:-1;pointer-events:none;';
  document.body.appendChild(canvas);

  const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
  if (!gl) return;

  const vertSource = 'attribute vec2 a_position;void main(){gl_Position=vec4(a_position,0,1);}';
  const vertShader = gl.createShader(gl.VERTEX_SHADER);
  gl.shaderSource(vertShader, vertSource);
  gl.compileShader(vertShader);

  const fragShader = gl.createShader(gl.FRAGMENT_SHADER);
  gl.shaderSource(fragShader, code);
  gl.compileShader(fragShader);
  if (!gl.getShaderParameter(fragShader, gl.COMPILE_STATUS)) { canvas.remove(); return; }

  const program = gl.createProgram();
  gl.attachShader(program, vertShader);
  gl.attachShader(program, fragShader);
  gl.linkProgram(program);
  gl.useProgram(program);

  const posBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1,1,-1,-1,1,1,1]), gl.STATIC_DRAW);
  const posLoc = gl.getAttribLocation(program, 'a_position');
  gl.enableVertexAttribArray(posLoc);
  gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

  function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; gl.viewport(0, 0, canvas.width, canvas.height); }
  resize();
  window.addEventListener('resize', resize);

  let time = 0, mouse = [0, 0];
  document.addEventListener('mousemove', (e) => { mouse = [e.clientX, window.innerHeight - e.clientY]; });

  function render() {
    if (!document.getElementById('shader-background')) return;
    time += 0.016;
    gl.clearColor(0, 0, 0, 1);
    gl.clear(gl.COLOR_BUFFER_BIT);
    const tLoc = gl.getUniformLocation(program, 'u_time');
    const rLoc = gl.getUniformLocation(program, 'u_resolution');
    const mLoc = gl.getUniformLocation(program, 'u_mouse');
    if (tLoc) gl.uniform1f(tLoc, time);
    if (rLoc) gl.uniform2f(rLoc, canvas.width, canvas.height);
    if (mLoc) gl.uniform2f(mLoc, mouse[0], mouse[1]);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    window._shaderBgAnimFrame = requestAnimationFrame(render);
  }
  render();
}

function handleKeyDown(e) {
  if (e.key === 'Escape') {
    hideStartMenu();
    hideContextMenu();
  }
}

function handleContextMenu(e) {
  const desktop = document.getElementById('desktop');

  // Check if click is inside a window - if so, don't show desktop menu
  const windowEl = e.target.closest('.window');
  if (windowEl) {
    // Apps can define their own contextmenu handler on their content
    // If they don't, we just prevent the default browser menu
    e.preventDefault();
    return;
  }

  // Only show desktop context menu when clicking on desktop itself
  if (e.target === desktop || (desktop.contains(e.target) && !e.target.closest('.window'))) {
    e.preventDefault();
    showDesktopContextMenu(e);
  }
}

// ==================== DESKTOP ICONS ====================
// Desktop now shows files from disk (~/), not localStorage

let desktopFiles = []; // Cache of files from disk

async function createDesktopIcons() {
  const desktop = document.getElementById('desktop');
  desktop.innerHTML = '';

  // Default app icons
  const defaultIcons = [
    { id: 'notepad', name: 'Notepad', icon: 'ğŸ“', x: 20, y: 20, action: 'openNotepad' },
    { id: 'jside', name: 'javascript.ide', icon: 'ğŸ’»', x: 20, y: 100, action: 'openJSIDE' },
    { id: 'browser', name: 'Web Browser', icon: 'ğŸŒ', x: 20, y: 180, action: 'openBrowser' },
    { id: 'docs', name: 'Documentation', icon: 'ğŸ“•', x: 20, y: 260, action: 'openDocumentation' },
  ];

  defaultIcons.forEach(ic => createDesktopIcon(ic));

  // Fetch files from disk
  desktopFiles = await fetchDesktopFiles();

  // Create icons for disk files
  desktopFiles.forEach((file, idx) => {
    createDesktopIcon({
      id: 'file-' + idx,
      name: file.name,
      icon: getFileIcon(file.name),
      x: 120 + (idx % 5) * 80,
      y: 20 + Math.floor(idx / 5) * 80,
      action: 'openDiskFile',
      filePath: file.path,
      fileName: file.name
    });
  });
}

function createDesktopIcon(ic) {
  const desktop = document.getElementById('desktop');
  const icon = document.createElement('div');
  icon.className = 'desktop-icon';
  icon.id = 'icon-' + ic.id;
  icon.dataset.id = ic.id;
  icon.style.left = ic.x + 'px';
  icon.style.top = ic.y + 'px';
  icon.innerHTML = '<div class="icon-img">' + ic.icon + '</div><div class="icon-label">' + escapeHtml(ic.name) + '</div>';

  icon.ondblclick = async () => {
    if (ic.action === 'openDiskFile') {
      const content = await getFileFromDisk(ic.filePath);
      if (content !== null) {
        openSavedFile({ name: ic.fileName, content: content }, ic.filePath);
      } else {
        algoSpeak('Failed to open file');
      }
    } else if (typeof window[ic.action] === 'function') {
      window[ic.action]();
    }
  };

  // Right-click context menu for files
  if (ic.action === 'openDiskFile') {
    icon.oncontextmenu = (e) => {
      e.preventDefault();
      e.stopPropagation();
      showFileContextMenu(e, ic.filePath, ic.fileName);
    };
  }

  desktop.appendChild(icon);
}

function showFileContextMenu(e, filePath, fileName) {
  const menu = document.getElementById('context-menu');
  const isJS = fileName.endsWith('.js');
  menu.innerHTML =
    (isJS ? '<div class="ctx-item" onclick="runDiskFile(\'' + filePath + '\', \'' + fileName + '\')">â–¶ Run</div>' : '') +
    '<div class="ctx-item" onclick="openDiskFileByPath(\'' + filePath + '\', \'' + fileName + '\')">ğŸ“‚ Open</div>' +
    '<div class="ctx-item" onclick="renameDiskFile(\'' + filePath + '\', \'' + fileName + '\')">âœï¸ Rename</div>' +
    '<div class="ctx-separator"></div>' +
    '<div class="ctx-item" style="color:#f66;" onclick="deleteDiskFile(\'' + filePath + '\')">ğŸ—‘ï¸ Delete</div>';
  menu.style.left = e.clientX + 'px';
  menu.style.top = e.clientY + 'px';
  menu.classList.add('visible');
}

async function runDiskFile(path, name) {
  hideContextMenu();
  const content = await getFileFromDisk(path);
  if (content !== null) {
    runApp(content, name);
  } else {
    algoSpeak('Failed to load file');
  }
}

async function openDiskFileByPath(path, name) {
  hideContextMenu();
  const content = await getFileFromDisk(path);
  if (content !== null) {
    openSavedFile({ name: name, content: content }, path);
  } else {
    algoSpeak('Failed to open file');
  }
}

async function renameDiskFile(oldPath, oldName) {
  hideContextMenu();
  const newName = prompt('New name:', oldName);
  if (!newName || newName === oldName) return;

  const content = await getFileFromDisk(oldPath);
  if (content === null) { algoSpeak('Failed to read file'); return; }

  const saved = await saveFileToDisk(newName, content);
  if (!saved) { algoSpeak('Failed to save new file'); return; }

  const deleted = await deleteFileFromDisk(oldPath);
  if (!deleted) { algoSpeak('Renamed but failed to delete old file'); }

  await createDesktopIcons();
  algoSpeak('Renamed to ' + newName);
}

async function deleteDiskFile(path) {
  hideContextMenu();
  if (!confirm('Delete this file?')) return;

  const deleted = await deleteFileFromDisk(path);
  if (deleted) {
    await createDesktopIcons();
    algoSpeak('File deleted');
  } else {
    algoSpeak('Failed to delete file');
  }
}

function getFileIcon(filename) {
  const ext = filename.split('.').pop().toLowerCase();
  return fileTypeRegistry[ext]?.icon || 'ğŸ“„';
}

// ==================== WINDOWS ====================
function createWindow(opts) {
  const id = winId++;
  const win = {
    id,
    title: opts.title || 'Window',
    icon: opts.icon || 'ğŸ“„',
    width: opts.width || 400,
    height: opts.height || 300,
    x: opts.x || 100 + (id % 5) * 30,
    y: opts.y || 50 + (id % 5) * 30,
    minimized: false,
    maximized: false,
    content: opts.content || '',
    onClose: opts.onClose
  };
  windows.push(win);
  renderWindow(win);
  focusWindow(id);
  updateTaskbar();
  return id;
}

function renderWindow(win) {
  const desktop = document.getElementById('desktop');
  const el = document.createElement('div');
  el.className = 'window';
  el.id = 'win-' + win.id;
  el.style.cssText = 'left:' + win.x + 'px;top:' + win.y + 'px;width:' + win.width + 'px;height:' + win.height + 'px;';

  el.innerHTML =
    '<div class="window-titlebar" onmousedown="startDrag(event,' + win.id + ')">' +
      '<span class="window-icon">' + win.icon + '</span>' +
      '<span class="window-title">' + escapeHtml(win.title) + '</span>' +
      '<div class="window-controls">' +
        '<button class="win-btn minimize" onclick="minimizeWindow(' + win.id + ')">_</button>' +
        '<button class="win-btn maximize" onclick="maximizeWindow(' + win.id + ')">â–¡</button>' +
        '<button class="win-btn close" onclick="closeWindow(' + win.id + ')">Ã—</button>' +
      '</div>' +
    '</div>' +
    '<div class="window-content">' + win.content + '</div>';

  el.onmousedown = () => focusWindow(win.id);
  desktop.appendChild(el);
}

function focusWindow(id) {
  windows.forEach(w => {
    const el = document.getElementById('win-' + w.id);
    if (el) el.classList.remove('active');
  });
  const el = document.getElementById('win-' + id);
  if (el) {
    el.classList.add('active');
    el.style.zIndex = ++topZIndex;  // Increment z-index so focused window is always on top
  }
  activeWin = id;
}

function minimizeWindow(id) {
  const el = document.getElementById('win-' + id);
  if (el) el.classList.add('minimized');
  const win = windows.find(w => w.id === id);
  if (win) win.minimized = true;
  updateTaskbar();
}

function restoreWindow(id) {
  const el = document.getElementById('win-' + id);
  if (el) el.classList.remove('minimized');
  const win = windows.find(w => w.id === id);
  if (win) win.minimized = false;
  focusWindow(id);
  updateTaskbar();
}

function maximizeWindow(id) {
  const el = document.getElementById('win-' + id);
  const win = windows.find(w => w.id === id);
  if (!el || !win) return;

  if (win.maximized) {
    el.style.left = win.restoreX + 'px';
    el.style.top = win.restoreY + 'px';
    el.style.width = win.restoreW + 'px';
    el.style.height = win.restoreH + 'px';
    win.maximized = false;
  } else {
    win.restoreX = el.offsetLeft;
    win.restoreY = el.offsetTop;
    win.restoreW = el.offsetWidth;
    win.restoreH = el.offsetHeight;
    el.style.left = '0';
    el.style.top = '0';
    el.style.width = '100%';
    el.style.height = 'calc(100% - 28px)';
    win.maximized = true;
  }
}

function closeWindow(id) {
  const win = windows.find(w => w.id === id);
  if (win && win.onClose) win.onClose();
  const el = document.getElementById('win-' + id);
  if (el) el.remove();
  windows = windows.filter(w => w.id !== id);
  updateTaskbar();
}

function updateTaskbar() {
  const tb = document.getElementById('taskbar-windows');
  tb.innerHTML = windows.map(w =>
    '<div class="taskbar-item' + (w.id === activeWin ? ' active' : '') + (w.minimized ? ' minimized' : '') +
    '" onclick="' + (w.minimized ? 'restoreWindow(' + w.id + ')' : 'focusWindow(' + w.id + ')') + '">' +
    w.icon + ' ' + escapeHtml(w.title.substring(0, 20)) + '</div>'
  ).join('');
}

// ==================== DRAG ====================
function startDrag(e, id) {
  if (e.target.classList.contains('win-btn')) return;
  const el = document.getElementById('win-' + id);
  if (!el) return;
  dragWin = { id, el };
  dragOffset = { x: e.clientX - el.offsetLeft, y: e.clientY - el.offsetTop };
  focusWindow(id);
}

function onDrag(e) {
  if (!dragWin) return;
  dragWin.el.style.left = (e.clientX - dragOffset.x) + 'px';
  dragWin.el.style.top = (e.clientY - dragOffset.y) + 'px';
}

function endDrag() {
  dragWin = null;
}

// ==================== NOTEPAD ====================
function openNotepad(content, filename) {
  hideStartMenu();
  const id = winId;
  const text = content || '';
  const name = filename || 'Untitled.txt';

  createWindow({
    title: name,
    icon: 'ğŸ“',
    width: 500,
    height: 400,
    content:
      '<div class="notepad-container">' +
        '<div class="notepad-toolbar">' +
          '<button onclick="notepadNew(' + id + ')">New</button>' +
          '<button onclick="notepadSave(' + id + ')">Save</button>' +
        '</div>' +
        '<textarea id="notepad-text-' + id + '" class="notepad-textarea">' + escapeHtml(text) + '</textarea>' +
      '</div>'
  });
}

function notepadNew(id) {
  const textarea = document.getElementById('notepad-text-' + id);
  if (textarea) textarea.value = '';
}

async function notepadSave(id) {
  const textarea = document.getElementById('notepad-text-' + id);
  if (!textarea) return;
  const name = prompt('Filename:', 'document.txt');
  if (!name) return;

  const saved = await saveFileToDisk(name, textarea.value);
  if (saved) {
    await createDesktopIcons();
    algoSpeak('Saved ' + name + ' to ~/');
  } else {
    algoSpeak('Failed to save file');
  }
}

// ==================== JAVASCRIPT IDE ====================
const ALGO_API_CODE = `
// Extend global ALGO (don't shadow it - we need pubsub and bridge!)
ALGO.app = { name: 'App', icon: 'ğŸ“±' };
ALGO.title = (t) => { document.title = t; };
ALGO.html = (h) => { document.body.innerHTML = h; };
ALGO.createWindow = (opts) => createWindow(opts);
ALGO.notify = (msg) => algoSpeak(msg);
ALGO.state = ALGO.state || {};
ALGO.ui = ALGO.ui || {
  button: (text, onclick) => '<button onclick="(' + onclick + ')()">' + text + '</button>'
};
`;

const IDE_EXAMPLES = {
  'hello': {
    name: 'Hello World',
    code: '// Hello World\\nALGO.app.name = "Hello";\\nALGO.app.icon = "ğŸ‘‹";\\n\\nALGO.html("<h1>Hello, World!</h1>");'
  },
  'counter': {
    name: 'Counter',
    code: '// Counter App\\nALGO.app.name = "Counter";\\nALGO.app.icon = "ğŸ”¢";\\n\\nlet count = 0;\\n\\nfunction render() {\\n  ALGO.html(`\\n    <div style="text-align:center;padding:20px;">\\n      <h1>${count}</h1>\\n      <button onclick="count--;render()">-</button>\\n      <button onclick="count++;render()">+</button>\\n    </div>\\n  `);\\n}\\n\\nrender();'
  }
};

function openJSIDE(content, filename) {
  hideStartMenu();
  const id = winId;
  const code = content || '// Function Server App\\nALGO.app.name = "My App";\\nALGO.app.icon = "ğŸ“±";\\n\\nALGO.html("<h1>Hello!</h1>");';

  createWindow({
    title: filename || 'javascript.ide',
    icon: 'ğŸ’»',
    width: 700,
    height: 500,
    content:
      '<div class="ide-container">' +
        '<div class="ide-toolbar">' +
          '<button onclick="ideRun(' + id + ')">â–¶ Run</button>' +
          '<button onclick="ideSave(' + id + ')">ğŸ’¾ Save</button>' +
          '<select onchange="ideLoadExample(' + id + ',this.value)">' +
            '<option value="">Examples...</option>' +
            '<option value="hello">Hello World</option>' +
            '<option value="counter">Counter</option>' +
          '</select>' +
        '</div>' +
        '<div class="ide-main">' +
          '<textarea id="ide-code-' + id + '" class="ide-editor">' + escapeHtml(code) + '</textarea>' +
          '<div class="ide-preview" id="ide-preview-' + id + '"></div>' +
        '</div>' +
      '</div>'
  });
}

function ideRun(id) {
  const code = document.getElementById('ide-code-' + id).value;
  const preview = document.getElementById('ide-preview-' + id);

  try {
    preview.innerHTML = '<div id="app-root"></div>';
    const fullCode = ALGO_API_CODE + '\n' +
      'const ALGO_ROOT = document.getElementById("ide-preview-' + id + '").querySelector("#app-root");\n' +
      'ALGO.html = (h) => { ALGO_ROOT.innerHTML = h; };\n' +
      code;
    eval(fullCode);
  } catch (e) {
    preview.innerHTML = '<div style="color:red;padding:10px;">Error: ' + escapeHtml(e.message) + '</div>';
  }
}

async function ideSave(id) {
  const code = document.getElementById('ide-code-' + id).value;
  const name = prompt('Filename:', 'app.js');
  if (!name) return;

  const saved = await saveFileToDisk(name, code);
  if (saved) {
    await createDesktopIcons();
    algoSpeak('Saved ' + name + ' to ~/');
  } else {
    algoSpeak('Failed to save file');
  }
}

function ideLoadExample(id, key) {
  if (!key || !IDE_EXAMPLES[key]) return;
  document.getElementById('ide-code-' + id).value = IDE_EXAMPLES[key].code.replace(/\\\\n/g, '\\n');
}

// ==================== WEB BROWSER ====================
function openBrowser(url) {
  hideStartMenu();
  const id = winId;
  const startUrl = url || 'https://example.com';

  createWindow({
    title: 'Web Browser',
    icon: 'ğŸŒ',
    width: 800,
    height: 600,
    content:
      '<div class="browser-container">' +
        '<div class="browser-toolbar">' +
          '<button onclick="browserBack(' + id + ')">â—€</button>' +
          '<button onclick="browserFwd(' + id + ')">â–¶</button>' +
          '<input type="text" id="browser-url-' + id + '" value="' + escapeHtml(startUrl) + '" onkeypress="if(event.key===\'Enter\')browserGo(' + id + ')">' +
          '<button onclick="browserGo(' + id + ')">Go</button>' +
        '</div>' +
        '<iframe id="browser-frame-' + id + '" src="' + escapeHtml(startUrl) + '" class="browser-frame"></iframe>' +
      '</div>'
  });
}

function browserGo(id) {
  let url = document.getElementById('browser-url-' + id).value;
  if (!url.startsWith('http')) url = 'https://' + url;
  document.getElementById('browser-frame-' + id).src = url;
}

function browserBack(id) {
  try { document.getElementById('browser-frame-' + id).contentWindow.history.back(); } catch(e) {}
}

function browserFwd(id) {
  try { document.getElementById('browser-frame-' + id).contentWindow.history.forward(); } catch(e) {}
}

// ==================== DOCUMENTATION ====================
const DOCS = {
  'getting-started': {
    title: 'Getting Started',
    content: '<h2>Welcome to Function Server</h2><p>A cloud operating system in your browser.</p><h3>Quick Start</h3><ul><li>Double-click icons to open programs</li><li>Right-click for context menus</li><li>Use Start menu for all programs</li></ul>'
  },
  'apps': {
    title: 'Building Apps',
    content: '<h2>Building Apps</h2><p>Use JavaScript.IDE to create apps.</p><pre style="background:#e8e0f0;color:#222;padding:12px;border-radius:6px;">ALGO.app.name = "My App";\\nALGO.html("<h1>Hello!</h1>");</pre>'
  }
};

function openDocumentation() {
  hideStartMenu();
  createWindow({
    title: 'Documentation',
    icon: 'ğŸ“•',
    width: 500,
    height: 400,
    content:
      '<div class="docs-container">' +
        '<div class="docs-sidebar">' +
          Object.keys(DOCS).map(k => '<div class="docs-item" onclick="showDoc(\'' + k + '\')">' + DOCS[k].title + '</div>').join('') +
        '</div>' +
        '<div class="docs-content" id="docs-content">' +
          '<p>Select a topic from the sidebar.</p>' +
        '</div>' +
      '</div>'
  });
}

function showDoc(key) {
  const doc = DOCS[key];
  if (doc) {
    document.getElementById('docs-content').innerHTML = doc.content;
  }
}

function openHelp() {
  hideStartMenu();
  createWindow({
    title: 'Help',
    icon: 'ğŸ“™',
    width: 400,
    height: 300,
    content: '<div style="padding:20px;"><h2>Help</h2><p>Function Server is a cloud OS.</p><ul><li>Use Start menu for programs</li><li>System Apps load from /core/apps/</li><li>Create apps with JavaScript.IDE</li></ul></div>'
  });
}

// ==================== FILE HANDLING ====================
function openSavedFile(file, filePath) {
  // Files in ~/apps/ or ~/games/ folder auto-run instead of opening in editor
  // Also auto-run if file contains ALGO.app.name (marks it as an app)
  const isAppFolder = filePath && (
    filePath.startsWith('~/apps/') || filePath.startsWith('~/apps\\') ||
    filePath.startsWith('~/games/') || filePath.startsWith('~/games\\')
  );
  const isApp = isAppFolder || (file.content && /ALGO\.app\.name\s*=/.test(file.content));
  if (file.name.endsWith('.js')) {
    if (isApp) {
      runApp(file.content, file.name);
    } else {
      openJSIDE(file.content, file.name);
    }
  } else if (file.type === 'image') {
    viewImage(file);
  } else {
    openNotepad(file.content, file.name);
  }
}

function viewImage(file) {
  createWindow({
    title: file.name,
    icon: 'ğŸ–¼ï¸',
    width: 500,
    height: 400,
    content: '<div style="display:flex;align-items:center;justify-content:center;height:100%;background:#222;"><img src="' + file.data + '" style="max-width:100%;max-height:100%;"></div>'
  });
}

// ==================== CONTEXT MENU ====================
function showDesktopContextMenu(e) {
  const menu = document.getElementById('context-menu');
  menu.innerHTML =
    '<div class="ctx-item" onclick="openNotepad()">ğŸ“ New Text File</div>' +
    '<div class="ctx-item" onclick="openJSIDE()">ğŸ“œ New App</div>' +
    '<div class="ctx-separator"></div>' +
    '<div class="ctx-item" onclick="refreshDesktop()">ğŸ”„ Refresh</div>';
  menu.style.left = e.clientX + 'px';
  menu.style.top = e.clientY + 'px';
  menu.classList.add('visible');
}

async function refreshDesktop() {
  hideContextMenu();
  await createDesktopIcons();
  algoSpeak('Desktop refreshed');
}

function hideContextMenu() {
  document.getElementById('context-menu').classList.remove('visible');
}

// ==================== START MENU ====================
function toggleStartMenu() {
  document.getElementById('start-menu').classList.toggle('visible');
}

function hideStartMenu() {
  document.getElementById('start-menu').classList.remove('visible');
}

function openSubmenu(el) {
  if (submenuCloseTimeout) {
    clearTimeout(submenuCloseTimeout);
    submenuCloseTimeout = null;
  }
  document.querySelectorAll('.start-item.has-sub').forEach(item => {
    if (item !== el) item.classList.remove('submenu-open');
  });
  el.classList.add('submenu-open');

  // Fix submenu position to align with start menu bottom
  const submenu = el.querySelector('.start-submenu');
  if (submenu) {
    const startMenu = document.getElementById('start-menu');
    const startRect = startMenu.getBoundingClientRect();
    const taskbarHeight = window.innerHeight - document.getElementById('taskbar').getBoundingClientRect().top;

    // Use setProperty with !important to override CSS
    submenu.style.setProperty('position', 'fixed', 'important');
    submenu.style.setProperty('left', (startRect.right - 2) + 'px', 'important');
    submenu.style.setProperty('bottom', taskbarHeight + 'px', 'important');
    submenu.style.setProperty('top', 'auto', 'important');
    submenu.style.setProperty('max-height', (window.innerHeight - taskbarHeight - 20) + 'px', 'important');
  }
}

function closeSubmenuDelay(el) {
  submenuCloseTimeout = setTimeout(() => {
    el.classList.remove('submenu-open');
  }, 300);
}

function toggleSubmenu(e, el) {
  if (window.innerWidth <= 768) {
    e.stopPropagation();
    el.classList.toggle('submenu-open');
  }
}

// ==================== PROGRAMS MENU ====================
function updateProgramsMenu() {
  const el = document.getElementById('installed-programs-menu');
  if (!el) return;

  let html = '';

  // System apps
  const visibleSystemApps = systemApps.filter(a => !uninstalledSystemApps.includes(a.id));
  if (visibleSystemApps.length > 0) {
    html += '<div class="start-separator-label">System Apps</div>';
    html += visibleSystemApps.map(a =>
      '<div class="start-item" onclick="runSystemApp(\'' + a.id + '\')">' +
      '<span>' + (a.icon || 'ğŸ“±') + '</span> ' + escapeHtml(a.name) + '</div>'
    ).join('');
  }

  // User apps
  if (installedPrograms.length > 0) {
    if (visibleSystemApps.length > 0) html += '<div class="start-separator"></div>';
    html += '<div class="start-separator-label">My Apps</div>';
    html += installedPrograms.map(p =>
      '<div class="start-item" onclick="runUserApp(\'' + p.id + '\')">' +
      '<span>' + (p.icon || 'ğŸ®') + '</span> ' + escapeHtml(p.name) + '</div>'
    ).join('');
  }

  el.innerHTML = html;
}

// ==================== APP RUNNING ====================
function loadSystemApps() {
  fetch(API_BASE + '/system-apps')
    .then(r => r.json())
    .then(data => {
      systemApps = data.apps || [];
      updateProgramsMenu();
    })
    .catch(() => {});
}

function runSystemApp(appId) {
  hideStartMenu();
  const app = systemApps.find(a => a.id === appId);
  if (app) runApp(app);
}

function runUserApp(appId) {
  hideStartMenu();
  const app = installedPrograms.find(a => a.id === appId);
  if (app) runApp(app);
}

function runApp(appOrCode, name) {
  // Handle both object {code, name} and direct (code, name) arguments
  const code = typeof appOrCode === 'string' ? appOrCode : appOrCode?.code;
  const appName = name || appOrCode?.name || 'App';
  if (code) {
    try {
      const fullCode = ALGO_API_CODE + '\n' + code;
      eval(fullCode);
      // Hook AI Eyes after app loads (wraps Lens if Studio added functions)
      if (ALGO.eyes?.wrapLens) ALGO.eyes.wrapLens();
    } catch (e) {
      algoSpeak('Error in ' + appName + ': ' + e.message);
    }
  }
}

// ==================== UTILITIES ====================
function globalClick(e) {
  if (!e.target.closest('#start-menu') && !e.target.closest('#start-btn')) {
    hideStartMenu();
  }
  if (!e.target.closest('#context-menu')) {
    hideContextMenu();
  }
}

function updateClock() {
  const now = new Date();
  document.getElementById('clock').textContent =
    now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
}

function escapeHtml(s) {
  return String(s).replace(/[&<>"']/g, c => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[c]));
}

function algoSpeak(text) {
  const container = document.getElementById('toast-container');
  if (!container) return;
  const toast = document.createElement('div');
  toast.className = 'algo-toast';
  toast.innerHTML = '<span class="toast-icon">ğŸ–¥ï¸</span><span class="toast-text">' + escapeHtml(text) + '</span>';
  container.appendChild(toast);
  requestAnimationFrame(() => toast.classList.add('show'));
  setTimeout(() => {
    toast.classList.remove('show');
    setTimeout(() => toast.remove(), 300);
  }, 3500);
}

function showAbout() {
  hideStartMenu();
  createWindow({
    title: 'About',
    icon: 'ğŸ–¥ï¸',
    width: 320,
    height: 220,
    content: '<div style="padding:20px;text-align:center;"><div style="font-size:48px;">ğŸ–¥ï¸</div><h2>Function Server</h2><p style="color:#666;">A Cloud Operating System</p><p style="font-size:11px;margin-top:15px;">MIT License â€¢ Open Source</p></div>'
  });
}

function openSettings() {
  hideStartMenu();
  const currentBg = localStorage.getItem('algo-bg-color') || '#008080';
  createWindow({
    title: 'Settings',
    icon: 'âš™ï¸',
    width: 350,
    height: 250,
    content:
      '<div style="padding:20px;">' +
        '<h3>Settings</h3>' +
        '<label>Background Color:</label><br>' +
        '<input type="color" id="settings-bg" value="' + currentBg + '">' +
        '<button onclick="applySettings()" style="margin-left:10px;">Apply</button>' +
      '</div>'
  });
}

function applySettings() {
  const bg = document.getElementById('settings-bg').value;
  localStorage.setItem('algo-bg-color', bg);
  document.getElementById('desktop').style.background = bg;
  algoSpeak('Settings applied');
}

// ==================== PERSISTENCE ====================
function saveState() {
  const state = {
    savedFiles,
    installedPrograms,
    uninstalledSystemApps,
    apiKeys,
    windowStates
  };
  localStorage.setItem('algo-state-' + currentUser, JSON.stringify(state));
}

function loadState() {
  try {
    const saved = localStorage.getItem('algo-state-' + currentUser);
    if (saved) {
      const state = JSON.parse(saved);
      savedFiles = state.savedFiles || [];
      installedPrograms = state.installedPrograms || [];
      uninstalledSystemApps = state.uninstalledSystemApps || [];
      apiKeys = state.apiKeys || {};
      windowStates = state.windowStates || {};
    }
  } catch (e) {}

  // Apply saved background
  const bg = localStorage.getItem('algo-bg-color');
  if (bg) document.getElementById('desktop').style.background = bg;
}

// ==================== SYSTEM TRAY ====================
const systemTray = {
  icons: {},  // id -> { element, onClick, onContextMenu }

  add(id, icon, options = {}) {
    if (this.icons[id]) return this.icons[id].element;

    const el = document.createElement('div');
    el.className = 'tray-icon' + (options.className ? ' ' + options.className : '');
    el.innerHTML = icon;
    el.title = options.title || id;

    if (options.onClick) {
      el.onclick = options.onClick;
    }
    if (options.onContextMenu) {
      el.oncontextmenu = (e) => {
        e.preventDefault();
        options.onContextMenu(e);
      };
    }

    const container = document.getElementById('system-tray');
    if (container) container.appendChild(el);

    this.icons[id] = { element: el, ...options };
    return el;
  },

  remove(id) {
    const item = this.icons[id];
    if (item && item.element) {
      item.element.remove();
      delete this.icons[id];
    }
  },

  update(id, icon) {
    const item = this.icons[id];
    if (item && item.element) {
      item.element.innerHTML = icon;
    }
  },

  get(id) {
    return this.icons[id]?.element;
  }
};

// ==================== EYE BRIDGE ====================
let eyeBridgeWs = null;
let eyeBridgeReconnectTimer = null;
let eyeBridgeConnected = false;
let eyeBridgePingInterval = null;

function connectEyeBridge() {
  if (!sessionToken) return;
  if (eyeBridgeWs && eyeBridgeWs.readyState === WebSocket.OPEN) return;

  const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
  const wsUrl = `${protocol}//${location.host}/api/eye-bridge?token=${sessionToken}`;

  try {
    eyeBridgeWs = new WebSocket(wsUrl);

    eyeBridgeWs.onopen = () => {
      console.log('[EyeBridge] Connected');
      // Start keepalive ping every 25 seconds
      if (eyeBridgePingInterval) clearInterval(eyeBridgePingInterval);
      eyeBridgePingInterval = setInterval(() => {
        if (eyeBridgeWs && eyeBridgeWs.readyState === WebSocket.OPEN) {
          eyeBridgeWs.send('ping');
        }
      }, 25000);
    };

    eyeBridgeWs.onmessage = (event) => {
      const msg = event.data;

      if (msg === 'EYE_BRIDGE:ready') {
        eyeBridgeConnected = true;
        updateEyeTray();
        return;
      }

      // Handle eye commands from Claude
      // Format: EYE_CMD:id:expression
      if (msg.startsWith('EYE_CMD:')) {
        handleEyeCommand(msg.slice(8));
        return;
      }
    };

    eyeBridgeWs.onclose = () => {
      console.log('[EyeBridge] Disconnected');
      eyeBridgeConnected = false;
      if (eyeBridgePingInterval) {
        clearInterval(eyeBridgePingInterval);
        eyeBridgePingInterval = null;
      }
      updateEyeTray();
      scheduleEyeBridgeReconnect();
    };

    eyeBridgeWs.onerror = (err) => {
      console.error('[EyeBridge] Error:', err);
    };
  } catch (e) {
    console.error('[EyeBridge] Connect failed:', e);
    scheduleEyeBridgeReconnect();
  }
}

function scheduleEyeBridgeReconnect() {
  if (eyeBridgeReconnectTimer) return;
  eyeBridgeReconnectTimer = setTimeout(() => {
    eyeBridgeReconnectTimer = null;
    if (sessionToken) connectEyeBridge();
  }, 3000);
}

function handleEyeCommand(data) {
  // Parse id:expression
  const colonIdx = data.indexOf(':');
  if (colonIdx === -1) return;

  const id = data.slice(0, colonIdx);
  const expression = data.slice(colonIdx + 1);

  // Visual feedback - blink the eye
  blinkEyeTray();

  // Execute and send response
  (async () => {
    try {
      let result = eval(expression);
      // Await promises
      if (result && typeof result.then === 'function') {
        result = await result;
      }

      // Serialize result
      let response;
      try {
        response = JSON.stringify(result);
      } catch (e) {
        response = String(result);
      }

      sendEyeResponse(id, response, false);
    } catch (e) {
      // Enhanced error with line number extraction
      let errorMsg = e.message || String(e);

      // Try to extract line number from stack
      if (e.stack) {
        const match = e.stack.match(/<anonymous>:(\d+):(\d+)/);
        if (match) {
          errorMsg += ` (line ${match[1]}, col ${match[2]})`;
        }
      }

      // For syntax errors, try to get more context
      if (e instanceof SyntaxError && expression) {
        const lines = expression.split('\n');
        if (lines.length > 1) {
          errorMsg += ` [${lines.length} lines]`;
        }
      }

      sendEyeResponse(id, errorMsg, true);
    }
  })();
}

function sendEyeResponse(id, result, isError) {
  if (!eyeBridgeWs || eyeBridgeWs.readyState !== WebSocket.OPEN) return;

  // Format: EYE:id:result or EYE:id!:error
  const sep = isError ? '!:' : ':';
  eyeBridgeWs.send(`EYE:${id}${sep}${result}`);
}

function updateEyeTray() {
  let el = systemTray.get('eye');
  if (!el) {
    el = systemTray.add('eye', 'ğŸ‘ï¸<span class="eye-indicator"></span>', {
      className: 'eye-tray',
      title: 'Claude Eye Bridge',
      onClick: () => {
        // Try to open Claude Eyes app if it exists
        const eyeApp = systemApps.find(a => a.name.toLowerCase().includes('eye') || a.name.toLowerCase().includes('claude'));
        if (eyeApp) {
          loadSystemApp(eyeApp.file);
        } else {
          algoSpeak(eyeBridgeConnected ? 'Eye bridge connected' : 'Eye bridge disconnected');
        }
      }
    });
  }

  if (el) {
    el.classList.toggle('connected', eyeBridgeConnected);
    el.title = eyeBridgeConnected ? 'Claude Eye Bridge (connected)' : 'Claude Eye Bridge (disconnected)';
  }
}

function blinkEyeTray() {
  const el = systemTray.get('eye');
  if (!el) return;

  el.classList.remove('active');
  void el.offsetWidth; // Force reflow
  el.classList.add('active');
}

// Disconnect eye bridge on logout
const originalLogout = logout;
logout = function() {
  if (eyeBridgeWs) {
    eyeBridgeWs.close();
    eyeBridgeWs = null;
  }
  eyeBridgeConnected = false;
  ShadowBridge.disconnect();
  originalLogout();
};

// ==================== SHADOW BRIDGE SERVICE ====================
const ShadowBridge = {
  ws: null,
  connected: false,
  ready: false,
  tabs: [],
  shadowTabs: new Map(), // tabId -> { url, shadowId }
  pendingRequests: {},
  trayVisible: false,
  MAX_SHADOW_TABS: 10,

  // Check if browser supports the extension (Chrome/Edge)
  isSupported() {
    const ua = navigator.userAgent;
    return /Chrome|Edg/.test(ua) && !/OPR|Opera/.test(ua);
  },

  // Initialize - only shows tray if supported
  init() {
    if (!this.isSupported()) return;
    this.connect();
  },

  connect() {
    if (!sessionToken) return;
    if (this.ws && this.ws.readyState === WebSocket.OPEN) return;

    const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
    const wsUrl = `${protocol}//${location.host}/api/content-bridge`;

    try {
      this.ws = new WebSocket(wsUrl);

      this.ws.onopen = () => {
        console.log('[ShadowBridge] Connected to server');
        this.send({ action: 'listTabs' });
      };

      this.ws.onmessage = (event) => {
        try {
          const msg = JSON.parse(event.data);
          this.handleMessage(msg);
        } catch (e) {
          console.error('[ShadowBridge] Parse error:', e);
        }
      };

      this.ws.onclose = () => {
        console.log('[ShadowBridge] Disconnected');
        this.connected = false;
        this.ready = false;
        this.updateTray();
        // Reconnect after delay
        setTimeout(() => this.connect(), 5000);
      };

      this.ws.onerror = () => {
        console.error('[ShadowBridge] WebSocket error');
      };
    } catch (e) {
      console.error('[ShadowBridge] Connect failed:', e);
    }
  },

  disconnect() {
    if (this.ws) {
      this.ws.close();
      this.ws = null;
    }
    this.connected = false;
    this.ready = false;
  },

  handleMessage(msg) {
    // Handle tab list (extension is connected) - check this FIRST
    // because tabList responses also have an id for request routing
    if (msg.action === 'tabList') {
      this.tabs = msg.tabs || [];
      if (!this.connected) {
        this.connected = true;
        this.ready = true;
        console.log('[ShadowBridge] Extension connected');
        this.showTray();
        this.updateTray();
      }
    }

    // Handle responses to pending requests
    if (msg.id && this.pendingRequests[msg.id]) {
      const { resolve, reject } = this.pendingRequests[msg.id];
      delete this.pendingRequests[msg.id];

      if (msg.error) {
        // Check for auth required
        if (msg.error === 'AUTH_REQUIRED') {
          reject(new Error('AUTH_REQUIRED'));
        } else {
          reject(new Error(msg.error));
        }
      } else {
        resolve(msg.result);
      }
    }
  },

  send(msg) {
    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
      return Promise.reject(new Error('Not connected'));
    }

    return new Promise((resolve, reject) => {
      const id = 'sb_' + Date.now() + '_' + Math.random().toString(36).slice(2);
      msg.id = id;
      this.pendingRequests[id] = { resolve, reject };

      // Timeout after 30s
      setTimeout(() => {
        if (this.pendingRequests[id]) {
          delete this.pendingRequests[id];
          reject(new Error('Request timeout'));
        }
      }, 30000);

      this.ws.send(JSON.stringify(msg));
    });
  },

  // Public API for apps
  get available() {
    return this.ready && this.connected;
  },

  async open(url, options = {}) {
    if (!this.available) {
      this.promptInstall();
      throw new Error('Shadow Bridge not available');
    }

    if (this.shadowTabs.size >= this.MAX_SHADOW_TABS) {
      throw new Error(`Maximum ${this.MAX_SHADOW_TABS} shadow tabs allowed`);
    }

    const shadowId = options.shadowId || 'shadow_' + Date.now();
    const result = await this.send({
      action: 'openShadow',
      data: { url, shadowId }
    });

    this.shadowTabs.set(result.tabId, { url, shadowId });
    this.pulseIcon();
    this.updateTray();
    return result;
  },

  async close(tabId) {
    if (!this.available) return;

    await this.send({
      action: 'closeShadow',
      data: { tabId }
    });
    this.shadowTabs.delete(tabId);
    this.updateTray();
  },

  async query(tabId, selector, all = true) {
    if (!this.available) throw new Error('Shadow Bridge not available');

    this.pulseIcon();
    return await this.send({
      action: 'query',
      tabId,
      data: { selector, all }
    });
  },

  async getContent(tabId) {
    if (!this.available) throw new Error('Shadow Bridge not available');

    this.pulseIcon();
    return await this.send({
      action: 'getContent',
      tabId
    });
  },

  async click(tabId, selector) {
    if (!this.available) throw new Error('Shadow Bridge not available');

    return await this.send({
      action: 'click',
      tabId,
      data: { selector }
    });
  },

  // Convenience method: open, wait, query, close
  async fetch(url, options = {}) {
    const { selector, waitFor = 3000 } = options;

    const tab = await this.open(url);
    await new Promise(r => setTimeout(r, waitFor));

    let result;
    if (selector) {
      result = await this.query(tab.tabId, selector);
    } else {
      result = await this.getContent(tab.tabId);
    }

    if (!options.keepOpen) {
      await this.close(tab.tabId);
    }

    return result;
  },

  // Tray management
  showTray() {
    if (this.trayVisible) return;
    this.trayVisible = true;

    systemTray.add('shadow', 'ğŸ‘»<span class="shadow-indicator"></span>', {
      className: 'shadow-tray',
      title: 'Shadow Bridge',
      onClick: () => this.showPanel()
    });
  },

  updateTray() {
    const el = systemTray.get('shadow');
    if (!el) return;

    el.classList.toggle('connected', this.connected);
    el.title = this.connected
      ? `Shadow Bridge (${this.shadowTabs.size} tabs)`
      : 'Shadow Bridge (disconnected)';
  },

  pulseIcon() {
    const el = systemTray.get('shadow');
    if (!el) return;
    el.classList.remove('active');
    void el.offsetWidth;
    el.classList.add('active');
  },

  showPanel() {
    // Show status and instructions
    const tabs = Array.from(this.shadowTabs.entries()).map(([id, info]) =>
      `â€¢ ${info.url.slice(0, 40)}... (${id})`
    ).join('\n') || 'No active shadow tabs';

    const status = this.connected
      ? `âœ… Connected\n\nActive Shadow Tabs:\n${tabs}`
      : `âŒ Extension not connected\n\nğŸ“‹ To install:\n1. Open chrome://extensions\n2. Enable Developer mode\n3. Load unpacked: functionserver/extension\n4. Click the extension, set server URL\n5. Refresh this page`;

    algoSpeak(status);
  },

  promptInstall() {
    if (!this.isSupported()) return;
    if (this.connected) return;

    algoSpeak('Shadow Bridge extension needed. Click ğŸ‘» in taskbar for instructions.');
    this.showTray();
    this.updateTray();
  }
};

// Export for apps
window.ShadowBridge = ShadowBridge;

// ==================== BOOT ====================
checkSession();
</script>
</body>
</html>
