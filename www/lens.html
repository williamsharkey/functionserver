<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Lens: A Visual Interface Designed for AI</title>
<meta name="description" content="What if we designed a UI for AI first? Lens is a token-efficient viewport that lets LLMs see, navigate, and edit code faster than traditional file operations.">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Newsreader:ital,opsz,wght@0,6..72,400;1,6..72,400&display=swap" rel="stylesheet">
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }

:root {
  --bg: #09090b;
  --surface: #18181b;
  --text: #fafafa;
  --text-secondary: #a1a1aa;
  --text-tertiary: #52525b;
  --border: #27272a;
  --accent: #a78bfa;
  --green: #86efac;
  --red: #fca5a5;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', 'Segoe UI', system-ui, sans-serif;
  font-size: 16px;
  line-height: 1.7;
  color: var(--text);
  background: var(--bg);
  -webkit-font-smoothing: antialiased;
}

.grid-bg {
  position: fixed;
  inset: 0;
  z-index: -1;
  background-image:
    linear-gradient(rgba(255,255,255,0.02) 1px, transparent 1px),
    linear-gradient(90deg, rgba(255,255,255,0.02) 1px, transparent 1px);
  background-size: 60px 60px;
  mask-image: radial-gradient(ellipse at 50% 0%, black 0%, transparent 70%);
}

nav {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  padding: 16px 32px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  z-index: 100;
  background: rgba(9, 9, 11, 0.8);
  backdrop-filter: blur(12px);
  border-bottom: 1px solid var(--border);
}

.logo {
  font-size: 14px;
  font-weight: 500;
  color: var(--text);
  text-decoration: none;
}

nav a {
  color: var(--text-secondary);
  text-decoration: none;
  font-size: 13px;
}

nav a:hover { color: var(--text); }

.nav-cta {
  background: var(--text);
  color: var(--bg) !important;
  padding: 8px 16px;
  border-radius: 6px;
  font-weight: 500;
}

article {
  max-width: 720px;
  margin: 0 auto;
  padding: 120px 24px 80px;
}

h1 {
  font-family: 'Newsreader', 'New York', Georgia, serif;
  font-size: clamp(32px, 5vw, 48px);
  font-weight: 400;
  line-height: 1.2;
  margin-bottom: 24px;
  letter-spacing: -0.02em;
}

.lead {
  font-size: 18px;
  color: var(--text-secondary);
  margin-bottom: 48px;
  line-height: 1.8;
}

h2 {
  font-family: 'Newsreader', 'New York', Georgia, serif;
  font-size: 28px;
  font-weight: 400;
  margin-top: 64px;
  margin-bottom: 20px;
  letter-spacing: -0.01em;
}

h3 {
  font-size: 18px;
  font-weight: 500;
  margin-top: 40px;
  margin-bottom: 16px;
  color: var(--accent);
}

p {
  margin-bottom: 20px;
  color: var(--text-secondary);
  line-height: 1.8;
}

strong { color: var(--text); font-weight: 500; }
em { color: var(--text); font-style: italic; }

ol, ul {
  margin-bottom: 20px;
  padding-left: 24px;
  color: var(--text-secondary);
}

li { margin-bottom: 8px; }

code {
  font-family: 'SF Mono', ui-monospace, monospace;
  font-size: 14px;
  background: var(--surface);
  padding: 2px 6px;
  border-radius: 4px;
  color: var(--accent);
}

pre {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 20px 24px;
  margin: 24px 0;
  overflow-x: auto;
  white-space: pre-line;
}

pre code {
  background: none;
  padding: 0;
  font-size: 13px;
  line-height: 1.7;
  color: var(--text);
}

.cm { color: var(--text-tertiary); }
.kw { color: var(--accent); }
.str { color: var(--green); }
.num { color: #fcd34d; }
.result { color: var(--text-tertiary); font-style: italic; }

table {
  width: 100%;
  border-collapse: collapse;
  margin: 24px 0;
  font-size: 14px;
}

th, td {
  padding: 12px 16px;
  text-align: left;
  border-bottom: 1px solid var(--border);
}

th {
  background: var(--surface);
  color: var(--text);
  font-weight: 500;
}

td { color: var(--text-secondary); }
td code { font-size: 12px; }

blockquote {
  background: var(--surface);
  border-left: 3px solid var(--accent);
  padding: 24px 28px;
  margin: 48px 0;
  border-radius: 0 8px 8px 0;
}

blockquote p {
  margin-bottom: 0;
  font-size: 15px;
}

.comparison {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 16px;
  margin: 32px 0;
}

.comparison > div {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 20px;
}

.comparison h4 {
  font-size: 13px;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  margin-bottom: 12px;
  color: var(--text-tertiary);
}

.comparison.bad h4 { color: var(--red); }
.comparison.good h4 { color: var(--green); }

.comparison pre {
  margin: 0;
  padding: 12px;
  font-size: 12px;
}

hr {
  border: none;
  border-top: 1px solid var(--border);
  margin: 48px 0;
}

.cta-section {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 32px;
  margin: 48px 0;
  text-align: center;
}

.cta-section p { margin-bottom: 8px; }
.cta-section a { color: var(--accent); text-decoration: none; }
.cta-section a:hover { text-decoration: underline; }

footer {
  padding: 40px 24px;
  text-align: center;
  border-top: 1px solid var(--border);
}

footer a { color: var(--accent); text-decoration: none; }

.vision-compare {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 24px;
  margin: 32px 0;
}

.vision-compare > div {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 20px;
}

.vision-compare h4 {
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.1em;
  color: var(--text-tertiary);
  margin-bottom: 16px;
  text-align: center;
}

.vision-compare .caption {
  font-size: 12px;
  color: var(--text-tertiary);
  text-align: center;
  margin: 12px 0 0 0;
}

.fake-desktop {
  background: #1a1a2e;
  border-radius: 8px;
  padding: 12px;
  min-height: 160px;
}

.fake-window {
  background: #0d0d0d;
  border-radius: 6px;
  overflow: hidden;
  box-shadow: 0 4px 20px rgba(0,0,0,0.4);
}

.fake-titlebar {
  background: linear-gradient(#3a3a3a, #2a2a2a);
  padding: 8px 12px;
  display: flex;
  align-items: center;
  gap: 8px;
}

.fake-titlebar .dots {
  display: flex;
  gap: 4px;
}

.fake-titlebar .dots span {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: #ff5f57;
}

.fake-titlebar .dots span:nth-child(2) { background: #ffbd2e; }
.fake-titlebar .dots span:nth-child(3) { background: #28c840; }

.fake-titlebar .title {
  font-size: 11px;
  color: #999;
  margin-left: auto;
  margin-right: auto;
}

.fake-toolbar {
  background: #1a1a1a;
  padding: 6px 10px;
  display: flex;
  gap: 8px;
  border-bottom: 1px solid #333;
}

.fake-toolbar .btn {
  font-size: 10px;
  padding: 3px 8px;
  background: #2a2a2a;
  border-radius: 4px;
  color: #888;
}

.fake-toolbar .btn.active {
  background: var(--accent);
  color: #000;
}

.fake-editor {
  padding: 10px;
  font-family: 'SF Mono', monospace;
  font-size: 11px;
}

.fake-editor .line {
  color: #ccc;
  line-height: 1.6;
}

.fake-editor .ln {
  color: #555;
  margin-right: 12px;
  user-select: none;
}

.claude-view pre {
  margin: 0;
  padding: 12px;
  font-size: 11px;
  line-height: 1.5;
}

@media (max-width: 600px) {
  h1 { font-size: 28px; }
  article { padding: 100px 16px 60px; }
  nav { padding: 16px 20px; }
  .comparison { grid-template-columns: 1fr; }
  .vision-compare { grid-template-columns: 1fr; }
}
</style>
</head>
<body>

<div class="grid-bg"></div>

<nav>
  <a href="/" class="logo">FunctionServer</a>
  <a href="/app" class="nav-cta">Enter</a>
</nav>

<article>
  <h1>Lens: A Visual Interface Designed for AI</h1>

  <p class="lead">What if we designed a UI for AI first? Not "AI-assisted" or "AI-compatible"â€”but <em>AI-native</em>. An interface where LLMs can see, navigate, and edit faster than traditional file operations. That's Lens.</p>

  <h2>How AI Sees</h2>

  <p>When you look at FunctionServer, you see a desktop with windows, icons, and buttons. When an AI looks through Lens, it sees something different:</p>

  <div class="vision-compare">
    <div class="human-view">
      <h4>What You See</h4>
      <div class="fake-desktop">
        <div class="fake-window">
          <div class="fake-titlebar">
            <span class="dots"><span></span><span></span><span></span></span>
            <span class="title">Studio - app.js</span>
          </div>
          <div class="fake-toolbar">
            <span class="btn">+ New</span>
            <span class="btn">Save</span>
            <span class="btn active">Run</span>
          </div>
          <div class="fake-editor">
            <div class="line"><span class="ln">1</span>function hello() {</div>
            <div class="line"><span class="ln">2</span>  return "world";</div>
            <div class="line"><span class="ln">3</span>}</div>
          </div>
        </div>
      </div>
      <p class="caption">Pixels, colors, spatial layout</p>
    </div>
    <div class="claude-view">
      <h4>What AI Sees</h4>
      <pre><code>Lens.look(<span class="str">'body'</span>)
<span class="result"> 0123456789012345678901234
0â”‚Studio - app.js
1â”‚+ New    Save    â–¶ Run
2â”‚
3â”‚1:function hello() {
4â”‚2:  return "world";
5â”‚3:}</span>

Lens.at(<span class="num">1</span>, <span class="num">16</span>)
<span class="result">â†’ BUTTON:"Run" [click]</span></code></pre>
      <p class="caption">Text grid with coordinates + actions</p>
    </div>
  </div>

  <p>The AI doesn't parse pixels or decode screenshots. It receives a <strong>text grid with coordinates</strong>â€”every element addressable by row and column. Want to click "Run"? <code>Lens.click(1, 16)</code>. Want to know what's there first? <code>Lens.at(1, 16)</code>.</p>

  <p>This isn't OCR or computer vision. It's a <strong>native text representation</strong> designed for how language models actually work.</p>

  <h2>The Problem: Tokens Are Expensive</h2>

  <p>When an AI edits code through traditional tools, the workflow looks like this:</p>

  <ol>
    <li>Read entire file (1000+ tokens)</li>
    <li>Parse and understand structure</li>
    <li>Generate entire new file (1000+ tokens)</li>
    <li>Write to disk</li>
    <li>Repeat for every change</li>
  </ol>

  <p>A simple one-line fix costs thousands of tokens. And the AI is blindâ€”it can't see if the edit worked without reading the file again.</p>

  <h2>The Solution: Surgical Operations</h2>

  <p>Lens provides a different workflow:</p>

  <div class="comparison">
    <div>
      <h4>Traditional (high tokens)</h4>
      <pre><code><span class="cm">// Read entire file</span>
Read file.js  <span class="result">// 847 lines</span>

<span class="cm">// Rewrite entire file</span>
Write file.js <span class="result">// 847 lines</span>

<span class="cm">// ~3000 tokens for one edit</span></code></pre>
    </div>
    <div>
      <h4>Lens (minimal tokens)</h4>
      <pre><code>Lens.grep(<span class="str">'fetchData'</span>)
<span class="result">// â†’ "42:async function fetchData"</span>

Lens.setLine(<span class="num">42</span>, <span class="str">'new code'</span>)
<span class="result">// â†’ "âœ“ L42"</span>

Lens.save()
<span class="result">// â†’ "âœ“ saved"</span>

<span class="cm">// ~50 tokens total</span></code></pre>
    </div>
  </div>

  <p><strong>That's 60x fewer tokens for the same edit.</strong></p>

  <h2>The Lens API</h2>

  <h3>Code Navigation</h3>

  <table>
    <tr><th>Command</th><th>Purpose</th><th>Output</th></tr>
    <tr><td><code>Lens.code()</code></td><td>View with line numbers</td><td>Numbered lines</td></tr>
    <tr><td><code>Lens.line(42)</code></td><td>Get specific line</td><td>Line content</td></tr>
    <tr><td><code>Lens.line(42, 5)</code></td><td>Get lines 42-46</td><td>5 lines</td></tr>
    <tr><td><code>Lens.grep('pattern')</code></td><td>Find in code</td><td>Matching lines with numbers</td></tr>
  </table>

  <h3>Surgical Editing</h3>

  <table>
    <tr><th>Command</th><th>Purpose</th><th>Output</th></tr>
    <tr><td><code>Lens.setLine(42, 'code')</code></td><td>Replace one line</td><td><code>âœ“ L42</code></td></tr>
    <tr><td><code>Lens.insertLine(42, 'code')</code></td><td>Insert at line</td><td><code>âœ“ +L42</code></td></tr>
    <tr><td><code>Lens.deleteLine(42)</code></td><td>Delete line</td><td><code>âœ“ -L42</code></td></tr>
    <tr><td><code>Lens.replace('a', 'b')</code></td><td>Find/replace all</td><td><code>âœ“ Replaced</code></td></tr>
  </table>

  <h3>DOM Viewport</h3>

  <p>Lens can render any DOM element to a compact text grid:</p>

  <pre><code>Lens.look(<span class="str">'#studio-container'</span>, {width: <span class="num">60</span>, height: <span class="num">20</span>})
<span class="result">// â†’ "127 elements
//   0123456789012345678901234567890123456789
//  0â”‚+ New              Examples...        â–¶ Run  ğŸ’¾
//  1â”‚Files   â†»         API Reference       Git
//  2â”‚ğŸ“„ app.js          ALGO.createWindow   Commit
//  3â”‚ğŸ“„ utils.js        Create a new window History
// ..."</span></code></pre>

  <p>The AI can "see" the UI without parsing verbose HTML. Then target elements by position:</p>

  <pre><code>Lens.click(<span class="num">2</span>, <span class="num">3</span>)   <span class="cm">// Click "app.js" at row 2, col 3</span>
<span class="result">// â†’ "âœ“ clicked"</span></code></pre>

  <h3>Position Inspection</h3>

  <p>Discover what actions are available at any position:</p>

  <pre><code>Lens.at(<span class="num">2</span>, <span class="num">3</span>)   <span class="cm">// What's at row 2, col 3?</span>
<span class="result">// â†’ "A:\"app.js\" [click,href:/files/app.js]"</span></code></pre>

  <p>Or list all interactive elements in a container:</p>

  <pre><code>Lens.actions(<span class="str">'#toolbar'</span>)
<span class="result">// â†’ "0:button:\"Run\"
//    1:button:\"Save\"
//    2:a:\"Settings\"
//    3:input:\"Search...\""</span>

Lens.do(<span class="str">'#toolbar'</span>, <span class="num">0</span>)  <span class="cm">// Click "Run" button</span>
<span class="result">// â†’ "âœ“ clicked"</span></code></pre>

  <p><strong>Why this matters:</strong> Instead of guessing what elements exist or parsing HTML, the AI can inspect a location and see exactly what actions are available. This enables exploration of unfamiliar UIs.</p>

  <h3>State & Helpers</h3>

  <table>
    <tr><th>Command</th><th>Purpose</th><th>Output</th></tr>
    <tr><td><code>Lens.state()</code></td><td>Compact system state</td><td><code>w:Studio|Shell e:0 u:william</code></td></tr>
    <tr><td><code>Lens.dash()</code></td><td>Dashboard with icons</td><td><code>[Studio|Shell] ğŸ®ğŸ“ğŸ’»</code></td></tr>
    <tr><td><code>Lens.define(name, fn)</code></td><td>Register helper</td><td><code>âœ“ name</code></td></tr>
    <tr><td><code>Lens.call(name, args)</code></td><td>Call helper</td><td>Result</td></tr>
    <tr><td><code>Lens.look(sel, opts)</code></td><td>Render to text grid</td><td>Numbered rows</td></tr>
    <tr><td><code>Lens.at(row, col)</code></td><td>What's at position?</td><td>Element + actions</td></tr>
    <tr><td><code>Lens.click(row, col)</code></td><td>Click at position</td><td><code>âœ“ clicked "text"</code></td></tr>
    <tr><td><code>Lens.actions(sel)</code></td><td>List all interactive</td><td>Indexed action list</td></tr>
    <tr><td><code>Lens.do(sel, index)</code></td><td>Execute by index</td><td><code>âœ“ clicked</code></td></tr>
  </table>

  <h2>Persistent Helpers</h2>

  <p>Define reusable functions that persist across calls:</p>

  <pre><code>Lens.define(<span class="str">'pos'</span>, () => `P(${px},${py})`)
<span class="result">// â†’ "âœ“ pos"</span>

Lens.call(<span class="str">'pos'</span>)
<span class="result">// â†’ "P(3,5)"</span>

<span class="cm">// Define more complex helpers</span>
Lens.define(<span class="str">'move'</span>, <span class="str">'(dx,dy) => { px+=dx; py+=dy; render(); return Lens.call("pos"); }'</span>)
Lens.call(<span class="str">'move'</span>, <span class="num">1</span>, <span class="num">0</span>)
<span class="result">// â†’ "P(4,5)"</span></code></pre>

  <p><strong>Why helpers matter:</strong> Instead of re-sending the same code every call, define it once. Reduces token usage by 80%+ for repeated operations.</p>

  <h2>Batch Operations</h2>

  <p>Chain multiple operations in a single call:</p>

  <pre><code>Lens.batch([
  [<span class="str">'setLine'</span>, <span class="num">42</span>, <span class="str">'const x = await fetch(url);'</span>],
  [<span class="str">'setLine'</span>, <span class="num">43</span>, <span class="str">'const data = await x.json();'</span>],
  [<span class="str">'save'</span>],
  [<span class="str">'run'</span>]
])
<span class="result">// â†’ "âœ“setLine âœ“setLine âœ“save âœ“run"</span></code></pre>

  <p><strong>Four operations. One API call. One response.</strong></p>

  <h2>Compact State</h2>

  <p>Get system state in minimal tokens:</p>

  <pre><code>Lens.state()
<span class="result">// â†’ "w:Studio|Shell e:0 u:william"</span>

Lens.dash()
<span class="result">// â†’ "[Studio|Shell|(Settings)] ğŸ®ğŸ“ğŸ’»ğŸŒâš™ï¸"</span></code></pre>

  <p>One line tells you: active windows, minimized windows (in parens), error count, current user, and available apps. No JSON parsing needed.</p>

  <h2>Why This Matters</h2>

  <blockquote>
    <p>"The best interface for AI isn't a better API. It's an interface designed from scratch for how AI actually worksâ€”in tokens, not pixels."</p>
  </blockquote>

  <p>Lens inverts the traditional assumption. Instead of adapting AI to human interfaces, we built an interface for AI that humans can also use.</p>

  <h3>For AI:</h3>
  <ul>
    <li>See code with line numbers for addressing</li>
    <li>Edit surgically without reading/rewriting entire files</li>
    <li>See UI state without parsing HTML</li>
    <li>Know immediately if edits worked</li>
    <li>Batch operations to minimize round-trips</li>
  </ul>

  <h3>For Humans:</h3>
  <ul>
    <li>Watch AI navigate code in real-time</li>
    <li>See exactly which lines are being touched</li>
    <li>Faster iteration cycles</li>
    <li>Lower costs (fewer tokens = cheaper)</li>
  </ul>

  <h3>Live Collaboration</h3>

  <p>When AI uses Lens, you see everything happen in real-time. Buttons click. Text appears. Windows open. It's not a transcript of what happenedâ€”it's happening right now, in your browser.</p>

  <p>Ask the AI to "open Studio and fix the bug in app.js" and watch as it:</p>
  <ol>
    <li>Opens the Studio window</li>
    <li>Navigates to app.js</li>
    <li>Searches for the bug with <code>Lens.grep('error')</code></li>
    <li>Edits the specific line with <code>Lens.setLine()</code></li>
    <li>Saves and runs to verify</li>
  </ol>

  <p>You can interrupt, redirect, or take over at any point. It's pair programming where your partner can see your screen.</p>

  <hr>

  <h2>The Bridge: Real-Time Connection</h2>

  <p>Lens is powered by <strong>eye</strong>â€”a WebSocket bridge that gives AI direct access to the browser's JavaScript VM. No HTTP overhead. No JSON wrapping. Just raw JavaScript execution in ~25ms.</p>

  <pre><code><span class="cm">// From the terminal, execute JS in your browser</span>
eye <span class="str">'document.title'</span>
<span class="result">â†’ "FunctionServer"</span>

eye <span class="str">'Lens.look("#desktop")'</span>
<span class="result">â†’ "42 elements
    01234567890123456789...
   0â”‚ğŸ“ Documents
   1â”‚ğŸ“ Projects
   2â”‚ğŸ® game.js
   ..."</span>

eye <span class="str">'Lens.click(2, 0)'</span>
<span class="result">â†’ "âœ“ clicked \"game.js\""</span></code></pre>

  <p>The connection is bidirectional. The AI can:</p>
  <ul>
    <li><strong>Read</strong> â€” Query DOM, check state, inspect elements</li>
    <li><strong>Write</strong> â€” Click buttons, fill forms, modify content</li>
    <li><strong>Execute</strong> â€” Run any JavaScript, define functions, patch code live</li>
    <li><strong>Watch</strong> â€” See changes instantly as they happen</li>
  </ul>

  <p>This isn't remote control through an API. The AI is <em>inside</em> the browser, with the same access as code running in the console.</p>

  <hr>

  <h2>The Bigger Picture</h2>

  <p>Lens is part of <strong>Studio</strong>, a full IDE built for FunctionServer. But the ideas generalize:</p>

  <ul>
    <li><strong>Addressable content</strong> â€” Everything has coordinates (line numbers, row/col positions)</li>
    <li><strong>Compact output</strong> â€” Status in one line, not JSON blobs</li>
    <li><strong>Surgical operations</strong> â€” Edit the smallest possible unit</li>
    <li><strong>Batch support</strong> â€” Multiple operations per call</li>
    <li><strong>Verification built-in</strong> â€” Every operation confirms success</li>
  </ul>

  <p>These principles could apply to any interface. What would an AI-first spreadsheet look like? An AI-first design tool? An AI-first terminal?</p>

  <p>We're just getting started.</p>

  <hr>

  <h2>Try It</h2>

  <p>Lens is built into FunctionServer Studio. To use it:</p>

  <ol>
    <li>Go to <a href="/app">functionserver.com/app</a></li>
    <li>Open Studio from the Programs menu (or run <code>~/studio.js</code>)</li>
    <li>Use Lens commands in the console or via <code>eye</code></li>
  </ol>

  <pre><code><span class="cm">// Via eye MCP tool</span>
eye <span class="str">'Lens.code()'</span>
eye <span class="str">'Lens.setLine(42, "fixed")'</span>
eye <span class="str">'Lens.save()'</span></code></pre>

  <hr>

  <div class="cta-section">
    <p><strong>Launch:</strong> <a href="/app">functionserver.com/app</a></p>
    <p><strong>Code:</strong> <a href="https://github.com/williamsharkey/functionserver">github.com/williamsharkey/functionserver</a></p>
    <p><strong>Studio:</strong> <a href="https://github.com/williamsharkey/fs-studio">github.com/williamsharkey/fs-studio</a></p>
  </div>

</article>

<footer>
  <a href="/">FunctionServer</a> Â· Open source under MIT
</footer>

</body>
</html>
