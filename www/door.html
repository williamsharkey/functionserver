<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>I Let AI Debug My Browser From the Command Line</title>
<meta name="description" content="An AI that can see, inspect, and manipulate a web browser in real-time via MCP.">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Newsreader:ital,opsz,wght@0,6..72,400;1,6..72,400&display=swap" rel="stylesheet">
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }

:root {
  --bg: #09090b;
  --surface: #18181b;
  --text: #fafafa;
  --text-secondary: #a1a1aa;
  --text-tertiary: #52525b;
  --border: #27272a;
  --accent: #a78bfa;
  --green: #86efac;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', 'Segoe UI', system-ui, sans-serif;
  font-size: 16px;
  line-height: 1.7;
  color: var(--text);
  background: var(--bg);
  -webkit-font-smoothing: antialiased;
}

/* Subtle grid background */
.grid-bg {
  position: fixed;
  inset: 0;
  z-index: -1;
  background-image:
    linear-gradient(rgba(255,255,255,0.02) 1px, transparent 1px),
    linear-gradient(90deg, rgba(255,255,255,0.02) 1px, transparent 1px);
  background-size: 60px 60px;
  mask-image: radial-gradient(ellipse at 50% 0%, black 0%, transparent 70%);
}

nav {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  padding: 16px 32px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  z-index: 100;
  background: rgba(9, 9, 11, 0.8);
  backdrop-filter: blur(12px);
  border-bottom: 1px solid var(--border);
}

.logo {
  font-size: 14px;
  font-weight: 500;
  color: var(--text);
  text-decoration: none;
}

nav a {
  color: var(--text-secondary);
  text-decoration: none;
  font-size: 13px;
}

nav a:hover { color: var(--text); }

.nav-cta {
  background: var(--text);
  color: var(--bg) !important;
  padding: 8px 16px;
  border-radius: 6px;
  font-weight: 500;
}

article {
  max-width: 680px;
  margin: 0 auto;
  padding: 120px 24px 80px;
}

h1 {
  font-family: 'Newsreader', 'New York', Georgia, serif;
  font-size: clamp(32px, 5vw, 48px);
  font-weight: 400;
  line-height: 1.2;
  margin-bottom: 24px;
  letter-spacing: -0.02em;
}

.lead {
  font-size: 18px;
  color: var(--text-secondary);
  margin-bottom: 48px;
  line-height: 1.8;
}

h2 {
  font-family: 'Newsreader', 'New York', Georgia, serif;
  font-size: 28px;
  font-weight: 400;
  margin-top: 64px;
  margin-bottom: 20px;
  letter-spacing: -0.01em;
}

h3 {
  font-size: 18px;
  font-weight: 500;
  margin-top: 40px;
  margin-bottom: 16px;
  color: var(--accent);
}

p {
  margin-bottom: 20px;
  color: var(--text-secondary);
  line-height: 1.8;
}

strong { color: var(--text); font-weight: 500; }
em { color: var(--text); font-style: italic; }

ol, ul {
  margin-bottom: 20px;
  padding-left: 24px;
  color: var(--text-secondary);
}

li { margin-bottom: 8px; }

code {
  font-family: 'SF Mono', ui-monospace, monospace;
  font-size: 14px;
  background: var(--surface);
  padding: 2px 6px;
  border-radius: 4px;
  color: var(--accent);
}

pre {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 20px 24px;
  margin: 24px 0;
  overflow-x: auto;
}

pre code {
  background: none;
  padding: 0;
  font-size: 13px;
  line-height: 1.7;
  color: var(--text);
}

.cm { color: var(--text-tertiary); }
.kw { color: var(--accent); }
.str { color: var(--green); }

table {
  width: 100%;
  border-collapse: collapse;
  margin: 24px 0;
  font-size: 14px;
}

th, td {
  padding: 12px 16px;
  text-align: left;
  border-bottom: 1px solid var(--border);
}

th {
  background: var(--surface);
  color: var(--text);
  font-weight: 500;
}

td { color: var(--text-secondary); }

blockquote {
  background: var(--surface);
  border-left: 3px solid var(--accent);
  padding: 24px 28px;
  margin: 48px 0;
  border-radius: 0 8px 8px 0;
}

blockquote strong {
  display: block;
  color: var(--accent);
  font-size: 15px;
  margin-bottom: 16px;
}

blockquote p {
  margin-bottom: 16px;
  font-size: 15px;
}

blockquote p:last-child { margin-bottom: 0; }

.ascii-art {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 20px;
  margin: 24px 0;
  font-family: 'SF Mono', ui-monospace, monospace;
  font-size: 12px;
  line-height: 1.3;
  color: var(--accent);
  overflow-x: auto;
}

hr {
  border: none;
  border-top: 1px solid var(--border);
  margin: 48px 0;
}

.quote-block {
  text-align: center;
  font-family: 'Newsreader', 'New York', Georgia, serif;
  font-style: italic;
  color: var(--text-secondary);
  margin: 48px 0;
  font-size: 20px;
}

.cta-section {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 32px;
  margin: 48px 0;
  text-align: center;
}

.cta-section p { margin-bottom: 8px; }
.cta-section a { color: var(--accent); text-decoration: none; }
.cta-section a:hover { text-decoration: underline; }

footer {
  padding: 40px 24px;
  text-align: center;
  border-top: 1px solid var(--border);
}

footer a { color: var(--accent); text-decoration: none; }

@media (max-width: 600px) {
  h1 { font-size: 28px; }
  article { padding: 100px 16px 60px; }
  nav { padding: 16px 20px; }
}
</style>
</head>
<body>

<div class="grid-bg"></div>

<nav>
  <a href="/" class="logo">FunctionServer</a>
  <a href="/app" class="nav-cta">Enter</a>
</nav>

<article>
  <h1>I Let AI Debug My Browser From the Command Line</h1>

  <p class="lead">Today I built something that felt like crossing a threshold: an AI that can see, inspect, and manipulate a web browser in real-time from completely outside it. Not Puppeteer. Not Selenium. An LLM with authenticated API access to your DOM.</p>

  <h2>What We Built</h2>

  <p>FunctionServer is a browser-based operating system (think Windows 95 aesthetic, runs at functionserver.com). It has windows, apps, a start menu, the works. We added:</p>

  <ol>
    <li><strong>MCP Bridge</strong> - A Model Context Protocol endpoint that routes commands to the browser via WebSocket</li>
    <li><strong>Authenticated API</strong> - Bearer tokens so only you can control your session</li>
    <li><strong>Browser Tools</strong> - <code>algo_eval</code>, <code>algo_getState</code>, <code>algo_query</code>, <code>algo_click</code>, <code>algo_openApp</code>, etc.</li>
  </ol>

  <p>The result: any LLM with HTTP access can execute JavaScript in your browser, query the DOM, click buttons, and open apps - all via curl.</p>

  <pre><code>curl -X POST https://functionserver.com/api/mcp \
  -H "Authorization: Bearer $TOKEN" \
  -d '{"method":"tools/call","params":{"name":"algo_openApp","arguments":{"appId":"calculator"}}}'</code></pre>

  <p>A window opens in your browser. From my terminal. No WebDriver. No browser automation framework. Just HTTPS.</p>

  <h2>The Live Debugging Sessions</h2>

  <h3>Session 1: The Invisible Menu</h3>

  <p>The user reported that the Programs submenu was appearing off-screen. Instead of the normal debug cycle (inspect element, edit CSS, refresh, repeat), I did this:</p>

  <p><strong>1. Diagnosed remotely via MCP:</strong></p>
  <pre><code><span class="cm">// Injected via algo_eval from my terminal</span>
<span class="kw">const</span> submenu = document.getElementById(<span class="str">'programs-menu'</span>);
<span class="kw">const</span> rect = submenu.getBoundingClientRect();
<span class="cm">// Result: {bottom: 343, taskbarTop: 383}</span>
<span class="cm">// The menu was 40px too high!</span></code></pre>

  <p><strong>2. Found the conflict:</strong></p>
  <pre><code><span class="kw">const</span> cs = getComputedStyle(submenu);
<span class="cm">// inline: {top: "auto", bottom: "39px"}</span>
<span class="cm">// computed: {top: "0px", bottom: "80px"}  <- CSS overriding inline!</span></code></pre>

  <p><strong>3. Fixed it with setProperty + !important:</strong></p>
  <pre><code>submenu.style.setProperty(<span class="str">'bottom'</span>, <span class="str">'40px'</span>, <span class="str">'important'</span>);
submenu.style.setProperty(<span class="str">'top'</span>, <span class="str">'auto'</span>, <span class="str">'important'</span>);
<span class="cm">// Both menus now at 383.3px - aligned!</span></code></pre>

  <p><strong>4. Hot-reloaded the function</strong> without refreshing:</p>
  <pre><code>window.openSubmenu = <span class="kw">function</span>(el) {
  <span class="cm">// ... patched code with setProperty ...</span>
};</code></pre>

  <p>Total time: ~5 minutes. Zero page refreshes.</p>

  <h3>Session 2: The Missing Calendar</h3>

  <p>User: "Calendar looks like unstyled webpage, missing CSS or something."</p>

  <pre><code><span class="cm">// Check what classes the calendar uses</span>
<span class="kw">const</span> grid = document.querySelector(<span class="str">'.cal-grid'</span>);
getComputedStyle(grid).display;  <span class="cm">// "block" - no grid!</span>

<span class="cm">// The CSS had .calendar-app-header but the app uses .cal-header</span>
<span class="cm">// Completely different naming conventions. Injected fix:</span>
<span class="kw">const</span> style = document.createElement(<span class="str">'style'</span>);
style.textContent = <span class="str">`
  .cal-header { display: flex; background: #008080; color: white; }
  .cal-grid { display: grid; grid-template-columns: repeat(7, 1fr); }
  .cal-day { background: white; cursor: pointer; }
  .cal-day.today { background: #c0e0e0; }
`</span>;
document.head.appendChild(style);
<span class="cm">// Calendar instantly styled!</span></code></pre>

  <h3>Session 3: Live WebGL Desktop Background</h3>

  <p>This one was just for fun. I wrote a shader in Shade Station, then via MCP:</p>

  <pre><code><span class="cm">// Create canvas behind desktop icons</span>
<span class="kw">const</span> canvas = document.createElement(<span class="str">'canvas'</span>);
canvas.style.cssText = <span class="str">'position:absolute;top:0;left:0;width:100%;height:100%;z-index:0'</span>;
desktop.insertBefore(canvas, desktop.firstChild);

<span class="cm">// Initialize WebGL, compile shader, start render loop</span>
<span class="kw">const</span> gl = canvas.getContext(<span class="str">'webgl'</span>);
<span class="cm">// ... shader compilation ...</span>
<span class="kw">function</span> render() {
  gl.uniform1f(timeLoc, time += 0.016);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  requestAnimationFrame(render);
}
render();</code></pre>

  <p>Now there's a hypnotic tunnel shader animating as the desktop wallpaper. All injected via MCP. The user watched it appear in real-time.</p>

  <h2>The MCP Debugging Technique</h2>

  <table>
    <tr><th>Step</th><th>Tool</th><th>Purpose</th></tr>
    <tr><td>Measure</td><td><code>getBoundingClientRect()</code></td><td>Get exact pixel positions</td></tr>
    <tr><td>Diagnose</td><td><code>getComputedStyle()</code> vs inline</td><td>Find style conflicts</td></tr>
    <tr><td>Inject CSS</td><td><code>document.createElement('style')</code></td><td>Test fixes instantly</td></tr>
    <tr><td>Force override</td><td><code>setProperty('prop', 'val', 'important')</code></td><td>Beat stubborn CSS</td></tr>
    <tr><td>Patch functions</td><td><code>window.fn = function() {...}</code></td><td>Hot-reload JS</td></tr>
    <tr><td>Verify</td><td><code>getBoundingClientRect()</code> again</td><td>Confirm fix worked</td></tr>
  </table>

  <p>The browser becomes a REPL you can poke from anywhere.</p>

  <h2>The Architecture: Neo and Morpheus</h2>

  <p>We ended up with two personas:</p>

  <ul>
    <li><strong>Neo</strong> - AI running inside FunctionServer's terminal (has shell access, runs on server)</li>
    <li><strong>Morpheus</strong> - AI running anywhere else (laptop, cloud, phone), controlling the browser via MCP</li>
  </ul>

  <p>For users without shell access, there's AI Eyes - a window that shows an ASCII face watching you, logging MCP activity as it happens:</p>

  <div class="ascii-art">+-----------------------------+
|      o            o        |  <- blinks when commands arrive
|           ----              |
|   Morpheus connected        |
|   --- MCP Activity ---      |
|   algo_openApp(calendar) +  |
|   algo_eval              +  |
|   algo_eval              +  |
+-----------------------------+</div>

  <hr>

  <blockquote>
    <strong>A note on architecture</strong>
    <p>Live patching exists. Browser automation exists. MITM injection exists. So what's actually new here?</p>
    <p>In a traditional setup, apps are compiled binaries or isolated processes. You automate them from outside via WebDriver protocols. The AI is a client, the app is a server.</p>
    <p>In FunctionServer, apps <em>are</em> JavaScript artifacts running in the same VM that MCP accesses. When an AI calls <code>getBoundingClientRect()</code>, it's touching the same DOM element the user sees. When it patches <code>window.openSubmenu</code>, that's the real running function. The AI doesn't automate the OS—it inhabits it.</p>
    <p>This creates an interesting question: how do you version control a system that's constantly being reshaped?</p>
    <p>You don't. Each app becomes its own repository. What you version is the <em>protocol</em>—the ALGO API, the conventions for file type registration, the pubsub message format. The OS defines the rules. Users and AI agents shape whatever they want within them.</p>
    <p>We're not sure yet what this topology enables. But there's something in the architecture worth exploring—a cloud OS where apps, AI, and debugging tools share the same address space.</p>
  </blockquote>

  <hr>

  <h2>Why This Matters</h2>

  <p><strong>1. The debugging loop collapsed.</strong></p>
  <p>Old way: write code -> deploy -> refresh -> inspect -> guess -> repeat</p>
  <p>New way: inspect live -> measure -> test fix -> verify -> commit</p>

  <p><strong>2. AI assistants can have eyes.</strong></p>
  <p>Most AI coding assistants are blind. They read your code, guess what it does, and hope. With MCP, AI can query element positions, check computed styles, inject test fixes, and verify they worked - all before touching your source files.</p>

  <p><strong>3. It's surprisingly precise.</strong></p>
  <p>When I needed to align two menus, I didn't guess. I measured:</p>
  <pre><code>startMenu.bottom: 383.3px
programsMenu.bottom: 343.3px  <span class="cm">// 40px off!</span>
<span class="cm">// After fix:</span>
programsMenu.bottom: 383.3px  <span class="cm">// Aligned!</span></code></pre>

  <p><strong>4. Live shader desktop backgrounds.</strong></p>
  <p>I didn't plan this feature. I was testing Shade Station via MCP, saved a shader, and thought "what if the desktop could render this?" Twenty minutes later, there's a hypnotic tunnel animating behind the icons. That's the power of having direct DOM access.</p>

  <h2>The Code</h2>

  <p>Open source: <a href="https://github.com/williamsharkey/functionserver">github.com/williamsharkey/functionserver</a></p>

  <p>Key files:</p>
  <ul>
    <li><code>go/main.go</code> - MCP endpoint, WebSocket routing, auth</li>
    <li><code>core/apps/claude-eyes.js</code> - Visual MCP activity monitor</li>
    <li><code>core/apps/shade-station.js</code> - WebGL shader editor with save-to-desktop</li>
    <li><code>CLAUDE-MORPHEUS.md</code> - Docs for external Claude instances</li>
  </ul>

  <h2>The Uncomfortable Question</h2>

  <p>Yes, this means an AI can manipulate your browser. That's why there's auth. Your session token, your control.</p>

  <p>The upside: an AI can now help you in ways that weren't possible before. It can see what you see. It can try things and check if they worked. It can debug CSS without asking you to "open DevTools and tell me what you see."</p>

  <p>Is that worth the tradeoff? For me, watching AI inject a WebGL shader as my desktop background from a terminal on my laptop - yeah, it's worth it.</p>

  <hr>

  <p class="quote-block">"I'm trying to free your mind, Neo. But I can only show you the door. You're the one that has to walk through it."</p>

  <p style="text-align: center; color: var(--text-secondary);">We built the door. Come walk through.</p>

  <hr>

  <h2>What Came Next: Lens</h2>

  <p>After months of using MCP to debug the browser, we noticed patterns. AI was wasting tokens reading entire files to make one-line changes. It couldn't "see" UI state without verbose DOM dumps. Every edit was expensive.</p>

  <p>So we built <strong>Lens</strong>—a token-efficient viewport designed for AI. Instead of reading a 1000-line file, AI can:</p>

  <pre><code>Lens.grep(<span class="str">'fetchData'</span>)           <span class="cm">// → "42:async function fetchData"</span>
Lens.setLine(<span class="num">42</span>, <span class="str">'new code'</span>)    <span class="cm">// → "✓ L42"</span>
Lens.save()                      <span class="cm">// → "✓ saved"</span></code></pre>

  <p>Three calls. Zero file reads. 60x fewer tokens.</p>

  <p>Lens can also render DOM to a text grid, letting Claude "see" the UI without parsing HTML. It's part of <strong>Studio</strong>, a full IDE built for FunctionServer.</p>

  <p><a href="/lens.html">Read the full Lens article →</a></p>

  <hr>

  <div class="cta-section">
    <p><strong>Try it:</strong> <a href="/app">functionserver.com/app</a></p>
    <p><strong>Lens:</strong> <a href="/lens.html">Read about AI-first UI design</a></p>
    <p><strong>Code:</strong> <a href="https://github.com/williamsharkey/functionserver">github.com/williamsharkey/functionserver</a></p>
  </div>

</article>

<footer>
  <a href="/">FunctionServer</a> · Open source under MIT
</footer>

</body>
</html>
